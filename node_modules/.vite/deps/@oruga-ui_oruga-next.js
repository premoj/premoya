import {
  Comment,
  Fragment,
  Text,
  Transition,
  capitalize,
  createApp,
  createBlock,
  createCommentVNode,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  h,
  mergeProps,
  openBlock,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDirective,
  resolveDynamicComponent,
  toDisplayString,
  toHandlers,
  vModelCheckbox,
  vModelRadio,
  vModelSelect,
  vShow,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-DPG7LVJ7.js";
import "./chunk-FAW2VN4A.js";

// node_modules/@oruga-ui/oruga-next/dist/esm/helpers.mjs
function signPoly(value) {
  if (value < 0)
    return -1;
  return value > 0 ? 1 : 0;
}
var sign = Math.sign || signPoly;
function hasFlag(val, flag) {
  return (val & flag) === flag;
}
function mod(n, mod2) {
  return (n % mod2 + mod2) % mod2;
}
function bound(val, min, max) {
  return Math.max(min, Math.min(max, val));
}
function getValueByPath(obj, path, defaultValue = void 0) {
  const value = path.split(".").reduce((o, i) => typeof o !== "undefined" ? o[i] : void 0, obj);
  return typeof value !== "undefined" ? value : defaultValue;
}
function indexOf(array, obj, fn) {
  if (!array)
    return -1;
  if (!fn || typeof fn !== "function")
    return array.indexOf(obj);
  for (let i = 0; i < array.length; i++) {
    if (fn(array[i], obj)) {
      return i;
    }
  }
  return -1;
}
var isObject = (item) => typeof item === "object" && !Array.isArray(item);
var mergeFn = (target, source, deep = false) => {
  if (deep || !Object.assign) {
    const isDeep = (prop) => isObject(source[prop]) && target !== null && Object.prototype.hasOwnProperty.call(target, prop) && isObject(target[prop]);
    let replaced;
    if (source === null || typeof source === "undefined") {
      replaced = false;
    } else {
      replaced = Object.getOwnPropertyNames(source).map((prop) => ({ [prop]: isDeep(prop) ? mergeFn(target[prop], source[prop], deep) : source[prop] })).reduce((a, b) => ({ ...a, ...b }), {});
    }
    return {
      ...target,
      ...replaced
    };
  } else {
    return Object.assign(target, source);
  }
};
var merge = mergeFn;
var isMobile = {
  Android: function() {
    return typeof window !== "undefined" && window.navigator.userAgent.match(/Android/i);
  },
  BlackBerry: function() {
    return typeof window !== "undefined" && window.navigator.userAgent.match(/BlackBerry/i);
  },
  iOS: function() {
    return typeof window !== "undefined" && window.navigator.userAgent.match(/iPhone|iPad|iPod/i);
  },
  Opera: function() {
    return typeof window !== "undefined" && window.navigator.userAgent.match(/Opera Mini/i);
  },
  Windows: function() {
    return typeof window !== "undefined" && window.navigator.userAgent.match(/IEMobile/i);
  },
  any: function() {
    return isMobile.Android() || isMobile.BlackBerry() || isMobile.iOS() || isMobile.Opera() || isMobile.Windows();
  }
};
function removeElement(el) {
  if (typeof el.remove !== "undefined") {
    el.remove();
  } else if (typeof el.parentNode !== "undefined" && el.parentNode !== null) {
    el.parentNode.removeChild(el);
  }
}
function createAbsoluteElement(el) {
  const root = document.createElement("div");
  root.style.position = "absolute";
  root.style.left = "0px";
  root.style.top = "0px";
  const wrapper = document.createElement("div");
  root.appendChild(wrapper);
  wrapper.appendChild(el);
  document.body.appendChild(root);
  return root;
}
function escapeRegExpChars(value) {
  if (!value)
    return value;
  return value.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
function toCssDimension(width) {
  return width === void 0 ? null : isNaN(width) ? width : width + "px";
}
function blankIfUndefined(value) {
  return typeof value !== "undefined" && value !== null ? value : "";
}
function defaultIfUndefined(value, defaultValue) {
  return typeof value !== "undefined" && value !== null ? value : defaultValue;
}
function getMonthNames(locale = void 0, format = "long") {
  const dates = [];
  for (let i = 0; i < 12; i++) {
    dates.push(new Date(2e3, i, 15));
  }
  const dtf = new Intl.DateTimeFormat(locale, {
    month: format
  });
  return dates.map((d) => dtf.format(d));
}
function getWeekdayNames(locale = void 0, firstDayOfWeek = 0, format = "narrow") {
  const dates = [];
  for (let i = 1, j = 0; j < 7; i++) {
    const d = new Date(2e3, 0, i);
    const day = d.getDay();
    if (day === firstDayOfWeek || j > 0) {
      dates.push(d);
      j++;
    }
  }
  const dtf = new Intl.DateTimeFormat(locale, {
    weekday: format
  });
  return dates.map((d) => dtf.format(d));
}
function matchWithGroups(pattern, str) {
  const matches = str.match(pattern);
  return pattern.toString().match(/<(.+?)>/g).map((group) => {
    const groupMatches = group.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return group.match(/<(.+)>/)[1];
  }).reduce((acc, curr, index29) => {
    if (matches && matches.length > index29) {
      acc[curr] = matches[index29 + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}
function debounce(func, wait, immediate) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    const later = function() {
      timeout = null;
      if (!immediate)
        func.apply(context, args);
    };
    const callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow)
      func.apply(context, args);
  };
}
function endsWith(str, suffix) {
  return str.indexOf(suffix, str.length - suffix.length) !== -1;
}
var isDefined = (d) => d !== void 0;
function removeDiacriticsFromString(value) {
  if (!value)
    return value;
  return value.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
}

// node_modules/@oruga-ui/oruga-next/dist/esm/config.mjs
var config = {
  iconPack: "mdi",
  useHtml5Validation: true,
  statusIcon: true,
  transformClasses: void 0
};
var setOptions = (options) => {
  config = options;
};
var getOptions = () => {
  return config;
};
var VueInstance;
var setVueInstance = (Vue) => {
  VueInstance = Vue;
};
var Programmatic = {
  getOptions,
  setOptions(options) {
    setOptions(merge(getOptions(), options, true));
  }
};
var Plugin = {
  install(Vue, options = {}) {
    setVueInstance(Vue);
    setOptions(merge(getOptions(), options, true));
  }
};

// node_modules/@oruga-ui/oruga-next/dist/esm/plugins-8d3efc9b.mjs
var _defaultSuffixProcessor = (input, suffix) => {
  return blankIfUndefined(input).split(" ").filter((cls) => cls.length > 0).map((cls) => cls + suffix).join(" ");
};
var _getContext = (vm) => {
  const computedNames = vm.$options.computed ? Object.keys(vm.$options.computed) : [];
  const computed = computedNames.filter((e) => !endsWith(e, "Classes")).reduce((o, key) => {
    o[key] = vm[key];
    return o;
  }, {});
  return { props: vm.$props, data: vm.$data, computed };
};
var BaseComponentMixin = defineComponent({
  isOruga: true,
  props: {
    override: Boolean
  },
  methods: {
    computedClass(field, defaultValue, suffix = "") {
      const config2 = this.$props.override === true ? {} : getOptions();
      const override = this.$props.override || getValueByPath(config2, `${this.$options.configField}.override`, false);
      const overrideClass = getValueByPath(config2, `${this.$options.configField}.${field}.override`, override);
      const globalTransformClasses = getValueByPath(config2, `transformClasses`, void 0);
      const localTransformClasses = getValueByPath(config2, `${this.$options.configField}.transformClasses`, void 0);
      let globalClass = getValueByPath(config2, `${this.$options.configField}.${field}.class`, "") || getValueByPath(config2, `${this.$options.configField}.${field}`, "");
      let currentClass = getValueByPath(this.$props, field);
      if (Array.isArray(currentClass)) {
        currentClass = currentClass.join(" ");
      }
      if (defaultValue.search("{*}") !== -1) {
        defaultValue = defaultValue.replace(/\{\*\}/g, suffix);
      } else {
        defaultValue = defaultValue + suffix;
      }
      let context = null;
      if (typeof currentClass === "function") {
        context = _getContext(this);
        currentClass = currentClass(suffix, context);
      } else {
        currentClass = _defaultSuffixProcessor(currentClass, suffix);
      }
      if (typeof globalClass === "function") {
        globalClass = globalClass(suffix, context || _getContext(this));
      } else {
        globalClass = _defaultSuffixProcessor(globalClass, suffix);
      }
      let appliedClasses = `${override && !overrideClass || !override && !overrideClass ? defaultValue : ""} ${blankIfUndefined(globalClass)} ${blankIfUndefined(currentClass)}`.trim().replace(/\s\s+/g, " ");
      if (localTransformClasses) {
        appliedClasses = localTransformClasses(appliedClasses);
      }
      if (globalTransformClasses) {
        appliedClasses = globalTransformClasses(appliedClasses);
      }
      return appliedClasses;
    }
  }
});
var oruga = {};
function addProgrammatic(property, component) {
  oruga[property] = component;
}
function useProgrammatic() {
  return { oruga, addProgrammatic };
}
var registerPlugin = (app, plugin) => {
  app.use(plugin);
};
var registerComponent = (app, component) => {
  app.component(component.name, component);
};
var registerComponentProgrammatic = (app, property, component) => {
  const { oruga: oruga2, addProgrammatic: addProgrammatic2 } = useProgrammatic();
  addProgrammatic2(property, component);
  if (!(app._context.provides && app._context.provides.oruga))
    app.provide("oruga", oruga2);
  if (!app.config.globalProperties.$oruga)
    app.config.globalProperties.$oruga = oruga2;
};

// node_modules/@oruga-ui/oruga-next/dist/esm/Icon-f48ba8d7.mjs
var mdiIcons = {
  sizes: {
    "default": "mdi-24px",
    "small": null,
    "medium": "mdi-36px",
    "large": "mdi-48px"
  },
  iconPrefix: "mdi-"
};
var faIcons = () => {
  const iconComponent = getValueByPath(getOptions(), "iconComponent");
  const faIconPrefix = iconComponent ? "" : "fa-";
  return {
    sizes: {
      "default": null,
      "small": null,
      "medium": faIconPrefix + "lg",
      "large": faIconPrefix + "2x"
    },
    iconPrefix: faIconPrefix,
    internalIcons: {
      "check": "check",
      "information": "info-circle",
      "alert": "exclamation-triangle",
      "alert-circle": "exclamation-circle",
      "arrow-up": "arrow-up",
      "chevron-right": "angle-right",
      "chevron-left": "angle-left",
      "chevron-down": "angle-down",
      "chevron-up": "angle-up",
      "eye": "eye",
      "eye-off": "eye-slash",
      "caret-down": "caret-down",
      "caret-up": "caret-up",
      "close-circle": "times-circle",
      "close": "times",
      "loading": "circle-notch"
    }
  };
};
var getIcons = () => {
  let icons = {
    mdi: mdiIcons,
    fa: faIcons(),
    fas: faIcons(),
    far: faIcons(),
    fad: faIcons(),
    fab: faIcons(),
    fal: faIcons()
  };
  const customIconPacks = getValueByPath(getOptions(), "customIconPacks");
  if (customIconPacks) {
    icons = merge(icons, customIconPacks, true);
  }
  return icons;
};
var script = defineComponent({
  name: "OIcon",
  mixins: [BaseComponentMixin],
  configField: "icon",
  props: {
    variant: [String, Object],
    component: String,
    pack: String,
    icon: String,
    size: String,
    customSize: String,
    customClass: String,
    clickable: Boolean,
    spin: Boolean,
    rotation: [Number, String],
    both: Boolean,
    rootClass: [String, Function, Array],
    clickableClass: [String, Function, Array],
    spinClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    variantClass: [String, Function, Array]
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-icon"),
        { [this.computedClass("clickableClass", "o-icon--clickable")]: this.clickable },
        { [this.computedClass("spinClass", "o-icon--spin")]: this.spin },
        { [this.computedClass("sizeClass", "o-icon--", this.size)]: this.size },
        { [this.computedClass("variantClass", "o-icon--", this.newVariant)]: this.newVariant }
      ];
    },
    rootStyle() {
      const style = {};
      if (this.rotation) {
        style["transform"] = `rotate(${this.rotation}deg)`;
      }
      return style;
    },
    iconConfig() {
      return getIcons()[this.newPack];
    },
    iconPrefix() {
      if (this.iconConfig && this.iconConfig.iconPrefix) {
        return this.iconConfig.iconPrefix;
      }
      return "";
    },
    newIcon() {
      return `${this.iconPrefix}${this.getEquivalentIconOf(this.icon)}`;
    },
    newPack() {
      return this.pack || getValueByPath(getOptions(), "iconPack", "mdi");
    },
    newVariant() {
      if (!this.variant)
        return;
      let newVariant = "";
      if (typeof this.variant === "string") {
        newVariant = this.variant;
      } else {
        newVariant = Object.keys(this.variant).filter((key) => this.variant[key])[0];
      }
      return newVariant;
    },
    newCustomSize() {
      return this.customSize || this.customSizeByPack;
    },
    customSizeByPack() {
      if (this.iconConfig && this.iconConfig.sizes) {
        if (this.size && this.iconConfig.sizes[this.size] !== void 0) {
          return this.iconConfig.sizes[this.size];
        } else if (this.iconConfig.sizes.default) {
          return this.iconConfig.sizes.default;
        }
      }
      return null;
    },
    useIconComponent() {
      if (this.component)
        return this.component;
      const component = getValueByPath(getOptions(), "iconComponent");
      if (component)
        return component;
      return null;
    }
  },
  methods: {
    getEquivalentIconOf(value) {
      if (!this.both) {
        return value;
      }
      if (this.iconConfig && this.iconConfig.internalIcons && this.iconConfig.internalIcons[value]) {
        return this.iconConfig.internalIcons[value];
      }
      return value;
    }
  }
});
function render2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "span",
    {
      class: _ctx.rootClasses,
      style: _ctx.rootStyle
    },
    [!_ctx.useIconComponent ? (openBlock(), createBlock(
      "i",
      {
        key: 0,
        class: [_ctx.newPack, _ctx.newIcon, _ctx.newCustomSize, _ctx.customClass]
      },
      null,
      2
    )) : (openBlock(), createBlock(
      Fragment,
      {
        key: 1
      },
      [createCommentVNode(" custom icon component "), (openBlock(), createBlock(
        resolveDynamicComponent(_ctx.useIconComponent),
        {
          icon: [_ctx.newPack, _ctx.newIcon],
          size: _ctx.newCustomSize,
          class: [_ctx.customClass]
        },
        null,
        8,
        ["icon", "size", "class"]
      ))],
      64
    ))],
    6
  );
}
script.render = render2;
script.__file = "src/components/icon/Icon.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/FormElementMixin-eb63f60f.mjs
var FormElementMixin = defineComponent({
  inject: {
    $field: { from: "$field", default: false }
  },
  emits: ["blur", "focus"],
  props: {
    expanded: Boolean,
    rounded: Boolean,
    icon: String,
    iconPack: String,
    autocomplete: String,
    maxlength: [Number, String],
    useHtml5Validation: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "useHtml5Validation", true);
      }
    },
    statusIcon: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "statusIcon", true);
      }
    },
    validationMessage: String
  },
  data() {
    return {
      isValid: true,
      isFocused: false,
      newIconPack: this.iconPack
    };
  },
  computed: {
    parentField() {
      return this.$field;
    },
    statusVariant() {
      if (!this.parentField)
        return;
      if (!this.parentField.newVariant)
        return;
      if (typeof this.parentField.newVariant === "string") {
        return this.parentField.newVariant;
      } else {
        for (const key in this.parentField.newVariant) {
          if (this.parentField.newVariant[key]) {
            return key;
          }
        }
      }
    },
    statusMessage() {
      if (!this.parentField)
        return;
      return this.parentField.newMessage || this.parentField.hasMessageSlot;
    },
    statusVariantIcon() {
      const statusVariantIcon = getValueByPath(getOptions(), "statusVariantIcon", {
        "success": "check",
        "danger": "alert-circle",
        "info": "information",
        "warning": "alert"
      });
      return statusVariantIcon[this.statusVariant] || "";
    }
  },
  methods: {
    focus() {
      const el = this.getElement();
      if (!el)
        return;
      this.$nextTick(() => {
        if (el)
          el.focus();
      });
    },
    onBlur(event) {
      this.isFocused = false;
      if (this.parentField) {
        this.parentField.isFocused = false;
      }
      this.$emit("blur", event);
      this.checkHtml5Validity();
    },
    onFocus(event) {
      this.isFocused = true;
      if (this.parentField) {
        this.parentField.isFocused = true;
      }
      this.$emit("focus", event);
    },
    getElement() {
      let el = this.$refs[this.$elementRef];
      while (el && el.$elementRef) {
        el = el.$refs[el.$elementRef];
      }
      return el;
    },
    setInvalid() {
      const variant = "danger";
      const message = this.validationMessage || this.getElement().validationMessage;
      this.setValidity(variant, message);
    },
    setValidity(variant, message) {
      this.$nextTick(() => {
        if (this.parentField) {
          if (!this.parentField.variant) {
            this.parentField.newVariant = variant;
          }
          if (!this.parentField.message) {
            this.parentField.newMessage = message;
          }
        }
      });
    },
    checkHtml5Validity() {
      if (!this.useHtml5Validation)
        return;
      const el = this.getElement();
      if (!el)
        return;
      if (!el.checkValidity()) {
        this.setInvalid();
        this.isValid = false;
      } else {
        this.setValidity(null, null);
        this.isValid = true;
      }
      return this.isValid;
    },
    syncFilled(value) {
      if (this.parentField) {
        this.parentField.isFilled = !!value;
      }
    }
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/Input-347ec015.mjs
var script2 = defineComponent({
  name: "OInput",
  components: {
    [script.name]: script
  },
  mixins: [BaseComponentMixin, FormElementMixin],
  configField: "input",
  inheritAttrs: false,
  emits: ["update:modelValue", "icon-click", "icon-right-click"],
  props: {
    modelValue: [Number, String],
    autocomplete: String,
    type: {
      type: String,
      default: "text"
    },
    size: String,
    variant: String,
    passwordReveal: Boolean,
    iconClickable: Boolean,
    hasCounter: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "input.counter", false);
      }
    },
    autosize: {
      type: Boolean,
      default: false
    },
    iconRight: String,
    iconRightClickable: Boolean,
    iconRightVariant: String,
    clearable: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "input.clearable", false);
      }
    },
    rootClass: [String, Function, Array],
    expandedClass: [String, Function, Array],
    iconLeftSpaceClass: [String, Function, Array],
    iconRightSpaceClass: [String, Function, Array],
    inputClass: [String, Function, Array],
    roundedClass: [String, Function, Array],
    iconLeftClass: [String, Function, Array],
    iconRightClass: [String, Function, Array],
    counterClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    variantClass: [String, Function, Array]
  },
  data() {
    return {
      newValue: this.modelValue,
      newType: this.type,
      newAutocomplete: this.autocomplete || getValueByPath(getOptions(), "input.autocompletete", "off"),
      isPasswordVisible: false,
      height: "auto"
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-ctrl-input"),
        { [this.computedClass("expandedClass", "o-ctrl-input--expanded")]: this.expanded }
      ];
    },
    inputClasses() {
      return [
        this.computedClass("inputClass", "o-input"),
        { [this.computedClass("roundedClass", "o-input--rounded")]: this.rounded },
        { [this.computedClass("sizeClass", "o-input--", this.size)]: this.size },
        { [this.computedClass("variantClass", "o-input--", this.statusVariant || this.variant)]: this.statusVariant || this.variant },
        { [this.computedClass("textareaClass", "o-input__textarea")]: this.type === "textarea" },
        { [this.computedClass("iconLeftSpaceClass", "o-input-iconspace-left")]: this.icon },
        { [this.computedClass("iconRightSpaceClass", "o-input-iconspace-right")]: this.hasIconRight }
      ];
    },
    iconLeftClasses() {
      return [
        this.computedClass("iconLeftClass", "o-input__icon-left")
      ];
    },
    iconRightClasses() {
      return [
        this.computedClass("iconRightClass", "o-input__icon-right")
      ];
    },
    counterClasses() {
      return [
        this.computedClass("counterClass", "o-input__counter")
      ];
    },
    computedValue: {
      get() {
        return this.newValue;
      },
      set(value) {
        this.newValue = value;
        this.$emit("update:modelValue", this.newValue);
        this.syncFilled(this.newValue);
        !this.isValid && this.checkHtml5Validity();
      }
    },
    hasIconRight() {
      return this.passwordReveal || this.statusIcon && this.statusVariantIcon || this.clearable && this.newValue || this.iconRight;
    },
    rightIcon() {
      if (this.passwordReveal) {
        return this.passwordVisibleIcon;
      } else if (this.clearable && this.newValue) {
        return "close-circle";
      } else if (this.iconRight) {
        return this.iconRight;
      }
      return this.statusVariantIcon;
    },
    rightIconVariant() {
      if (this.passwordReveal || this.iconRight) {
        return this.iconRightVariant || this.variant || null;
      }
      return this.statusVariant;
    },
    hasMessage() {
      return !!this.statusMessage;
    },
    passwordVisibleIcon() {
      return !this.isPasswordVisible ? "eye" : "eye-off";
    },
    valueLength() {
      if (typeof this.computedValue === "string") {
        return this.computedValue.length;
      } else if (typeof this.computedValue === "number") {
        return this.computedValue.toString().length;
      }
      return 0;
    },
    computedStyles() {
      if (!this.autosize)
        return {};
      return {
        resize: "none",
        height: this.height,
        overflow: "hidden"
      };
    },
    $elementRef() {
      return this.type === "textarea" ? "textarea" : "input";
    }
  },
  watch: {
    modelValue: {
      immediate: true,
      handler(value) {
        this.newValue = value;
        this.syncFilled(this.newValue);
        if (this.autosize) {
          this.resize();
        }
      }
    }
  },
  methods: {
    togglePasswordVisibility() {
      this.isPasswordVisible = !this.isPasswordVisible;
      this.newType = this.isPasswordVisible ? "text" : "password";
      this.$nextTick(() => {
        this.focus();
      });
    },
    iconClick(emit, event) {
      this.$emit(emit, event);
      this.$nextTick(() => {
        this.focus();
      });
    },
    rightIconClick(event) {
      if (this.passwordReveal) {
        this.togglePasswordVisibility();
      } else if (this.clearable) {
        this.computedValue = "";
      } else if (this.iconRightClickable) {
        this.iconClick("icon-right-click", event);
      }
    },
    resize() {
      this.height = "auto";
      this.$nextTick(() => {
        let scrollHeight = this.$refs.textarea.scrollHeight;
        this.height = scrollHeight + "px";
      });
    }
  }
});
function render3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses
    },
    [_ctx.type !== "textarea" ? (openBlock(), createBlock(
      "input",
      mergeProps({
        key: 0
      }, _ctx.$attrs, {
        ref: "input",
        class: _ctx.inputClasses,
        type: _ctx.newType,
        autocomplete: _ctx.newAutocomplete,
        maxlength: _ctx.maxlength,
        value: _ctx.computedValue,
        onInput: _cache[1] || (_cache[1] = ($event) => _ctx.computedValue = $event.target.value),
        onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.onBlur(...args)),
        onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.onFocus(...args))
      }),
      null,
      16,
      ["type", "autocomplete", "maxlength", "value"]
    )) : (openBlock(), createBlock(
      "textarea",
      mergeProps({
        key: 1
      }, _ctx.$attrs, {
        ref: "textarea",
        class: _ctx.inputClasses,
        maxlength: _ctx.maxlength,
        value: _ctx.computedValue,
        onInput: _cache[4] || (_cache[4] = ($event) => _ctx.computedValue = $event.target.value),
        onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.onBlur(...args)),
        onFocus: _cache[6] || (_cache[6] = (...args) => _ctx.onFocus(...args)),
        style: _ctx.computedStyles
      }),
      null,
      16,
      ["maxlength", "value"]
    )), _ctx.icon ? createVNode(
      _component_o_icon,
      {
        key: 2,
        class: _ctx.iconLeftClasses,
        clickable: _ctx.iconClickable,
        icon: _ctx.icon,
        pack: _ctx.iconPack,
        size: _ctx.size,
        onClick: _cache[7] || (_cache[7] = ($event) => _ctx.iconClick("icon-click", $event))
      },
      null,
      8,
      ["class", "clickable", "icon", "pack", "size"]
    ) : createCommentVNode("v-if", true), _ctx.hasIconRight ? createVNode(
      _component_o_icon,
      {
        key: 3,
        class: _ctx.iconRightClasses,
        clickable: _ctx.passwordReveal || _ctx.clearable || _ctx.iconRightClickable,
        icon: _ctx.rightIcon,
        pack: _ctx.iconPack,
        size: _ctx.size,
        variant: _ctx.rightIconVariant,
        both: "",
        onClick: _ctx.rightIconClick
      },
      null,
      8,
      ["class", "clickable", "icon", "pack", "size", "variant", "onClick"]
    ) : createCommentVNode("v-if", true), _ctx.maxlength && _ctx.hasCounter && _ctx.isFocused && _ctx.type !== "number" ? (openBlock(), createBlock(
      "small",
      {
        key: 4,
        class: _ctx.counterClasses
      },
      toDisplayString(_ctx.valueLength) + " / " + toDisplayString(_ctx.maxlength),
      3
    )) : createCommentVNode("v-if", true)],
    2
  );
}
script2.render = render3;
script2.__file = "src/components/input/Input.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/Autocomplete-f6c445af.mjs
var script3 = defineComponent({
  name: "OAutocomplete",
  configField: "autocomplete",
  components: {
    [script2.name]: script2
  },
  mixins: [BaseComponentMixin, FormElementMixin],
  inheritAttrs: false,
  emits: ["update:modelValue", "select", "infinite-scroll", "typing", "focus", "blur", "icon-click", "icon-right-click"],
  props: {
    modelValue: [Number, String],
    data: {
      type: Array,
      default: () => []
    },
    autocomplete: String,
    size: String,
    field: {
      type: String,
      default: "value"
    },
    keepFirst: Boolean,
    clearOnSelect: Boolean,
    openOnFocus: Boolean,
    customFormatter: Function,
    checkInfiniteScroll: Boolean,
    keepOpen: Boolean,
    clearable: Boolean,
    maxHeight: [String, Number],
    menuPosition: {
      type: String,
      default: "auto"
    },
    animation: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "autocomplete.animation", "fade");
      }
    },
    groupField: String,
    groupOptions: String,
    debounceTyping: Number,
    iconRight: String,
    iconRightClickable: Boolean,
    appendToBody: Boolean,
    confirmKeys: {
      type: Array,
      default: () => ["Tab", "Enter"]
    },
    type: {
      type: String,
      default: "text"
    },
    menuTag: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "autocomplete.menuTag", "div");
      }
    },
    itemTag: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "autocomplete.itemTag", "div");
      }
    },
    selectOnClickOutside: Boolean,
    selectableHeader: Boolean,
    selectableFooter: Boolean,
    rootClass: [String, Function, Array],
    menuClass: [String, Function, Array],
    expandedClass: [String, Function, Array],
    menuPositionClass: [String, Function, Array],
    itemClass: [String, Function, Array],
    itemHoverClass: [String, Function, Array],
    itemGroupTitleClass: [String, Function, Array],
    itemEmptyClass: [String, Function, Array],
    itemHeaderClass: [String, Function, Array],
    itemFooterClass: [String, Function, Array],
    inputClasses: {
      type: Object,
      default: () => {
        return getValueByPath(getOptions(), "autocomplete.inputClasses", {});
      }
    }
  },
  data() {
    return {
      selected: null,
      hovered: null,
      headerHovered: null,
      footerHovered: null,
      isActive: false,
      newValue: this.modelValue,
      ariaAutocomplete: this.keepFirst ? "both" : "list",
      newAutocomplete: this.autocomplete || "off",
      isListInViewportVertically: true,
      hasFocus: false,
      itemRefs: [],
      width: void 0,
      bodyEl: void 0
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-acp"),
        { [this.computedClass("expandedClass", "o-acp--expanded")]: this.expanded }
      ];
    },
    menuClasses() {
      return [
        this.computedClass("menuClass", "o-acp__menu"),
        { [this.computedClass("menuPositionClass", "o-acp__menu--", this.newDropdownPosition)]: !this.appendToBody }
      ];
    },
    itemClasses() {
      return [
        this.computedClass("itemClass", "o-acp__item")
      ];
    },
    itemEmptyClasses() {
      return [
        ...this.itemClasses,
        this.computedClass("itemEmptyClass", "o-acp__item--empty")
      ];
    },
    itemGroupClasses() {
      return [
        ...this.itemClasses,
        this.computedClass("itemGroupTitleClass", "o-acp__item-group-title")
      ];
    },
    itemHeaderClasses() {
      return [
        ...this.itemClasses,
        this.computedClass("itemHeaderClass", "o-acp__item-header"),
        { [this.computedClass("itemHoverClass", "o-acp__item--hover")]: this.headerHovered }
      ];
    },
    itemFooterClasses() {
      return [
        ...this.itemClasses,
        this.computedClass("itemFooterClass", "o-acp__item-footer"),
        { [this.computedClass("itemHoverClass", "o-acp__item--hover")]: this.footerHovered }
      ];
    },
    inputBind() {
      return {
        ...this.$attrs,
        ...this.inputClasses
      };
    },
    computedData() {
      if (this.groupField) {
        if (this.groupOptions) {
          const newData = [];
          this.data.forEach((option) => {
            const group = getValueByPath(option, this.groupField);
            const items2 = getValueByPath(option, this.groupOptions);
            newData.push({ group, items: items2 });
          });
          return newData;
        } else {
          const tmp = {};
          this.data.forEach((option) => {
            const group = getValueByPath(option, this.groupField);
            if (!tmp[group])
              tmp[group] = [];
            tmp[group].push(option);
          });
          const newData = [];
          Object.keys(this.data).forEach((group) => {
            newData.push({ group, items: this.data[group] });
          });
          return newData;
        }
      }
      return [{ items: this.data }];
    },
    isEmpty() {
      if (!this.computedData)
        return true;
      return !this.computedData.some((element) => element.items && element.items.length);
    },
    whiteList() {
      const whiteList = [];
      whiteList.push(this.$refs.input.$el.querySelector("input"));
      whiteList.push(this.$refs.dropdown);
      if (this.$refs.dropdown !== void 0) {
        const children = this.$refs.dropdown.querySelectorAll("*");
        for (const child of children) {
          whiteList.push(child);
        }
      }
      return whiteList;
    },
    newDropdownPosition() {
      if (this.menuPosition === "top" || this.menuPosition === "auto" && !this.isListInViewportVertically) {
        return "top";
      }
      return "bottom";
    },
    newIconRight() {
      if (this.clearable && this.newValue) {
        return "close-circle";
      }
      return this.iconRight;
    },
    newIconRightClickable() {
      if (this.clearable) {
        return true;
      }
      return this.iconRightClickable;
    },
    menuStyle() {
      return {
        maxHeight: toCssDimension(this.maxHeight)
      };
    },
    $elementRef() {
      return "input";
    }
  },
  watch: {
    modelValue(value) {
      this.newValue = value;
    },
    isActive(active) {
      if (this.menuPosition === "auto") {
        if (active) {
          this.calcDropdownInViewportVertical();
        } else {
          setTimeout(() => {
            this.calcDropdownInViewportVertical();
          }, 100);
        }
      }
    },
    newValue(value) {
      this.$emit("update:modelValue", value);
      const currentValue = this.getValue(this.selected);
      if (currentValue && currentValue !== value) {
        this.setSelected(null, false);
      }
      if (this.hasFocus && (!this.openOnFocus || value)) {
        this.isActive = !!value;
      }
    },
    data() {
      if (this.keepFirst) {
        this.$nextTick(() => {
          if (this.isActive) {
            this.selectFirstOption(this.computedData);
          } else {
            this.setHovered(null);
          }
        });
      } else {
        if (this.hovered) {
          const hoveredValue = this.getValue(this.hovered);
          const data = this.computedData.map((d) => d.items).reduce((a, b) => [...a, ...b], []);
          if (!data.some((d) => this.getValue(d) === hoveredValue)) {
            this.setHovered(null);
          }
        }
      }
    },
    debounceTyping: {
      handler(value) {
        this.debouncedEmitTyping = debounce(this.emitTyping, value);
      },
      immediate: true
    }
  },
  methods: {
    itemOptionClasses(option) {
      return [
        ...this.itemClasses,
        { [this.computedClass("itemHoverClass", "o-acp__item--hover")]: option === this.hovered }
      ];
    },
    setHovered(option) {
      if (option === void 0)
        return;
      this.hovered = option;
    },
    setSelected(option, closeDropdown = true, event = void 0) {
      if (option === void 0)
        return;
      this.selected = option;
      this.$emit("select", this.selected, event);
      if (this.selected !== null) {
        if (this.clearOnSelect) {
          const input = this.$refs.input;
          input.newValue = "";
          input.$refs.input.value = "";
        } else {
          this.newValue = this.getValue(this.selected);
        }
        this.setHovered(null);
      }
      closeDropdown && this.$nextTick(() => {
        this.isActive = false;
      });
      this.checkValidity();
    },
    selectFirstOption(computedData) {
      this.$nextTick(() => {
        const nonEmptyElements = computedData.filter((element) => element.items && element.items.length);
        if (nonEmptyElements.length) {
          const option = nonEmptyElements[0].items[0];
          this.setHovered(option);
        } else {
          this.setHovered(null);
        }
      });
    },
    keydown(event) {
      const { key } = event;
      if (key === "Enter")
        event.preventDefault();
      if (key === "Escape" || key === "Tab") {
        this.isActive = false;
      }
      if (this.confirmKeys.indexOf(key) >= 0) {
        if (key === ",")
          event.preventDefault();
        const closeDropdown = !this.keepOpen || key === "Tab";
        if (this.hovered === null) {
          this.checkIfHeaderOrFooterSelected(event, null, closeDropdown);
          return;
        }
        this.setSelected(this.hovered, closeDropdown, event);
      }
    },
    selectHeaderOrFoterByClick(event, origin) {
      this.checkIfHeaderOrFooterSelected(event, { origin });
    },
    checkIfHeaderOrFooterSelected(event, triggerClick, closeDropdown = true) {
      if (this.selectableHeader && (this.headerHovered || triggerClick && triggerClick.origin === "header")) {
        this.$emit("select-header", event);
        this.headerHovered = false;
        if (triggerClick)
          this.setHovered(null);
        if (closeDropdown)
          this.isActive = false;
      }
      if (this.selectableFooter && (this.footerHovered || triggerClick && triggerClick.origin === "header")) {
        this.$emit("select-footer", event);
        this.footerHovered = false;
        if (triggerClick)
          this.setHovered(null);
        if (closeDropdown)
          this.isActive = false;
      }
    },
    clickedOutside(event) {
      if (!this.hasFocus && this.whiteList.indexOf(event.target) < 0) {
        if (this.keepFirst && this.hovered && this.selectOnClickOutside) {
          this.setSelected(this.hovered, true);
        } else {
          this.isActive = false;
        }
      }
    },
    getValue(option) {
      if (option === null)
        return;
      if (typeof this.customFormatter !== "undefined") {
        return this.customFormatter(option);
      }
      return typeof option === "object" ? getValueByPath(option, this.field) : option;
    },
    checkIfReachedTheEndOfScroll() {
      const list = this.$refs.dropdown;
      if (list.clientHeight !== list.scrollHeight && list.scrollTop + list.clientHeight >= list.scrollHeight) {
        this.$emit("infinite-scroll");
      }
    },
    calcDropdownInViewportVertical() {
      this.$nextTick(() => {
        if (!this.$refs.dropdown)
          return;
        const rect = this.$refs.dropdown.getBoundingClientRect();
        this.isListInViewportVertically = rect.top >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight);
        if (this.appendToBody) {
          this.updateAppendToBody();
        }
      });
    },
    keyArrows(direction) {
      const sum = direction === "down" ? 1 : -1;
      if (this.isActive) {
        const data = this.computedData.map((d) => d.items).reduce((a, b) => [...a, ...b], []);
        if (this.$slots.header && this.selectableHeader) {
          data.unshift(void 0);
        }
        if (this.$slots.footer && this.selectableFooter) {
          data.push(void 0);
        }
        let index29;
        if (this.headerHovered) {
          index29 = 0 + sum;
        } else if (this.footerHovered) {
          index29 = data.length - 1 + sum;
        } else {
          index29 = data.indexOf(this.hovered) + sum;
        }
        index29 = index29 > data.length - 1 ? data.length - 1 : index29;
        index29 = index29 < 0 ? 0 : index29;
        this.footerHovered = false;
        this.headerHovered = false;
        this.setHovered(data[index29] !== void 0 ? data[index29] : null);
        if (this.$slots.footer && this.selectableFooter && index29 === data.length - 1) {
          this.footerHovered = true;
        }
        if (this.$slots.header && this.selectableHeader && index29 === 0) {
          this.headerHovered = true;
        }
        const list = this.$refs.dropdown;
        let items2 = this.itemRefs || [];
        if (this.$slots.header && this.selectableHeader) {
          items2 = [this.$refs.header, ...items2];
        }
        if (this.$slots.footer && this.selectableFooter) {
          items2 = [...items2, this.$refs.footer];
        }
        const element = items2[index29];
        if (!element)
          return;
        const visMin = list.scrollTop;
        const visMax = list.scrollTop + list.clientHeight - element.clientHeight;
        if (element.offsetTop < visMin) {
          list.scrollTop = element.offsetTop;
        } else if (element.offsetTop >= visMax) {
          list.scrollTop = element.offsetTop - list.clientHeight + element.clientHeight;
        }
      } else {
        this.isActive = true;
      }
    },
    focused(event) {
      if (this.getValue(this.selected) === this.newValue) {
        this.$el.querySelector("input").select();
      }
      if (this.openOnFocus) {
        this.isActive = true;
        if (this.keepFirst) {
          this.selectFirstOption(this.computedData);
        }
      }
      this.hasFocus = true;
      this.$emit("focus", event);
    },
    onBlur(event) {
      this.hasFocus = false;
      this.$emit("blur", event);
    },
    onInput() {
      const currentValue = this.getValue(this.selected);
      if (currentValue && currentValue === this.newValue)
        return;
      if (this.debounceTyping) {
        this.debouncedEmitTyping();
      } else {
        this.emitTyping();
      }
    },
    emitTyping() {
      this.$emit("typing", this.newValue);
      this.checkValidity();
    },
    rightIconClick(event) {
      if (this.clearable) {
        this.newValue = "";
        this.setSelected(null, false);
        if (this.openOnFocus) {
          this.$refs.input.$el.focus();
        }
      } else {
        this.$emit("icon-right-click", event);
      }
    },
    checkValidity() {
      if (this.useHtml5Validation) {
        this.$nextTick(() => {
          this.checkHtml5Validity();
        });
      }
    },
    setItemRef(el) {
      if (el) {
        this.itemRefs.push(el);
      }
    },
    updateAppendToBody() {
      const dropdownMenu = this.$refs.dropdown;
      const trigger = this.$refs.input.$el;
      if (dropdownMenu && trigger) {
        const root = this.$data.bodyEl;
        root.classList.forEach((item) => root.classList.remove(...item.split(" ")));
        this.rootClasses.forEach((item) => {
          if (item) {
            if (typeof item === "object") {
              Object.keys(item).filter((key) => key && item[key]).forEach((key) => root.classList.add(key));
            } else {
              root.classList.add(...item.split(" "));
            }
          }
        });
        const rect = trigger.getBoundingClientRect();
        let top = rect.top + window.scrollY;
        const left = rect.left + window.scrollX;
        if (this.newDropdownPosition !== "top") {
          top += trigger.clientHeight;
        } else {
          top -= dropdownMenu.clientHeight;
        }
        dropdownMenu.style.position = "absolute";
        dropdownMenu.style.top = `${top}px`;
        dropdownMenu.style.left = `${left}px`;
        dropdownMenu.style.width = `${trigger.clientWidth}px`;
        dropdownMenu.style.maxWidth = `${trigger.clientWidth}px`;
        dropdownMenu.style.zIndex = "9999";
      }
    }
  },
  created() {
    if (typeof window !== "undefined") {
      document.addEventListener("click", this.clickedOutside);
      if (this.menuPosition === "auto")
        window.addEventListener("resize", this.calcDropdownInViewportVertical);
    }
  },
  mounted() {
    const list = this.$refs.dropdown;
    if (this.checkInfiniteScroll && list) {
      list.addEventListener("scroll", this.checkIfReachedTheEndOfScroll);
    }
    if (this.appendToBody) {
      this.$data.bodyEl = createAbsoluteElement(list);
      this.updateAppendToBody();
    }
  },
  beforeUpdate() {
    this.width = this.$refs.input ? this.$refs.input.$el.clientWidth : void 0;
    this.itemRefs = [];
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      document.removeEventListener("click", this.clickedOutside);
      if (this.menuPosition === "auto")
        window.removeEventListener("resize", this.calcDropdownInViewportVertical);
    }
    if (this.checkInfiniteScroll && this.$refs.dropdown) {
      const list = this.$refs.dropdown;
      list.removeEventListener("scroll", this.checkIfReachedTheEndOfScroll);
    }
    if (this.appendToBody) {
      removeElement(this.$data.bodyEl);
    }
  }
});
var _hoisted_1 = {
  key: 1
};
var _hoisted_2 = {
  key: 1
};
function render4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_input = resolveComponent("o-input");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses
    },
    [createVNode(
      _component_o_input,
      mergeProps(_ctx.inputBind, {
        modelValue: _ctx.newValue,
        "onUpdate:modelValue": [_cache[1] || (_cache[1] = ($event) => _ctx.newValue = $event), _ctx.onInput],
        ref: "input",
        type: _ctx.type,
        size: _ctx.size,
        rounded: _ctx.rounded,
        icon: _ctx.icon,
        "icon-right": _ctx.newIconRight,
        "icon-right-clickable": _ctx.newIconRightClickable,
        "icon-pack": _ctx.iconPack,
        maxlength: _ctx.maxlength,
        autocomplete: _ctx.newAutocomplete,
        "use-html5-validation": false,
        "aria-autocomplete": _ctx.ariaAutocomplete,
        expanded: _ctx.expanded,
        onFocus: _ctx.focused,
        onBlur: _ctx.onBlur,
        onKeydown: [_ctx.keydown, _cache[2] || (_cache[2] = withKeys(withModifiers(($event) => _ctx.keyArrows("up"), ["prevent"]), ["up"])), _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.keyArrows("down"), ["prevent"]), ["down"]))],
        "onIcon-right-click": _ctx.rightIconClick,
        "onIcon-click": _cache[4] || (_cache[4] = (event) => _ctx.$emit("icon-click", event))
      }),
      null,
      16,
      ["modelValue", "type", "size", "rounded", "icon", "icon-right", "icon-right-clickable", "icon-pack", "maxlength", "autocomplete", "aria-autocomplete", "expanded", "onUpdate:modelValue", "onFocus", "onBlur", "onKeydown", "onIcon-right-click"]
    ), createVNode(
      Transition,
      {
        name: _ctx.animation
      },
      {
        default: withCtx(() => [withDirectives(createVNode(
          "div",
          {
            class: _ctx.menuClasses,
            is: _ctx.menuTag,
            style: _ctx.menuStyle,
            ref: "dropdown"
          },
          [_ctx.$slots.header ? (openBlock(), createBlock(
            "div",
            {
              key: 0,
              is: _ctx.itemTag,
              ref: "header",
              role: "button",
              tabindex: 0,
              onClick: _cache[5] || (_cache[5] = ($event) => _ctx.selectHeaderOrFoterByClick($event, "header")),
              class: _ctx.itemHeaderClasses
            },
            [renderSlot(_ctx.$slots, "header")],
            10,
            ["is"]
          )) : createCommentVNode("v-if", true), (openBlock(true), createBlock(
            Fragment,
            null,
            renderList(_ctx.computedData, (element, groupindex) => {
              return openBlock(), createBlock(
                Fragment,
                null,
                [element.group ? (openBlock(), createBlock(
                  "div",
                  {
                    is: _ctx.itemTag,
                    key: groupindex + "group",
                    class: _ctx.itemGroupClasses
                  },
                  [_ctx.$slots.group ? renderSlot(_ctx.$slots, "group", {
                    key: 0,
                    group: element.group,
                    index: groupindex
                  }) : (openBlock(), createBlock(
                    "span",
                    _hoisted_1,
                    toDisplayString(element.group),
                    1
                  ))],
                  10,
                  ["is"]
                )) : createCommentVNode("v-if", true), (openBlock(true), createBlock(
                  Fragment,
                  null,
                  renderList(element.items, (option, index29) => {
                    return openBlock(), createBlock(
                      "div",
                      {
                        key: groupindex + ":" + index29,
                        is: _ctx.itemTag,
                        class: _ctx.itemOptionClasses(option),
                        onClick: withModifiers(($event) => _ctx.setSelected(option, !_ctx.keepOpen, $event), ["stop"]),
                        ref: _ctx.setItemRef
                      },
                      [_ctx.$slots.default ? renderSlot(_ctx.$slots, "default", {
                        key: 0,
                        option,
                        index: index29
                      }) : (openBlock(), createBlock(
                        "span",
                        _hoisted_2,
                        toDisplayString(_ctx.getValue(option)),
                        1
                      ))],
                      10,
                      ["is", "onClick"]
                    );
                  }),
                  128
                ))],
                64
              );
            }),
            256
          )), _ctx.isEmpty && _ctx.$slots.empty ? (openBlock(), createBlock(
            "div",
            {
              key: 1,
              is: _ctx.itemTag,
              class: _ctx.itemEmptyClasses
            },
            [renderSlot(_ctx.$slots, "empty")],
            10,
            ["is"]
          )) : createCommentVNode("v-if", true), _ctx.$slots.footer ? (openBlock(), createBlock(
            "div",
            {
              key: 2,
              is: _ctx.itemTag,
              ref: "footer",
              role: "button",
              tabindex: 0,
              onClick: _cache[6] || (_cache[6] = ($event) => _ctx.selectHeaderOrFoterByClick($event, "footer")),
              class: _ctx.itemFooterClasses
            },
            [renderSlot(_ctx.$slots, "footer")],
            10,
            ["is"]
          )) : createCommentVNode("v-if", true)],
          14,
          ["is"]
        ), [[vShow, _ctx.isActive && (!_ctx.isEmpty || _ctx.$slots.empty || _ctx.$slots.header || _ctx.$slots.footer)]])]),
        _: 1
      },
      8,
      ["name"]
    )],
    2
  );
}
script3.render = render4;
script3.__file = "src/components/autocomplete/Autocomplete.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/autocomplete.mjs
var index = {
  install(app) {
    registerComponent(app, script3);
  }
};
var autocomplete_default = index;

// node_modules/@oruga-ui/oruga-next/dist/esm/Button-9fa4c9ff.mjs
var script4 = defineComponent({
  name: "OButton",
  components: {
    [script.name]: script
  },
  configField: "button",
  mixins: [BaseComponentMixin],
  inheritAttrs: false,
  props: {
    variant: String,
    size: String,
    label: String,
    iconPack: String,
    iconLeft: String,
    iconRight: String,
    rounded: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "button.rounded", false);
      }
    },
    outlined: Boolean,
    expanded: Boolean,
    inverted: Boolean,
    nativeType: {
      type: String,
      default: "button",
      validator: (value) => {
        return [
          "button",
          "submit",
          "reset"
        ].indexOf(value) >= 0;
      }
    },
    tag: {
      type: String,
      default: "button"
    },
    disabled: Boolean,
    iconBoth: Boolean,
    elementsWrapperClass: [String, Function, Array],
    rootClass: [String, Function, Array],
    outlinedClass: [String, Function, Array],
    invertedClass: [String, Function, Array],
    expandedClass: [String, Function, Array],
    roundedClass: [String, Function, Array],
    disabledClass: [String, Function, Array],
    iconClass: [String, Function, Array],
    iconLeftClass: [String, Function, Array],
    iconRightClass: [String, Function, Array],
    labelClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    variantClass: [String, Function, Array]
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-btn"),
        { [this.computedClass("sizeClass", "o-btn--", this.size)]: this.size },
        { [this.computedClass("variantClass", "o-btn--", this.variant)]: this.variant },
        { [this.computedClass("outlinedClass", "o-btn--outlined")]: this.outlined && !this.variant },
        { [this.computedClass("invertedClass", "o-btn--inverted")]: this.inverted && !this.variant },
        { [this.computedClass("outlinedClass", "o-btn--outlined-", this.variant)]: this.outlined && this.variant },
        { [this.computedClass("invertedClass", "o-btn--inverted-", this.variant)]: this.inverted && this.variant },
        { [this.computedClass("expandedClass", "o-btn--expanded")]: this.expanded },
        { [this.computedClass("roundedClass", "o-btn--rounded")]: this.rounded },
        { [this.computedClass("disabledClass", "o-btn--disabled")]: this.disabled }
      ];
    },
    labelClasses() {
      return [
        this.computedClass("labelClass", "o-btn__label")
      ];
    },
    iconClasses() {
      return [
        this.computedClass("iconClass", "o-btn__icon")
      ];
    },
    iconLeftClasses() {
      return [
        ...this.iconClasses,
        this.computedClass("iconLeftClass", "o-btn__icon-left")
      ];
    },
    iconRightClasses() {
      return [
        ...this.iconClasses,
        this.computedClass("iconRightClass", "o-btn__icon-right")
      ];
    },
    elementsWrapperClasses() {
      return [
        this.computedClass("elementsWrapperClass", "o-btn__wrapper")
      ];
    },
    computedTag() {
      if (typeof this.disabled !== "undefined" && this.disabled !== false) {
        return "button";
      }
      return this.tag;
    },
    computedNativeType() {
      if (this.tag === "button" || this.tag === "input") {
        return this.nativeType;
      }
      return null;
    },
    computedDisabled() {
      if (this.disabled)
        return true;
      return null;
    }
  }
});
function render5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");
  return openBlock(), createBlock(
    resolveDynamicComponent(_ctx.computedTag),
    mergeProps(_ctx.$attrs, {
      disabled: _ctx.computedDisabled,
      type: _ctx.computedNativeType,
      class: _ctx.rootClasses
    }),
    {
      default: withCtx(() => [createVNode(
        "span",
        {
          class: _ctx.elementsWrapperClasses
        },
        [_ctx.iconLeft ? createVNode(
          _component_o_icon,
          {
            key: 0,
            pack: _ctx.iconPack,
            icon: _ctx.iconLeft,
            size: _ctx.size,
            both: _ctx.iconBoth,
            class: _ctx.iconLeftClasses
          },
          null,
          8,
          ["pack", "icon", "size", "both", "class"]
        ) : createCommentVNode("v-if", true), _ctx.label || _ctx.$slots.default ? (openBlock(), createBlock(
          "span",
          {
            key: 1,
            class: _ctx.labelClasses
          },
          [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(
            toDisplayString(_ctx.label),
            1
          )])],
          2
        )) : createCommentVNode("v-if", true), _ctx.iconRight ? createVNode(
          _component_o_icon,
          {
            key: 2,
            pack: _ctx.iconPack,
            icon: _ctx.iconRight,
            size: _ctx.size,
            both: _ctx.iconBoth,
            class: _ctx.iconRightClasses
          },
          null,
          8,
          ["pack", "icon", "size", "both", "class"]
        ) : createCommentVNode("v-if", true)],
        2
      )]),
      _: 1
    },
    16,
    ["disabled", "type", "class"]
  );
}
script4.render = render5;
script4.__file = "src/components/button/Button.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/button.mjs
var index2 = {
  install(app) {
    registerComponent(app, script4);
  }
};
var button_default = index2;

// node_modules/@oruga-ui/oruga-next/dist/esm/InjectedChildMixin-d19abfc0.mjs
var items = 1;
var sorted = 3;
var Sorted = sorted;
var ProviderParentMixin = (itemName, flags = 0) => {
  const mixin = defineComponent({
    provide() {
      return {
        ["o" + itemName]: this
      };
    }
  });
  if (hasFlag(flags, items)) {
    mixin.data = function() {
      return {
        childItems: [],
        sequence: 1
      };
    };
    mixin.methods = {
      _registerItem(item) {
        item.index = this.childItems.length;
        this.childItems.push(item);
        if (this.$el) {
          this.$nextTick(() => {
            const ids = this.childItems.map((it) => `[data-id="${itemName}-${it.newValue}"]`).join(",");
            const sortedIds = Array.from(this.$el.querySelectorAll(ids)).map((el) => el.getAttribute("data-id").replace(`${itemName}-`, ""));
            this.childItems.forEach((it) => it.index = sortedIds.indexOf(`${it.newValue}`));
          });
        }
      },
      _unregisterItem(item) {
        this.childItems = this.childItems.filter((i) => i !== item);
      },
      _nextSequence() {
        return this.sequence++;
      }
    };
    if (hasFlag(flags, sorted)) {
      mixin.computed = {
        sortedItems() {
          return this.childItems.slice().sort((i1, i2) => {
            return i1.index - i2.index;
          });
        }
      };
    }
  }
  return mixin;
};
var sorted$1 = 1;
var optional = 2;
var Sorted$1 = sorted$1;
var InjectedChildMixin = (parentItemName, flags = 0) => {
  const mixin = defineComponent({
    inject: {
      parent: { from: "o" + parentItemName }
    },
    created() {
      this.newValue = defaultIfUndefined(this.value, this.parent._nextSequence());
      if (!this.parent) {
        if (!hasFlag(flags, optional)) {
          throw new Error("You should wrap " + this.$options.name + " in a " + parentItemName);
        }
      } else {
        this.parent._registerItem(this);
      }
    },
    beforeUnmount() {
      if (this.parent) {
        this.parent._unregisterItem(this);
      }
    }
  });
  if (hasFlag(flags, sorted$1)) {
    mixin.data = () => {
      return {
        index: null
      };
    };
  }
  return mixin;
};

// node_modules/@oruga-ui/oruga-next/dist/esm/carousel.mjs
var script5 = defineComponent({
  name: "OCarousel",
  components: {
    [script.name]: script
  },
  configField: "carousel",
  mixins: [ProviderParentMixin("carousel", Sorted), BaseComponentMixin],
  emits: ["update:modelValue", "scroll", "click"],
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    interval: {
      type: Number,
      default: () => {
        return getValueByPath(getOptions(), "carousel.interval", 3500);
      }
    },
    hasDrag: {
      type: Boolean,
      default: true
    },
    autoplay: {
      type: Boolean,
      default: false
    },
    pauseHover: {
      type: Boolean,
      default: false
    },
    repeat: {
      type: Boolean,
      default: false
    },
    indicator: {
      type: Boolean,
      default: true
    },
    indicatorInside: {
      type: Boolean,
      default: false
    },
    indicatorMode: {
      type: String,
      default: "click"
    },
    indicatorPosition: {
      type: String,
      default: "bottom"
    },
    indicatorStyle: {
      type: String,
      default: "dots"
    },
    overlay: Boolean,
    itemsToShow: {
      type: Number,
      default: 1
    },
    itemsToList: {
      type: Number,
      default: 1
    },
    asIndicator: Boolean,
    arrow: {
      type: Boolean,
      default: true
    },
    arrowHover: {
      type: Boolean,
      default: true
    },
    iconPack: String,
    iconSize: String,
    iconPrev: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "carousel.iconPrev", "chevron-left");
      }
    },
    iconNext: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "carousel.iconNext", "chevron-right");
      }
    },
    breakpoints: {
      type: Object,
      default: () => ({})
    },
    rootClass: [String, Function, Array],
    overlayClass: [String, Function, Array],
    sceneClass: [String, Function, Array],
    itemsClass: [String, Function, Array],
    itemsDraggingClass: [String, Function, Array],
    arrowIconClass: [String, Function, Array],
    arrowIconPrevClass: [String, Function, Array],
    arrowIconNextClass: [String, Function, Array],
    indicatorsClass: [String, Function, Array],
    indicatorsInsideClass: [String, Function, Array],
    indicatorsInsidePositionClass: [String, Function, Array],
    indicatorItemClass: [String, Function, Array],
    indicatorItemActiveClass: [String, Function, Array],
    indicatorItemStyleClass: [String, Function, Array]
  },
  data() {
    return {
      activeIndex: this.modelValue,
      scrollIndex: this.modelValue,
      delta: 0,
      dragX: false,
      hold: 0,
      windowWidth: 0,
      touch: false,
      observer: null,
      refresh_: 0,
      itemsHovered: false,
      isPause: false,
      timer: null
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-car"),
        { [this.computedClass("overlayClass", "o-car__overlay")]: this.overlay }
      ];
    },
    sceneClasses() {
      return [
        this.computedClass("sceneClass", "o-car__scene")
      ];
    },
    itemsClasses() {
      return [
        this.computedClass("itemsClass", "o-car__items"),
        { [this.computedClass("itemsDraggingClass", "o-car__items--dragging")]: this.dragging }
      ];
    },
    arrowIconClasses() {
      return [
        this.computedClass("arrowIconClass", "o-car__arrow__icon")
      ];
    },
    arrowIconPrevClasses() {
      return [
        ...this.arrowIconClasses,
        this.computedClass("arrowIconPrevClass", "o-car__arrow__icon-prev")
      ];
    },
    arrowIconNextClasses() {
      return [
        ...this.arrowIconClasses,
        this.computedClass("arrowIconNextClass", "o-car__arrow__icon-next")
      ];
    },
    indicatorsClasses() {
      return [
        this.computedClass("indicatorsClass", "o-car__indicators"),
        { [this.computedClass("indicatorsInsideClass", "o-car__indicators--inside")]: this.indicatorInside },
        { [this.computedClass("indicatorsInsidePositionClass", "o-car__indicators--inside--", this.indicatorPosition)]: this.indicatorInside && this.indicatorPosition }
      ];
    },
    indicatorClasses() {
      return [
        this.computedClass("indicatorClass", "o-car__indicator")
      ];
    },
    dragging() {
      return this.dragX !== false;
    },
    itemStyle() {
      return `width: ${this.itemWidth}px;`;
    },
    translation() {
      return -bound(this.delta + this.scrollIndex * this.itemWidth, 0, (this.childItems.length - this.settings.itemsToShow) * this.itemWidth);
    },
    total() {
      return this.childItems.length - this.settings.itemsToShow;
    },
    indicatorCount() {
      return Math.ceil(this.total / this.settings.itemsToList) + 1;
    },
    indicatorIndex() {
      return Math.ceil(this.scrollIndex / this.settings.itemsToList);
    },
    hasArrows() {
      return this.settings.arrowHover && this.itemsHovered || !this.settings.arrowHover;
    },
    hasPrev() {
      return (this.settings.repeat || this.scrollIndex > 0) && this.hasArrows;
    },
    hasNext() {
      return (this.settings.repeat || this.scrollIndex < this.total) && this.hasArrows;
    },
    breakpointKeys() {
      const keys = Object.keys(this.breakpoints).map(Number);
      return keys.sort((a, b) => b - a);
    },
    settings() {
      let breakpoint = this.breakpointKeys.filter((breakpoint2) => {
        if (this.windowWidth >= breakpoint2) {
          return true;
        }
      })[0];
      if (breakpoint) {
        return { ...this.$props, ...this.breakpoints[breakpoint] };
      }
      return this.$props;
    },
    itemWidth() {
      if (this.windowWidth) {
        this.refresh_;
        const rect = this.$el.getBoundingClientRect();
        return rect.width / this.settings.itemsToShow;
      }
      return 0;
    }
  },
  watch: {
    modelValue(value) {
      if (value <= this.childItems.length - 1) {
        this.activeIndex = value;
        this.switchTo(value * this.settings.itemsToList, true);
      }
    },
    autoplay(status) {
      if (status) {
        this.startTimer();
      } else {
        this.pauseTimer();
      }
    },
    repeat(status) {
      if (status) {
        this.startTimer();
      }
    }
  },
  methods: {
    indicatorItemClasses(index29) {
      return [
        this.computedClass("indicatorItemClass", "o-car__indicator__item"),
        { [this.computedClass("indicatorItemActiveClass", "o-car__indicator__item--active")]: this.indicatorIndex === index29 },
        { [this.computedClass("indicatorItemStyleClass", "o-car__indicator__item--", this.indicatorStyle)]: this.indicatorStyle }
      ];
    },
    onMouseEnter() {
      this.itemsHovered = true;
      this.checkPause();
    },
    onMouseLeave() {
      this.itemsHovered = false;
      this.startTimer();
    },
    startTimer() {
      if (!this.autoplay || this.timer)
        return;
      this.isPause = false;
      this.timer = setInterval(() => {
        if (!this.repeat && this.activeIndex >= this.childItems.length - 1) {
          this.pauseTimer();
        } else {
          this.next();
        }
      }, this.interval);
    },
    pauseTimer() {
      this.isPause = true;
      if (this.timer) {
        clearInterval(this.timer);
        this.timer = null;
      }
    },
    restartTimer() {
      this.pauseTimer();
      this.startTimer();
    },
    checkPause() {
      if (this.pauseHover && this.autoplay) {
        this.pauseTimer();
      }
    },
    modeChange(trigger, value) {
      if (this.indicatorMode === trigger) {
        return this.switchTo(value * this.settings.itemsToList);
      }
    },
    resized() {
      this.windowWidth = window.innerWidth;
    },
    switchTo(newIndex, onlyMove = this.asIndicator) {
      if (this.settings.repeat) {
        newIndex = mod(newIndex, this.total + 1);
      }
      newIndex = bound(newIndex, 0, this.total);
      this.scrollIndex = newIndex;
      this.$emit("scroll", this.indicatorIndex);
      if (!onlyMove) {
        this.activeIndex = Math.ceil(newIndex / this.settings.itemsToList);
        if (this.modelValue !== this.activeIndex) {
          this.$emit("update:modelValue", this.activeIndex);
        }
      }
    },
    next() {
      this.switchTo(this.scrollIndex + this.settings.itemsToList);
    },
    prev() {
      this.switchTo(this.scrollIndex - this.settings.itemsToList);
    },
    dragStart(event) {
      if (this.dragging || !this.settings.hasDrag || event.button !== 0 && event.type !== "touchstart")
        return;
      this.hold = Date.now();
      this.touch = !!event.touches;
      this.dragX = this.touch ? event.touches[0].clientX : event.clientX;
      if (this.touch) {
        this.pauseTimer();
      }
      window.addEventListener(this.touch ? "touchmove" : "mousemove", this.dragMove);
      window.addEventListener(this.touch ? "touchend" : "mouseup", this.dragEnd);
    },
    dragMove(event) {
      if (!this.dragging)
        return;
      const dragEndX = event.touches ? (event.changedTouches[0] || event.touches[0]).clientX : event.clientX;
      this.delta = this.dragX - dragEndX;
      if (!event.touches) {
        event.preventDefault();
      }
    },
    dragEnd(event) {
      if (!this.dragging && !this.hold)
        return;
      if (this.hold) {
        const signCheck = sign(this.delta);
        const results = Math.round(Math.abs(this.delta / this.itemWidth) + 0.15);
        this.switchTo(this.scrollIndex + signCheck * results);
      }
      this.delta = 0;
      this.dragX = false;
      if (event && event.touches) {
        this.startTimer();
      }
      window.removeEventListener(this.touch ? "touchmove" : "mousemove", this.dragMove);
      window.removeEventListener(this.touch ? "touchend" : "mouseup", this.dragEnd);
    },
    refresh() {
      this.$nextTick(() => {
        this.refresh_++;
      });
    }
  },
  mounted() {
    if (typeof window !== "undefined") {
      if (window.ResizeObserver) {
        this.observer = new window.ResizeObserver(this.refresh);
        this.observer.observe(this.$el);
      }
      window.addEventListener("resize", this.resized);
      document.addEventListener("animationend", this.refresh);
      document.addEventListener("transitionend", this.refresh);
      document.addEventListener("transitionstart", this.refresh);
      this.resized();
      this.startTimer();
    }
    if (this.$attrs.config) {
      throw new Error("The config prop was removed, you need to use v-bind instead");
    }
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      if (window.ResizeObserver) {
        this.observer.disconnect();
      }
      window.removeEventListener("resize", this.resized);
      document.removeEventListener("animationend", this.refresh);
      document.removeEventListener("transitionend", this.refresh);
      document.removeEventListener("transitionstart", this.refresh);
      this.dragEnd();
      this.pauseTimer();
    }
  }
});
function render6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses,
      onMouseenter: _cache[3] || (_cache[3] = (...args) => _ctx.onMouseEnter(...args)),
      onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.onMouseLeave(...args))
    },
    [createVNode(
      "div",
      {
        class: _ctx.sceneClasses
      },
      [createVNode(
        "div",
        {
          onMousedown: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.dragStart(...args), ["prevent"])),
          onTouchstart: _cache[2] || (_cache[2] = (...args) => _ctx.dragStart(...args)),
          class: _ctx.itemsClasses,
          style: "transform:translateX(" + _ctx.translation + "px)"
        },
        [renderSlot(_ctx.$slots, "default")],
        38
      ), renderSlot(_ctx.$slots, "arrow", {
        hasPrev: _ctx.hasPrev,
        prev: _ctx.prev,
        hasNext: _ctx.hasNext,
        next: _ctx.next
      }, () => [_ctx.arrow ? (openBlock(), createBlock(
        Fragment,
        {
          key: 0
        },
        [withDirectives(createVNode(
          _component_o_icon,
          {
            class: _ctx.arrowIconPrevClasses,
            onClick: _ctx.prev,
            pack: _ctx.iconPack,
            icon: _ctx.iconPrev,
            size: _ctx.iconSize,
            both: ""
          },
          null,
          8,
          ["class", "onClick", "pack", "icon", "size"]
        ), [[vShow, _ctx.hasPrev]]), withDirectives(createVNode(
          _component_o_icon,
          {
            class: _ctx.arrowIconNextClasses,
            onClick: _ctx.next,
            pack: _ctx.iconPack,
            icon: _ctx.iconNext,
            size: _ctx.iconSize,
            both: ""
          },
          null,
          8,
          ["class", "onClick", "pack", "icon", "size"]
        ), [[vShow, _ctx.hasNext]])],
        64
      )) : createCommentVNode("v-if", true)])],
      2
    ), renderSlot(_ctx.$slots, "indicators", {
      active: _ctx.activeIndex,
      switchTo: _ctx.switchTo,
      indicatorIndex: _ctx.indicatorIndex
    }, () => [_ctx.childItems.length ? (openBlock(), createBlock(
      Fragment,
      {
        key: 0
      },
      [_ctx.indicator && !_ctx.asIndicator ? (openBlock(), createBlock(
        "div",
        {
          key: 0,
          class: _ctx.indicatorsClasses
        },
        [(openBlock(true), createBlock(
          Fragment,
          null,
          renderList(_ctx.indicatorCount, (_, index29) => {
            return openBlock(), createBlock(
              "a",
              {
                class: _ctx.indicatorClasses,
                onMouseover: ($event) => _ctx.modeChange("hover", index29),
                onClick: ($event) => _ctx.modeChange("click", index29),
                key: index29
              },
              [renderSlot(_ctx.$slots, "indicator", {
                i: index29
              }, () => [createVNode(
                "span",
                {
                  class: _ctx.indicatorItemClasses(index29)
                },
                null,
                2
              )])],
              42,
              ["onMouseover", "onClick"]
            );
          }),
          128
        ))],
        2
      )) : createCommentVNode("v-if", true)],
      64
    )) : createCommentVNode("v-if", true)]), _ctx.overlay ? renderSlot(_ctx.$slots, "overlay", {
      key: 0
    }) : createCommentVNode("v-if", true)],
    34
  );
}
script5.render = render6;
script5.__file = "src/components/carousel/Carousel.vue";
var script$1 = defineComponent({
  name: "OCarouselItem",
  configField: "carousel",
  mixins: [InjectedChildMixin("carousel", Sorted$1), BaseComponentMixin],
  props: {
    itemClass: [String, Function, Array],
    itemActiveClass: [String, Function, Array]
  },
  computed: {
    itemClasses() {
      return [
        this.computedClass("itemClass", "o-car__item"),
        { [this.computedClass("itemActiveClass", "o-car__item--active")]: this.isActive }
      ];
    },
    itemStyle() {
      return `width: ${this.parent.itemWidth}px;`;
    },
    isActive() {
      return this.parent.activeIndex === this.index;
    }
  },
  methods: {
    onClick(event) {
      if (this.isActive) {
        this.parent.$emit("click", event);
      }
      if (this.parent.asIndicator) {
        this.parent.activeIndex = this.index;
        this.parent.$emit("update:modelValue", this.index);
      }
    }
  }
});
function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.itemClasses,
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClick(...args)),
      style: _ctx.itemStyle
    },
    [renderSlot(_ctx.$slots, "default")],
    6
  );
}
script$1.render = render$1;
script$1.__file = "src/components/carousel/CarouselItem.vue";
var index3 = {
  install(app) {
    registerComponent(app, script5);
    registerComponent(app, script$1);
  }
};
var carousel_default = index3;

// node_modules/@oruga-ui/oruga-next/dist/esm/CheckRadioMixin-f5b57344.mjs
var CheckRadioMixin = defineComponent({
  emits: ["update:modelValue"],
  props: {
    modelValue: [String, Number, Boolean, Array],
    nativeValue: [String, Number, Boolean, Array],
    variant: String,
    disabled: Boolean,
    required: Boolean,
    name: String,
    size: String
  },
  data() {
    return {
      newValue: this.modelValue
    };
  },
  computed: {
    computedValue: {
      get() {
        return this.newValue;
      },
      set(value) {
        this.newValue = value;
        this.$emit("update:modelValue", this.newValue);
      }
    }
  },
  watch: {
    modelValue(value) {
      this.newValue = value;
    }
  },
  methods: {
    focus() {
      this.$refs.input.focus();
    }
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/Checkbox-c9398157.mjs
var script6 = defineComponent({
  name: "OCheckbox",
  mixins: [BaseComponentMixin, CheckRadioMixin],
  configField: "checkbox",
  emits: [
    "input"
  ],
  props: {
    indeterminate: {
      type: Boolean,
      default: false
    },
    trueValue: {
      type: [String, Number, Boolean],
      default: true
    },
    falseValue: {
      type: [String, Number, Boolean],
      default: false
    },
    ariaLabelledby: String,
    autocomplete: String,
    rootClass: [String, Function, Array],
    disabledClass: [String, Function, Array],
    checkClass: [String, Function, Array],
    checkCheckedClass: [String, Function, Array],
    checkIndeterminateClass: [String, Function, Array],
    labelClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    variantClass: [String, Function, Array]
  },
  watch: {
    indeterminate: {
      handler(val) {
        this.isIndeterminate = val;
      },
      immediate: true
    }
  },
  computed: {
    isChecked() {
      return this.computedValue === this.trueValue || Array.isArray(this.computedValue) && this.computedValue.indexOf(this.nativeValue) !== -1;
    },
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-chk"),
        { [this.computedClass("checkedClass", "o-chk--checked")]: this.isChecked },
        { [this.computedClass("sizeClass", "o-chk--", this.size)]: this.size },
        { [this.computedClass("disabledClass", "o-chk--disabled")]: this.disabled },
        { [this.computedClass("variantClass", "o-chk--", this.variant)]: this.variant }
      ];
    },
    checkClasses() {
      return [
        this.computedClass("checkClass", "o-chk__check"),
        { [this.computedClass("checkCheckedClass", "o-chk__check--checked")]: this.isChecked },
        { [this.computedClass("checkIndeterminateClass", "o-chk__check--indeterminate")]: this.isIndeterminate }
      ];
    },
    labelClasses() {
      return [
        this.computedClass("labelClass", "o-chk__label")
      ];
    }
  }
});
function render7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "label",
    {
      class: _ctx.rootClasses,
      ref: "label",
      onClick: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.focus(...args), ["stop"])),
      onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.$refs.label.click(), ["prevent"]), ["enter"]))
    },
    [withDirectives(createVNode(
      "input",
      {
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.computedValue = $event),
        indeterminate: _ctx.indeterminate,
        type: "checkbox",
        ref: "input",
        onClick: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["stop"])),
        class: _ctx.checkClasses,
        disabled: _ctx.disabled,
        required: _ctx.required,
        name: _ctx.name,
        autocomplete: _ctx.autocomplete,
        value: _ctx.nativeValue,
        "true-value": _ctx.trueValue,
        "false-value": _ctx.falseValue,
        "aria-labelledby": _ctx.ariaLabelledby
      },
      null,
      10,
      ["indeterminate", "disabled", "required", "name", "autocomplete", "value", "true-value", "false-value", "aria-labelledby"]
    ), [[vModelCheckbox, _ctx.computedValue]]), createVNode(
      "span",
      {
        id: _ctx.ariaLabelledby,
        class: _ctx.labelClasses
      },
      [renderSlot(_ctx.$slots, "default")],
      10,
      ["id"]
    )],
    34
  );
}
script6.render = render7;
script6.__file = "src/components/checkbox/Checkbox.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/checkbox.mjs
var index4 = {
  install(app) {
    registerComponent(app, script6);
  }
};
var checkbox_default = index4;

// node_modules/@oruga-ui/oruga-next/dist/esm/collapse.mjs
var script7 = defineComponent({
  name: "OCollapse",
  mixins: [BaseComponentMixin],
  configField: "collapse",
  emits: ["update:open", "open", "close"],
  props: {
    open: {
      type: Boolean,
      default: true
    },
    animation: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "collapse.animation", "fade");
      }
    },
    ariaId: {
      type: String,
      default: ""
    },
    position: {
      type: String,
      default: "top",
      validator: (value) => {
        return [
          "top",
          "bottom"
        ].indexOf(value) > -1;
      }
    },
    rootClass: [String, Function, Array],
    triggerClass: [String, Function, Array],
    contentClass: [String, Function, Array]
  },
  data() {
    return {
      isOpen: this.open
    };
  },
  watch: {
    open(value) {
      this.isOpen = value;
    }
  },
  methods: {
    toggle() {
      this.isOpen = !this.isOpen;
      this.$emit("update:open", this.isOpen);
      this.$emit(this.isOpen ? "open" : "close");
    }
  },
  render() {
    const trigger = h("div", {
      class: this.computedClass("triggerClass", "o-clps__trigger"),
      onClick: this.toggle
    }, this.$slots.trigger({ open: this.isOpen }));
    const content = h(Transition, { name: this.animation }, () => withDirectives(h("div", {
      class: this.computedClass("contentClass", "o-clps__content"),
      "id": this.ariaId
    }, this.$slots.default()), [[vShow, this.isOpen]]));
    return h("div", { class: this.computedClass("rootClass", "o-clps") }, this.position === "top" ? [trigger, content] : [content, trigger]);
  }
});
script7.__file = "src/components/collapse/Collapse.vue";
var index5 = {
  install(app) {
    registerComponent(app, script7);
  }
};
var collapse_default = index5;

// node_modules/@oruga-ui/oruga-next/dist/esm/MatchMediaMixin-2c8a84de.mjs
var MatchMediaMixin = defineComponent({
  props: {
    mobileBreakpoint: String
  },
  data() {
    return {
      matchMediaRef: void 0,
      isMatchMedia: void 0
    };
  },
  methods: {
    onMatchMedia(event) {
      this.isMatchMedia = event.matches;
    }
  },
  created() {
    if (typeof window !== "undefined") {
      let width = this.mobileBreakpoint;
      if (!width) {
        const config2 = getOptions();
        const defaultWidth = getValueByPath(config2, `mobileBreakpoint`, "1023px");
        width = getValueByPath(config2, `${this.$options.configField}.mobileBreakpoint`, defaultWidth);
      }
      this.matchMediaRef = window.matchMedia(`(max-width: ${width})`);
      this.isMatchMedia = this.matchMediaRef.matches;
      this.matchMediaRef.addListener(this.onMatchMedia, false);
    }
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      this.matchMediaRef.removeListener(this.checkMatchMedia);
    }
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/trapFocus-dc03669f.mjs
var findFocusable = (element, programmatic = false) => {
  if (!element) {
    return null;
  }
  if (programmatic) {
    return element.querySelectorAll(`*[tabindex="-1"]`);
  }
  return element.querySelectorAll(`a[href]:not([tabindex="-1"]),
                                     area[href],
                                     input:not([disabled]),
                                     select:not([disabled]),
                                     textarea:not([disabled]),
                                     button:not([disabled]),
                                     iframe,
                                     object,
                                     embed,
                                     *[tabindex]:not([tabindex="-1"]),
                                     *[contenteditable]`);
};
var onKeyDown;
var bind = (el, { value = true }) => {
  if (value) {
    let focusable = findFocusable(el);
    let focusableProg = findFocusable(el, true);
    if (focusable && focusable.length > 0) {
      onKeyDown = (event) => {
        focusable = findFocusable(el);
        focusableProg = findFocusable(el, true);
        const firstFocusable = focusable[0];
        const lastFocusable = focusable[focusable.length - 1];
        if (event.target === firstFocusable && event.shiftKey && event.key === "Tab") {
          event.preventDefault();
          lastFocusable.focus();
        } else if ((event.target === lastFocusable || Array.from(focusableProg).indexOf(event.target) >= 0) && !event.shiftKey && event.key === "Tab") {
          event.preventDefault();
          firstFocusable.focus();
        }
      };
      el.addEventListener("keydown", onKeyDown);
    }
  }
};
var unbind = (el) => {
  el.removeEventListener("keydown", onKeyDown);
};
var directive = {
  beforeMount: bind,
  beforeUnmount: unbind
};

// node_modules/@oruga-ui/oruga-next/dist/esm/DropdownItem-e41a5158.mjs
var script8 = defineComponent({
  name: "ODropdown",
  directives: {
    trapFocus: directive
  },
  configField: "dropdown",
  mixins: [BaseComponentMixin, MatchMediaMixin],
  provide() {
    return {
      $dropdown: this
    };
  },
  emits: ["update:modelValue", "active-change", "change"],
  props: {
    modelValue: {
      type: [String, Number, Boolean, Object, Array],
      default: null
    },
    disabled: Boolean,
    inline: Boolean,
    scrollable: Boolean,
    maxHeight: {
      type: [String, Number],
      default: () => {
        return getValueByPath(getOptions(), "dropdown.maxHeight", 200);
      }
    },
    position: {
      type: String,
      validator: (value) => {
        return [
          "top-right",
          "top-left",
          "bottom-left",
          "bottom-right"
        ].indexOf(value) > -1;
      }
    },
    mobileModal: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "dropdown.mobileModal", true);
      }
    },
    ariaRole: {
      type: String,
      validator: (value) => {
        return [
          "menu",
          "list",
          "dialog"
        ].indexOf(value) > -1;
      },
      default: null
    },
    animation: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "dropdown.animation", "fade");
      }
    },
    multiple: Boolean,
    trapFocus: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "dropdown.trapFocus", true);
      }
    },
    closeOnClick: {
      type: Boolean,
      default: true
    },
    canClose: {
      type: [Array, Boolean],
      default: true
    },
    expanded: Boolean,
    triggers: {
      type: Array,
      default: () => ["click"]
    },
    appendToBody: Boolean,
    menuTag: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "dropdown.menuTag", "div");
      }
    },
    appendToBodyCopyParent: Boolean,
    rootClass: [String, Function, Array],
    triggerClass: [String, Function, Array],
    inlineClass: [String, Function, Array],
    menuMobileOverlayClass: [String, Function, Array],
    menuClass: [String, Function, Array],
    menuPositionClass: [String, Function, Array],
    menuActiveClass: [String, Function, Array],
    mobileClass: [String, Function, Array],
    disabledClass: [String, Function, Array],
    expandedClass: [String, Function, Array]
  },
  data() {
    return {
      selected: this.modelValue,
      isActive: false,
      isHoverable: false,
      bodyEl: void 0
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-drop"),
        { [this.computedClass("disabledClass", "o-drop--disabled")]: this.disabled },
        { [this.computedClass("expandedClass", "o-drop--expanded")]: this.expanded },
        { [this.computedClass("inlineClass", "o-drop--inline")]: this.inline },
        { [this.computedClass("mobileClass", "o-drop--mobile")]: this.isMobileModal && this.isMatchMedia && !this.hoverable }
      ];
    },
    triggerClasses() {
      return [
        this.computedClass("triggerClass", "o-drop__trigger")
      ];
    },
    menuMobileOverlayClasses() {
      return [
        this.computedClass("menuMobileOverlayClass", "o-drop__overlay")
      ];
    },
    menuClasses() {
      return [
        this.computedClass("menuClass", "o-drop__menu"),
        { [this.computedClass("menuPositionClass", "o-drop__menu--", this.position)]: this.position },
        { [this.computedClass("menuActiveClass", "o-drop__menu--active")]: this.isActive || this.inline }
      ];
    },
    isMobileModal() {
      return this.mobileModal && !this.inline;
    },
    cancelOptions() {
      return typeof this.canClose === "boolean" ? this.canClose ? ["escape", "outside"] : [] : this.canClose;
    },
    menuStyle() {
      return {
        maxHeight: this.scrollable ? toCssDimension(this.maxHeight) : null,
        overflow: this.scrollable ? "auto" : null
      };
    },
    hoverable() {
      return this.triggers.indexOf("hover") >= 0;
    }
  },
  watch: {
    modelValue(value) {
      this.selected = value;
    },
    isActive(value) {
      this.$emit("active-change", value);
      if (this.appendToBody) {
        this.$nextTick(() => {
          this.updateAppendToBody();
        });
      }
    }
  },
  methods: {
    selectItem(value) {
      if (this.multiple) {
        if (this.selected) {
          if (this.selected.indexOf(value) === -1) {
            this.selected = [...this.selected, value];
          } else {
            this.selected = this.selected.filter((val) => val !== value);
          }
        } else {
          this.selected = [value];
        }
        this.$emit("change", this.selected);
      } else {
        if (this.selected !== value) {
          this.selected = value;
          this.$emit("change", this.selected);
        }
      }
      this.$emit("update:modelValue", this.selected);
      if (!this.multiple) {
        this.isActive = !this.closeOnClick;
        if (this.hoverable && this.closeOnClick) {
          this.isHoverable = false;
        }
      }
    },
    isInWhiteList(el) {
      if (el === this.$refs.dropdownMenu)
        return true;
      if (el === this.$refs.trigger)
        return true;
      if (this.$refs.dropdownMenu !== void 0) {
        const children = this.$refs.dropdownMenu.querySelectorAll("*");
        for (const child of children) {
          if (el === child) {
            return true;
          }
        }
      }
      if (this.$refs.trigger !== void 0) {
        const children = this.$refs.trigger.querySelectorAll("*");
        for (const child of children) {
          if (el === child) {
            return true;
          }
        }
      }
      return false;
    },
    clickedOutside(event) {
      if (this.cancelOptions.indexOf("outside") < 0)
        return;
      if (this.inline)
        return;
      if (!this.isInWhiteList(event.target))
        this.isActive = false;
    },
    keyPress({ key }) {
      if (this.isActive && (key === "Escape" || key === "Esc")) {
        if (this.cancelOptions.indexOf("escape") < 0)
          return;
        this.isActive = false;
      }
    },
    onClick() {
      if (this.triggers.indexOf("click") < 0)
        return;
      this.toggle();
    },
    onContextMenu() {
      if (this.triggers.indexOf("contextmenu") < 0)
        return;
      this.toggle();
    },
    onHover() {
      if (this.triggers.indexOf("hover") < 0)
        return;
      this.isHoverable = true;
    },
    onFocus() {
      if (this.triggers.indexOf("focus") < 0)
        return;
      this.toggle();
    },
    toggle() {
      if (this.disabled)
        return;
      if (!this.isActive) {
        this.$nextTick(() => {
          const value = !this.isActive;
          this.isActive = value;
          setTimeout(() => this.isActive = value);
        });
      } else {
        this.isActive = !this.isActive;
      }
    },
    updateAppendToBody() {
      const dropdownMenu = this.$refs.dropdownMenu;
      const trigger = this.$refs.trigger;
      if (dropdownMenu && trigger) {
        const dropdown = this.$data.bodyEl.children[0];
        dropdown.classList.forEach((item) => dropdown.classList.remove(...item.split(" ")));
        this.rootClasses.forEach((item) => {
          if (item) {
            if (typeof item === "object") {
              Object.keys(item).filter((key) => key && item[key]).forEach((key) => dropdown.classList.add(key));
            } else {
              dropdown.classList.add(...item.split(" "));
            }
          }
        });
        if (this.appendToBodyCopyParent) {
          const parentNode = this.$refs.dropdown.parentNode;
          const parent = this.$data.bodyEl;
          parent.classList.forEach((item) => parent.classList.remove(...item.split(" ")));
          parentNode.classList.forEach((item) => parent.classList.add(...item.split(" ")));
        }
        const rect = trigger.getBoundingClientRect();
        let top = rect.top + window.scrollY;
        let left = rect.left + window.scrollX;
        if (!this.position || this.position.indexOf("bottom") >= 0) {
          top += trigger.clientHeight;
        } else {
          top -= dropdownMenu.clientHeight;
        }
        if (this.position && this.position.indexOf("left") >= 0) {
          left -= dropdownMenu.clientWidth - trigger.clientWidth;
        }
        dropdownMenu.style.position = "absolute";
        dropdownMenu.style.top = `${top}px`;
        dropdownMenu.style.left = `${left}px`;
        dropdownMenu.style.zIndex = "9999";
      }
    }
  },
  mounted() {
    if (this.appendToBody) {
      this.$data.bodyEl = createAbsoluteElement(this.$refs.dropdownMenu);
      this.updateAppendToBody();
    }
  },
  created() {
    if (typeof window !== "undefined") {
      document.addEventListener("click", this.clickedOutside);
      document.addEventListener("keyup", this.keyPress);
    }
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      document.removeEventListener("click", this.clickedOutside);
      document.removeEventListener("keyup", this.keyPress);
    }
    if (this.appendToBody) {
      removeElement(this.$data.bodyEl);
    }
  }
});
function render8(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_trap_focus = resolveDirective("trap-focus");
  return openBlock(), createBlock(
    "div",
    {
      ref: "dropdown",
      class: _ctx.rootClasses,
      onMouseleave: _cache[5] || (_cache[5] = ($event) => _ctx.isHoverable = false)
    },
    [!_ctx.inline ? (openBlock(), createBlock(
      "div",
      {
        key: 0,
        tabindex: _ctx.disabled ? null : 0,
        ref: "trigger",
        class: _ctx.triggerClasses,
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClick(...args)),
        onContextmenu: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.onContextMenu(...args), ["prevent"])),
        onMouseenter: _cache[3] || (_cache[3] = (...args) => _ctx.onHover(...args)),
        onFocusCapture: _cache[4] || (_cache[4] = (...args) => _ctx.onFocus(...args)),
        "aria-haspopup": "true"
      },
      [renderSlot(_ctx.$slots, "trigger", {
        active: _ctx.isActive
      })],
      42,
      ["tabindex"]
    )) : createCommentVNode("v-if", true), createVNode(
      Transition,
      {
        name: _ctx.animation
      },
      {
        default: withCtx(() => [_ctx.isMobileModal ? withDirectives((openBlock(), createBlock(
          "div",
          {
            key: 0,
            class: _ctx.menuMobileOverlayClasses,
            "aria-hidden": !_ctx.isActive
          },
          null,
          10,
          ["aria-hidden"]
        )), [[vShow, _ctx.isActive]]) : createCommentVNode("v-if", true)]),
        _: 1
      },
      8,
      ["name"]
    ), createVNode(
      Transition,
      {
        name: _ctx.animation
      },
      {
        default: withCtx(() => [withDirectives(createVNode(
          "div",
          {
            ref: "dropdownMenu",
            is: _ctx.menuTag,
            class: _ctx.menuClasses,
            "aria-hidden": !_ctx.isActive,
            role: _ctx.ariaRole,
            "aria-modal": !_ctx.inline,
            style: _ctx.menuStyle
          },
          [renderSlot(_ctx.$slots, "default")],
          14,
          ["is", "aria-hidden", "role", "aria-modal"]
        ), [[vShow, !_ctx.disabled && (_ctx.isActive || _ctx.isHoverable) || _ctx.inline], [_directive_trap_focus, _ctx.trapFocus]])]),
        _: 3
      },
      8,
      ["name"]
    )],
    34
  );
}
script8.render = render8;
script8.__file = "src/components/dropdown/Dropdown.vue";
var script$12 = defineComponent({
  name: "ODropdownItem",
  mixins: [BaseComponentMixin],
  configField: "dropdown",
  inject: ["$dropdown"],
  emits: ["click"],
  props: {
    value: {
      type: [String, Number, Boolean, Object, Array]
    },
    disabled: Boolean,
    clickable: {
      type: Boolean,
      default: true
    },
    tag: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "dropdown.itemTag", "div");
      }
    },
    tabindex: {
      type: [Number, String],
      default: 0
    },
    ariaRole: {
      type: String,
      default: ""
    },
    itemClass: [String, Function, Array],
    itemActiveClass: [String, Function, Array],
    itemDisabledClass: [String, Function, Array]
  },
  computed: {
    parent() {
      return this.$dropdown;
    },
    rootClasses() {
      return [
        this.computedClass("itemClass", "o-drop__item"),
        { [this.computedClass("itemDisabledClass", "o-drop__item--disabled")]: this.parent.disabled || this.disabled },
        { [this.computedClass("itemActiveClass", "o-drop__item--active")]: this.isActive }
      ];
    },
    ariaRoleItem() {
      return this.ariaRole === "menuitem" || this.ariaRole === "listitem" ? this.ariaRole : null;
    },
    isClickable() {
      return !this.parent.disabled && !this.disabled && this.clickable;
    },
    isActive() {
      if (this.parent.selected === null)
        return false;
      if (this.parent.multiple)
        return this.parent.selected.indexOf(this.value) >= 0;
      return this.value === this.parent.selected;
    }
  },
  methods: {
    selectItem() {
      if (!this.isClickable)
        return;
      this.parent.selectItem(this.value);
      this.$emit("click");
    }
  },
  created() {
    if (!this.parent) {
      throw new Error("You should wrap oDropdownItem on a oDropdown");
    }
  }
});
function render$12(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent(_ctx.tag),
    {
      class: _ctx.rootClasses,
      onClick: _ctx.selectItem,
      role: _ctx.ariaRoleItem,
      tabindex: _ctx.tabindex
    },
    {
      default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
      _: 3
    },
    8,
    ["class", "onClick", "role", "tabindex"]
  );
}
script$12.render = render$12;
script$12.__file = "src/components/dropdown/DropdownItem.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/Field-5b14380f.mjs
var script9 = defineComponent({
  name: "OFieldBody",
  inject: ["$field"],
  configField: "field",
  computed: {
    parent() {
      return this.$field;
    }
  },
  render() {
    let first = true;
    const slot = this.$slots.default();
    const children = slot.length === 1 && Array.isArray(slot[0].children) ? slot[0].children : slot;
    return h("div", { class: this.parent.bodyHorizontalClasses }, children.map((element) => {
      let message;
      if (element.type === Comment || element.type === Text) {
        return element;
      }
      if (first) {
        message = this.parent.newMessage;
        first = false;
      }
      return h(resolveComponent("OField"), { variant: this.parent.newVariant, message }, () => [element]);
    }));
  }
});
script9.__file = "src/components/field/FieldBody.vue";
var script$13 = defineComponent({
  name: "OField",
  components: {
    [script9.name]: script9
  },
  configField: "field",
  mixins: [BaseComponentMixin, MatchMediaMixin],
  provide() {
    return {
      $field: this
    };
  },
  inject: {
    $field: { from: "$field", default: false }
  },
  props: {
    variant: String,
    label: String,
    labelFor: String,
    message: String,
    grouped: Boolean,
    groupMultiline: Boolean,
    horizontal: Boolean,
    addons: {
      type: Boolean,
      default: true
    },
    labelSize: String,
    rootClass: [String, Function, Array],
    horizontalClass: [String, Function, Array],
    groupedClass: [String, Function, Array],
    groupMultilineClass: [String, Function, Array],
    labelClass: [String, Function, Array],
    labelSizeClass: [String, Function, Array],
    labelHorizontalClass: [String, Function, Array],
    bodyClass: [String, Function, Array],
    bodyHorizontalClass: [String, Function, Array],
    addonsClass: [String, Function, Array],
    messageClass: [String, Function, Array],
    variantMessageClass: [String, Function, Array],
    variantLabelClass: [String, Function, Array],
    mobileClass: [String, Function, Array],
    focusedClass: [String, Function, Array],
    filledClass: [String, Function, Array]
  },
  data() {
    return {
      newVariant: this.variant,
      newMessage: this.message,
      isFocused: false,
      isFilled: false
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-field"),
        { [this.computedClass("horizontalClass", "o-field--horizontal")]: this.horizontal },
        { [this.computedClass("mobileClass", "o-field--mobile")]: this.isMatchMedia },
        { [this.computedClass("focusedClass", "o-field--focused")]: this.isFocused },
        { [this.computedClass("filledClass", "o-field--filled")]: this.isFilled }
      ];
    },
    messageClasses() {
      return [
        this.computedClass("messageClass", "o-field__message"),
        { [this.computedClass("variantMessageClass", "o-field__message-", this.newVariant)]: this.newVariant }
      ];
    },
    labelClasses() {
      return [
        this.computedClass("labelClass", "o-field__label"),
        { [this.computedClass("labelSizeClass", "o-field__label-", this.labelSize)]: this.labelSize },
        { [this.computedClass("variantLabelClass", "o-field__label-", this.newVariant)]: this.newVariant }
      ];
    },
    labelHorizontalClasses() {
      return [
        this.computedClass("labelHorizontalClass", "o-field__horizontal-label")
      ];
    },
    bodyClasses() {
      return [
        this.computedClass("bodyClass", "o-field__body")
      ];
    },
    bodyHorizontalClasses() {
      return [
        this.computedClass("bodyHorizontalClass", "o-field__horizontal-body")
      ];
    },
    innerFieldClasses() {
      return [
        this.computedClass("rootClass", "o-field"),
        { [this.computedClass("groupMultilineClass", "o-field--grouped-multiline")]: this.groupMultiline },
        { [this.computedClass("groupedClass", "o-field--grouped")]: this.grouped },
        { [this.computedClass("addonsClass", "o-field--addons")]: !this.grouped && this.hasAddons() }
      ];
    },
    parent() {
      return this.$field;
    },
    hasLabelSlot() {
      return this.$slots.label;
    },
    hasMessageSlot() {
      return this.$slots.message;
    },
    hasLabel() {
      return this.label || this.hasLabelSlot;
    },
    hasMessage() {
      return (!this.parent || !this.parent.hasInnerField) && this.newMessage || this.hasMessageSlot;
    },
    hasInnerField() {
      return this.grouped || this.groupMultiline || this.hasAddons();
    }
  },
  watch: {
    variant(value) {
      this.newVariant = value;
    },
    message(value) {
      this.newMessage = value;
    },
    newMessage(value) {
      if (this.parent && this.parent.hasInnerField) {
        if (!this.parent.variant) {
          this.parent.newVariant = this.newVariant;
        }
        if (!this.parent.message) {
          this.parent.newMessage = value;
        }
      }
    }
  },
  methods: {
    hasAddons() {
      let renderedNode = 0;
      const slot = this.$slots.default();
      if (slot) {
        const children = slot.length === 1 && Array.isArray(slot[0].children) ? slot[0].children : slot;
        renderedNode = children.reduce((i, node) => node ? i + 1 : i, 0);
      }
      return renderedNode > 1 && this.addons && !this.horizontal;
    }
  }
});
function render9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_field_body = resolveComponent("o-field-body");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses
    },
    [_ctx.horizontal ? (openBlock(), createBlock(
      "div",
      {
        key: 0,
        class: _ctx.labelHorizontalClasses
      },
      [_ctx.hasLabel ? (openBlock(), createBlock(
        "label",
        {
          key: 0,
          for: _ctx.labelFor,
          class: _ctx.labelClasses
        },
        [_ctx.hasLabelSlot ? renderSlot(_ctx.$slots, "label", {
          key: 0
        }) : (openBlock(), createBlock(
          Fragment,
          {
            key: 1
          },
          [createTextVNode(
            toDisplayString(_ctx.label),
            1
          )],
          64
        ))],
        10,
        ["for"]
      )) : createCommentVNode("v-if", true)],
      2
    )) : (openBlock(), createBlock(
      Fragment,
      {
        key: 1
      },
      [_ctx.hasLabel ? (openBlock(), createBlock(
        "label",
        {
          key: 0,
          for: _ctx.labelFor,
          class: _ctx.labelClasses
        },
        [_ctx.hasLabelSlot ? renderSlot(_ctx.$slots, "label", {
          key: 0
        }) : (openBlock(), createBlock(
          Fragment,
          {
            key: 1
          },
          [createTextVNode(
            toDisplayString(_ctx.label),
            1
          )],
          64
        ))],
        10,
        ["for"]
      )) : createCommentVNode("v-if", true)],
      64
    )), _ctx.horizontal ? createVNode(_component_o_field_body, {
      key: 2
    }, {
      default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
      _: 3
    }) : _ctx.hasInnerField ? (openBlock(), createBlock(
      "div",
      {
        key: 3,
        class: _ctx.bodyClasses
      },
      [createVNode(
        "div",
        {
          class: _ctx.innerFieldClasses
        },
        [renderSlot(_ctx.$slots, "default")],
        2
      )],
      2
    )) : renderSlot(_ctx.$slots, "default", {
      key: 4
    }), _ctx.hasMessage && !_ctx.horizontal ? (openBlock(), createBlock(
      "p",
      {
        key: 5,
        class: _ctx.messageClasses
      },
      [_ctx.hasMessageSlot ? renderSlot(_ctx.$slots, "message", {
        key: 0
      }) : (openBlock(), createBlock(
        Fragment,
        {
          key: 1
        },
        [createTextVNode(
          toDisplayString(_ctx.newMessage),
          1
        )],
        64
      ))],
      2
    )) : createCommentVNode("v-if", true)],
    2
  );
}
script$13.render = render9;
script$13.__file = "src/components/field/Field.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/Select-9294146c.mjs
var script10 = defineComponent({
  name: "OSelect",
  components: {
    [script.name]: script
  },
  mixins: [BaseComponentMixin, FormElementMixin],
  configField: "select",
  inheritAttrs: false,
  emits: ["update:modelValue", "focus", "blur"],
  props: {
    modelValue: {
      type: [String, Number, Boolean, Object, Array],
      default: null
    },
    size: String,
    variant: String,
    iconPack: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "select.iconPack", void 0);
      }
    },
    iconRight: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "select.iconRight", void 0);
      }
    },
    placeholder: String,
    multiple: Boolean,
    nativeSize: [String, Number],
    rootClass: [String, Function, Array],
    selectClass: [String, Function, Array],
    iconLeftSpaceClass: [String, Function, Array],
    iconRightSpaceClass: [String, Function, Array],
    roundedClass: [String, Function, Array],
    multipleClass: [String, Function, Array],
    expandedClass: [String, Function, Array],
    iconLeftClass: [String, Function, Array],
    iconRightClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    variantClass: [String, Function, Array],
    placeholderClass: [String, Function, Array],
    arrowClass: [String, Function, Array]
  },
  data() {
    return {
      selected: this.modelValue
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-ctrl-sel"),
        { [this.computedClass("expandedClass", "o-ctrl-sel--expanded")]: this.expanded }
      ];
    },
    selectClasses() {
      return [
        this.computedClass("selectClass", "o-sel"),
        { [this.computedClass("roundedClass", "o-sel--rounded")]: this.rounded },
        { [this.computedClass("multipleClass", "o-sel--multiple")]: this.multiple },
        { [this.computedClass("sizeClass", "o-sel--", this.size)]: this.size },
        { [this.computedClass("variantClass", "o-sel--", this.statusVariant || this.variant)]: this.statusVariant || this.variant },
        { [this.computedClass("iconLeftSpaceClass", "o-sel-iconspace-left")]: this.icon },
        { [this.computedClass("iconRightSpaceClass", "o-sel-iconspace-right")]: this.iconRight },
        { [this.computedClass("placeholderClass", "o-sel--placeholder")]: this.placeholderVisible },
        { [this.computedClass("arrowClass", "o-sel-arrow")]: !this.iconRight && !this.multiple }
      ];
    },
    iconLeftClasses() {
      return [
        this.computedClass("iconLeftClass", "o-sel__icon-left")
      ];
    },
    iconRightClasses() {
      return [
        this.computedClass("iconRightClass", "o-sel__icon-right")
      ];
    },
    placeholderVisible() {
      return this.computedValue === null;
    },
    computedValue: {
      get() {
        return this.selected;
      },
      set(value) {
        this.selected = value;
        this.$emit("update:modelValue", value);
        this.syncFilled(this.selected);
        !this.isValid && this.checkHtml5Validity();
      }
    },
    $elementRef() {
      return "select";
    }
  },
  watch: {
    modelValue(value) {
      this.selected = value;
      this.syncFilled(this.selected);
      !this.isValid && this.checkHtml5Validity();
    }
  }
});
var _hoisted_12 = {
  key: 0,
  value: null,
  disabled: "",
  hidden: ""
};
function render10(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses
    },
    [withDirectives(createVNode(
      "select",
      mergeProps(_ctx.$attrs, {
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.computedValue = $event),
        class: _ctx.selectClasses,
        ref: "select",
        multiple: _ctx.multiple,
        size: _ctx.nativeSize,
        onBlur: _cache[2] || (_cache[2] = (...args) => _ctx.onBlur(...args)),
        onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.onFocus(...args))
      }),
      [_ctx.placeholder ? (openBlock(), createBlock(
        Fragment,
        {
          key: 0
        },
        [_ctx.placeholderVisible ? (openBlock(), createBlock(
          "option",
          _hoisted_12,
          toDisplayString(_ctx.placeholder),
          1
        )) : createCommentVNode("v-if", true)],
        64
      )) : createCommentVNode("v-if", true), renderSlot(_ctx.$slots, "default")],
      16,
      ["multiple", "size"]
    ), [[vModelSelect, _ctx.computedValue]]), _ctx.icon ? createVNode(
      _component_o_icon,
      {
        key: 0,
        class: _ctx.iconLeftClasses,
        icon: _ctx.icon,
        pack: _ctx.iconPack,
        size: _ctx.size
      },
      null,
      8,
      ["class", "icon", "pack", "size"]
    ) : createCommentVNode("v-if", true), _ctx.iconRight && !_ctx.multiple ? createVNode(
      _component_o_icon,
      {
        key: 1,
        class: _ctx.iconRightClasses,
        icon: _ctx.iconRight,
        pack: _ctx.iconPack,
        size: _ctx.size
      },
      null,
      8,
      ["class", "icon", "pack", "size"]
    ) : createCommentVNode("v-if", true)],
    2
  );
}
script10.render = render10;
script10.__file = "src/components/select/Select.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/Datepicker-96e63e4d.mjs
var script11 = defineComponent({
  name: "ODatepickerTableRow",
  mixins: [BaseComponentMixin],
  configField: "datepicker",
  inject: {
    $datepicker: { from: "$datepicker", default: false }
  },
  emits: ["select", "rangeHoverEndDate", "change-focus"],
  props: {
    selectedDate: {
      type: [Date, Array]
    },
    hoveredDateRange: Array,
    day: {
      type: Number
    },
    week: {
      type: Array,
      required: true
    },
    month: {
      type: Number,
      required: true
    },
    showWeekNumber: Boolean,
    minDate: Date,
    maxDate: Date,
    disabled: Boolean,
    unselectableDates: Array,
    unselectableDaysOfWeek: Array,
    selectableDates: Array,
    events: Array,
    indicators: String,
    dateCreator: Function,
    nearbyMonthDays: Boolean,
    nearbySelectableMonthDays: Boolean,
    weekNumberClickable: Boolean,
    range: Boolean,
    multiple: Boolean,
    rulesForFirstWeek: Number,
    firstDayOfWeek: Number,
    tableRowClass: [String, Function, Array],
    tableCellClass: [String, Function, Array],
    tableCellSelectedClass: [String, Function, Array],
    tableCellFirstSelectedClass: [String, Function, Array],
    tableCellWithinSelectedClass: [String, Function, Array],
    tableCellLastSelectedClass: [String, Function, Array],
    tableCellFirstHoveredClass: [String, Function, Array],
    tableCellInvisibleClass: [String, Function, Array],
    tableCellWithinHoveredClass: [String, Function, Array],
    tableCellLastHoveredClass: [String, Function, Array],
    tableCellTodayClass: [String, Function, Array],
    tableCellSelectableClass: [String, Function, Array],
    tableCellUnselectableClass: [String, Function, Array],
    tableCellNearbyClass: [String, Function, Array],
    tableCellEventsClass: [String, Function, Array],
    tableEventClass: [String, Function, Array],
    tableEventIndicatorsClass: [String, Function, Array],
    tableEventsClass: [String, Function, Array],
    tableEventVariantClass: [String, Function, Array]
  },
  computed: {
    tableRowClasses() {
      return [
        this.computedClass("tableRowClass", "o-dpck__table__row")
      ];
    },
    tableCellClasses() {
      return [
        this.computedClass("tableCellClass", "o-dpck__table__cell")
      ];
    },
    tableEventsClasses() {
      return [
        this.computedClass("tableEventsClass", "o-dpck__table__events")
      ];
    },
    hasEvents() {
      return this.events && this.events.length;
    }
  },
  watch: {
    day(day) {
      const refName = `day-${this.month}-${day}`;
      this.$nextTick(() => {
        if (this.$refs[refName] && this.$refs[refName].length > 0) {
          if (this.$refs[refName][0]) {
            this.$refs[refName][0].focus();
          }
        }
      });
    }
  },
  methods: {
    firstWeekOffset(year, dow, doy) {
      const fwd = 7 + dow - doy;
      const firstJanuary = new Date(year, 0, fwd);
      const fwdlw = (7 + firstJanuary.getDay() - dow) % 7;
      return -fwdlw + fwd - 1;
    },
    daysInYear(year) {
      return this.isLeapYear(year) ? 366 : 365;
    },
    isLeapYear(year) {
      return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    },
    getSetDayOfYear(input) {
      return Math.round((input.getTime() - new Date(input.getFullYear(), 0, 1).getTime()) / 864e5) + 1;
    },
    weeksInYear(year, dow, doy) {
      const weekOffset = this.firstWeekOffset(year, dow, doy);
      const weekOffsetNext = this.firstWeekOffset(year + 1, dow, doy);
      return (this.daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    },
    getWeekNumber(mom) {
      const dow = this.firstDayOfWeek;
      const doy = this.rulesForFirstWeek;
      const weekOffset = this.firstWeekOffset(mom.getFullYear(), dow, doy);
      const week = Math.floor((this.getSetDayOfYear(mom) - weekOffset - 1) / 7) + 1;
      let resWeek;
      let resYear;
      if (week < 1) {
        resYear = mom.getFullYear() - 1;
        resWeek = week + this.weeksInYear(resYear, dow, doy);
      } else if (week > this.weeksInYear(mom.getFullYear(), dow, doy)) {
        resWeek = week - this.weeksInYear(mom.getFullYear(), dow, doy);
        resYear = mom.getFullYear() + 1;
      } else {
        resYear = mom.getFullYear();
        resWeek = week;
      }
      return resWeek;
    },
    clickWeekNumber(week) {
      if (this.weekNumberClickable) {
        this.$datepicker.$emit("week-number-click", week);
      }
    },
    selectableDate(day) {
      const validity = [];
      if (this.minDate) {
        validity.push(day >= this.minDate);
      }
      if (this.maxDate) {
        validity.push(day <= this.maxDate);
      }
      if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {
        validity.push(day.getMonth() === this.month);
      }
      if (this.selectableDates) {
        for (let i = 0; i < this.selectableDates.length; i++) {
          const enabledDate = this.selectableDates[i];
          if (day.getDate() === enabledDate.getDate() && day.getFullYear() === enabledDate.getFullYear() && day.getMonth() === enabledDate.getMonth()) {
            return true;
          } else {
            validity.push(false);
          }
        }
      }
      if (this.unselectableDates) {
        for (let i = 0; i < this.unselectableDates.length; i++) {
          const disabledDate = this.unselectableDates[i];
          validity.push(day.getDate() !== disabledDate.getDate() || day.getFullYear() !== disabledDate.getFullYear() || day.getMonth() !== disabledDate.getMonth());
        }
      }
      if (this.unselectableDaysOfWeek) {
        for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
          const dayOfWeek = this.unselectableDaysOfWeek[i];
          validity.push(day.getDay() !== dayOfWeek);
        }
      }
      return validity.indexOf(false) < 0;
    },
    emitChosenDate(day) {
      if (this.disabled)
        return;
      if (this.selectableDate(day)) {
        this.$emit("select", day);
      }
    },
    eventsDateMatch(day) {
      if (!this.events || !this.events.length)
        return false;
      const dayEvents = [];
      for (let i = 0; i < this.events.length; i++) {
        if (this.events[i].date.getDay() === day.getDay()) {
          dayEvents.push(this.events[i]);
        }
      }
      if (!dayEvents.length) {
        return false;
      }
      return dayEvents;
    },
    cellClasses(day) {
      function dateMatch(dateOne, dateTwo, multiple = false) {
        if (!dateOne || !dateTwo || multiple) {
          return false;
        }
        if (Array.isArray(dateTwo)) {
          return dateTwo.some((date) => dateOne.getDate() === date.getDate() && dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth());
        }
        return dateOne.getDate() === dateTwo.getDate() && dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth();
      }
      function dateWithin(dateOne, dates, multiple = false) {
        if (!Array.isArray(dates) || multiple) {
          return false;
        }
        return dateOne > dates[0] && dateOne < dates[1];
      }
      return [
        ...this.tableCellClasses,
        {
          [this.computedClass("tableCellSelectedClass", "o-dpck__table__cell--selected")]: dateMatch(day, this.selectedDate) || dateWithin(day, this.selectedDate, this.multiple)
        },
        {
          [this.computedClass("tableCellFirstSelectedClass", "o-dpck__table__cell--first-selected")]: dateMatch(day, Array.isArray(this.selectedDate) && this.selectedDate[0], this.multiple)
        },
        {
          [this.computedClass("tableCellWithinSelectedClass", "o-dpck__table__cell--within-selected")]: dateWithin(day, this.selectedDate, this.multiple)
        },
        {
          [this.computedClass("tableCellLastSelectedClass", "o-dpck__table__cell--last-selected")]: dateMatch(day, Array.isArray(this.selectedDate) && this.selectedDate[1], this.multiple)
        },
        {
          [this.computedClass("tableCellFirstHoveredClass", "o-dpck__table__cell--first-hovered")]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0])
        },
        {
          [this.computedClass("tableCellWithinHoveredClass", "o-dpck__table__cell--within-hovered")]: dateWithin(day, this.hoveredDateRange)
        },
        {
          [this.computedClass("tableCellLastHoveredClass", "o-dpck__table__cell--last-hovered")]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1])
        },
        {
          [this.computedClass("tableCellTodayClass", "o-dpck__table__cell--today")]: dateMatch(day, this.dateCreator())
        },
        {
          [this.computedClass("tableCellSelectableClass", "o-dpck__table__cell--selectable")]: this.selectableDate(day) && !this.disabled
        },
        {
          [this.computedClass("tableCellUnselectableClass", "o-dpck__table__cell--unselectable")]: !this.selectableDate(day) || this.disabled
        },
        {
          [this.computedClass("tableCellInvisibleClass", "o-dpck__table__cell--invisible")]: !this.nearbyMonthDays && day.getMonth() !== this.month
        },
        {
          [this.computedClass("tableCellNearbyClass", "o-dpck__table__cell--nearby")]: this.nearbySelectableMonthDays && day.getMonth() !== this.month
        },
        {
          [this.computedClass("tableCellEventsClass", "o-dpck__table__cell--events")]: this.hasEvents
        },
        {
          [this.computedClass("tableCellTodayClass", "o-dpck__table__cell--today")]: dateMatch(day, this.dateCreator())
        }
      ];
    },
    eventClasses(event) {
      return [
        this.computedClass("tableEventClass", "o-dpck__table__event"),
        { [this.computedClass("tableEventVariantClass", "o-dpck__table__event--", event.type)]: event.type },
        { [this.computedClass("tableEventIndicatorsClass", "o-dpck__table__event--", this.indicators)]: this.indicators }
      ];
    },
    setRangeHoverEndDate(day) {
      if (this.range) {
        this.$emit("rangeHoverEndDate", day);
      }
    },
    manageKeydown(event, weekDay) {
      const { key } = event;
      let preventDefault = true;
      switch (key) {
        case "Tab": {
          preventDefault = false;
          break;
        }
        case " ":
        case "Space":
        case "Spacebar":
        case "Enter": {
          this.emitChosenDate(weekDay);
          break;
        }
        case "ArrowLeft":
        case "Left": {
          this.changeFocus(weekDay, -1);
          break;
        }
        case "ArrowRight":
        case "Right": {
          this.changeFocus(weekDay, 1);
          break;
        }
        case "ArrowUp":
        case "Up": {
          this.changeFocus(weekDay, -7);
          break;
        }
        case "ArrowDown":
        case "Down": {
          this.changeFocus(weekDay, 7);
          break;
        }
      }
      if (preventDefault) {
        event.preventDefault();
      }
    },
    changeFocus(day, inc) {
      const nextDay = new Date(day.getTime());
      nextDay.setDate(day.getDate() + inc);
      while ((!this.minDate || nextDay > this.minDate) && (!this.maxDate || nextDay < this.maxDate) && !this.selectableDate(nextDay)) {
        nextDay.setDate(day.getDate() + Math.sign(inc));
      }
      this.setRangeHoverEndDate(nextDay);
      this.$emit("change-focus", nextDay);
    }
  }
});
function render11(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.tableRowClasses
    },
    [_ctx.showWeekNumber ? (openBlock(), createBlock(
      "a",
      {
        key: 0,
        class: _ctx.tableCellClasses,
        style: {
          "cursor: pointer": _ctx.weekNumberClickable
        },
        onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.clickWeekNumber(_ctx.getWeekNumber(_ctx.week[6])), ["prevent"]))
      },
      [createVNode(
        "span",
        null,
        toDisplayString(_ctx.getWeekNumber(_ctx.week[6])),
        1
      )],
      6
    )) : createCommentVNode("v-if", true), (openBlock(true), createBlock(
      Fragment,
      null,
      renderList(_ctx.week, (weekDay, index29) => {
        return openBlock(), createBlock(
          Fragment,
          {
            key: index29
          },
          [_ctx.selectableDate(weekDay) && !_ctx.disabled ? (openBlock(), createBlock(
            "a",
            {
              key: 0,
              ref: `day-${weekDay.getMonth()}-${weekDay.getDate()}`,
              class: _ctx.cellClasses(weekDay),
              role: "button",
              href: "#",
              disabled: _ctx.disabled,
              onClick: withModifiers(($event) => _ctx.emitChosenDate(weekDay), ["prevent"]),
              onMouseenter: ($event) => _ctx.setRangeHoverEndDate(weekDay),
              onKeydown: ($event) => _ctx.manageKeydown($event, weekDay),
              tabindex: _ctx.day === weekDay.getDate() && _ctx.month === weekDay.getMonth() ? null : -1
            },
            [createVNode(
              "span",
              null,
              toDisplayString(weekDay.getDate()),
              1
            ), _ctx.eventsDateMatch(weekDay) ? (openBlock(), createBlock(
              "div",
              {
                key: 0,
                class: _ctx.tableEventsClasses
              },
              [(openBlock(true), createBlock(
                Fragment,
                null,
                renderList(_ctx.eventsDateMatch(weekDay), (event, index30) => {
                  return openBlock(), createBlock(
                    "div",
                    {
                      class: _ctx.eventClasses(event),
                      key: index30
                    },
                    null,
                    2
                  );
                }),
                128
              ))],
              2
            )) : createCommentVNode("v-if", true)],
            42,
            ["disabled", "onClick", "onMouseenter", "onKeydown", "tabindex"]
          )) : (openBlock(), createBlock(
            "div",
            {
              key: index29,
              class: _ctx.cellClasses(weekDay)
            },
            [createVNode(
              "span",
              null,
              toDisplayString(weekDay.getDate()),
              1
            )],
            2
          ))],
          64
        );
      }),
      128
    ))],
    2
  );
}
script11.render = render11;
script11.__file = "src/components/datepicker/DatepickerTableRow.vue";
var script$14 = defineComponent({
  name: "ODatepickerTable",
  mixins: [BaseComponentMixin],
  configField: "datepicker",
  components: {
    [script11.name]: script11
  },
  emits: ["update:modelValue", "range-start", "range-end", "update:focused"],
  props: {
    modelValue: {
      type: [Date, Array]
    },
    dayNames: Array,
    monthNames: Array,
    firstDayOfWeek: Number,
    events: Array,
    indicators: String,
    minDate: Date,
    maxDate: Date,
    focused: Object,
    disabled: Boolean,
    dateCreator: Function,
    unselectableDates: Array,
    unselectableDaysOfWeek: Array,
    selectableDates: Array,
    nearbyMonthDays: Boolean,
    nearbySelectableMonthDays: Boolean,
    showWeekNumber: Boolean,
    weekNumberClickable: Boolean,
    rulesForFirstWeek: Number,
    range: Boolean,
    multiple: Boolean,
    tableClass: [String, Function, Array],
    tableHeadClass: [String, Function, Array],
    tableHeadCellClass: [String, Function, Array],
    tableBodyClass: [String, Function, Array],
    tableRowClass: [String, Function, Array],
    tableCellClass: [String, Function, Array],
    tableCellSelectedClass: [String, Function, Array],
    tableCellFirstSelectedClass: [String, Function, Array],
    tableCellInvisibleClass: [String, Function, Array],
    tableCellWithinSelectedClass: [String, Function, Array],
    tableCellLastSelectedClass: [String, Function, Array],
    tableCellFirstHoveredClass: [String, Function, Array],
    tableCellWithinHoveredClass: [String, Function, Array],
    tableCellLastHoveredClass: [String, Function, Array],
    tableCellTodayClass: [String, Function, Array],
    tableCellSelectableClass: [String, Function, Array],
    tableCellUnselectableClass: [String, Function, Array],
    tableCellNearbyClass: [String, Function, Array],
    tableCellEventsClass: [String, Function, Array],
    tableEventClass: [String, Function, Array],
    tableEventIndicatorsClass: [String, Function, Array],
    tableEventsClass: [String, Function, Array],
    tableEventVariantClass: [String, Function, Array]
  },
  data() {
    return {
      selectedBeginDate: void 0,
      selectedEndDate: void 0,
      hoveredEndDate: void 0
    };
  },
  computed: {
    tableClasses() {
      return [
        this.computedClass("tableClass", "o-dpck__table")
      ];
    },
    tableHeadClasses() {
      return [
        this.computedClass("tableHeadClass", "o-dpck__table__head")
      ];
    },
    tableHeadCellClasses() {
      return [
        this.computedClass("tableHeadCellClass", "o-dpck__table__head-cell"),
        ...this.tableCellClasses
      ];
    },
    tableBodyClasses() {
      return [
        this.computedClass("tableBodyClass", "o-dpck__table__body")
      ];
    },
    tableCellClasses() {
      return [
        this.computedClass("tableCellClass", "o-dpck__table__cell")
      ];
    },
    visibleDayNames() {
      const visibleDayNames = [];
      let index29 = this.firstDayOfWeek;
      while (visibleDayNames.length < this.dayNames.length) {
        const currentDayName = this.dayNames[index29 % this.dayNames.length];
        visibleDayNames.push(currentDayName);
        index29++;
      }
      if (this.showWeekNumber)
        visibleDayNames.unshift("");
      return visibleDayNames;
    },
    eventsInThisMonth() {
      if (!this.events)
        return [];
      const monthEvents = [];
      for (let i = 0; i < this.events.length; i++) {
        let event = this.events[i];
        if (!Object.prototype.hasOwnProperty.call(event, "date")) {
          event = { date: event };
        }
        if (event.date.getMonth() === this.focused.month && event.date.getFullYear() === this.focused.year) {
          monthEvents.push(event);
        }
      }
      return monthEvents;
    },
    weeksInThisMonth() {
      this.validateFocusedDay();
      const month = this.focused.month;
      const year = this.focused.year;
      const weeksInThisMonth = [];
      let startingDay = 1;
      while (weeksInThisMonth.length < 6) {
        const newWeek = this.weekBuilder(startingDay, month, year);
        weeksInThisMonth.push(newWeek);
        startingDay += 7;
      }
      return weeksInThisMonth;
    },
    hoveredDateRange() {
      if (!this.range) {
        return [];
      }
      if (!isNaN(this.selectedEndDate)) {
        return [];
      }
      if (this.hoveredEndDate < this.selectedBeginDate) {
        return [this.hoveredEndDate, this.selectedBeginDate].filter((d) => d !== void 0);
      }
      return [this.selectedBeginDate, this.hoveredEndDate].filter((d) => d !== void 0);
    }
  },
  methods: {
    updateSelectedDate(date) {
      if (!this.range && !this.multiple) {
        this.$emit("update:modelValue", date);
      } else if (this.range) {
        this.handleSelectRangeDate(date);
      } else if (this.multiple) {
        this.handleSelectMultipleDates(date);
      }
    },
    handleSelectRangeDate(date) {
      if (this.selectedBeginDate && this.selectedEndDate) {
        this.selectedBeginDate = date;
        this.selectedEndDate = void 0;
        this.$emit("range-start", date);
      } else if (this.selectedBeginDate && !this.selectedEndDate) {
        if (this.selectedBeginDate > date) {
          this.selectedEndDate = this.selectedBeginDate;
          this.selectedBeginDate = date;
        } else {
          this.selectedEndDate = date;
        }
        this.$emit("range-end", date);
        this.$emit("update:modelValue", [this.selectedBeginDate, this.selectedEndDate]);
      } else {
        this.selectedBeginDate = date;
        this.$emit("range-start", date);
      }
    },
    handleSelectMultipleDates(date) {
      let multipleSelectedDates = this.modelValue;
      const multipleSelect = multipleSelectedDates.filter((selectedDate) => selectedDate.getDate() === date.getDate() && selectedDate.getFullYear() === date.getFullYear() && selectedDate.getMonth() === date.getMonth());
      if (multipleSelect.length) {
        multipleSelectedDates = multipleSelectedDates.filter((selectedDate) => selectedDate.getDate() !== date.getDate() || selectedDate.getFullYear() !== date.getFullYear() || selectedDate.getMonth() !== date.getMonth());
      } else {
        multipleSelectedDates = [...multipleSelectedDates, date];
      }
      this.$emit("update:modelValue", multipleSelectedDates);
    },
    weekBuilder(startingDate, month, year) {
      const thisMonth = new Date(year, month);
      const thisWeek = [];
      const dayOfWeek = new Date(year, month, startingDate).getDay();
      const end = dayOfWeek >= this.firstDayOfWeek ? dayOfWeek - this.firstDayOfWeek : 7 - this.firstDayOfWeek + dayOfWeek;
      let daysAgo = 1;
      for (let i = 0; i < end; i++) {
        thisWeek.unshift(new Date(thisMonth.getFullYear(), thisMonth.getMonth(), startingDate - daysAgo));
        daysAgo++;
      }
      thisWeek.push(new Date(year, month, startingDate));
      let daysForward = 1;
      while (thisWeek.length < 7) {
        thisWeek.push(new Date(year, month, startingDate + daysForward));
        daysForward++;
      }
      return thisWeek;
    },
    validateFocusedDay() {
      const focusedDate = new Date(this.focused.year, this.focused.month, this.focused.day);
      if (this.selectableDate(focusedDate))
        return;
      let day = 0;
      const monthDays = new Date(this.focused.year, this.focused.month + 1, 0).getDate();
      let firstFocusable = null;
      while (!firstFocusable && ++day < monthDays) {
        const date = new Date(this.focused.year, this.focused.month, day);
        if (this.selectableDate(date)) {
          firstFocusable = focusedDate;
          const focused = {
            day: date.getDate(),
            month: date.getMonth(),
            year: date.getFullYear()
          };
          this.$emit("update:focused", focused);
        }
      }
    },
    selectableDate(day) {
      const validity = [];
      if (this.minDate) {
        validity.push(day >= this.minDate);
      }
      if (this.maxDate) {
        validity.push(day <= this.maxDate);
      }
      if (this.nearbyMonthDays && !this.nearbySelectableMonthDays) {
        validity.push(day.getMonth() === this.focused.month);
      }
      if (this.selectableDates) {
        for (let i = 0; i < this.selectableDates.length; i++) {
          const enabledDate = this.selectableDates[i];
          if (day.getDate() === enabledDate.getDate() && day.getFullYear() === enabledDate.getFullYear() && day.getMonth() === enabledDate.getMonth()) {
            return true;
          } else {
            validity.push(false);
          }
        }
      }
      if (this.unselectableDates) {
        for (let i = 0; i < this.unselectableDates.length; i++) {
          const disabledDate = this.unselectableDates[i];
          validity.push(day.getDate() !== disabledDate.getDate() || day.getFullYear() !== disabledDate.getFullYear() || day.getMonth() !== disabledDate.getMonth());
        }
      }
      if (this.unselectableDaysOfWeek) {
        for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
          const dayOfWeek = this.unselectableDaysOfWeek[i];
          validity.push(day.getDay() !== dayOfWeek);
        }
      }
      return validity.indexOf(false) < 0;
    },
    eventsInThisWeek(week) {
      return this.eventsInThisMonth.filter((event) => {
        const stripped = new Date(Date.parse(event.date));
        stripped.setHours(0, 0, 0, 0);
        const timed = stripped.getTime();
        return week.some((weekDate) => weekDate.getTime() === timed);
      });
    },
    setRangeHoverEndDate(day) {
      this.hoveredEndDate = day;
    },
    changeFocus(day) {
      const focused = {
        day: day.getDate(),
        month: day.getMonth(),
        year: day.getFullYear()
      };
      this.$emit("update:focused", focused);
    }
  }
});
function render$13(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_datepicker_table_row = resolveComponent("o-datepicker-table-row");
  return openBlock(), createBlock(
    "section",
    {
      class: _ctx.tableClasses
    },
    [createVNode(
      "header",
      {
        class: _ctx.tableHeadClasses
      },
      [(openBlock(true), createBlock(
        Fragment,
        null,
        renderList(_ctx.visibleDayNames, (day, index29) => {
          return openBlock(), createBlock(
            "div",
            {
              key: index29,
              class: _ctx.tableHeadCellClasses
            },
            [createVNode(
              "span",
              null,
              toDisplayString(day),
              1
            )],
            2
          );
        }),
        128
      ))],
      2
    ), createVNode(
      "div",
      {
        class: _ctx.tableBodyClasses
      },
      [(openBlock(true), createBlock(
        Fragment,
        null,
        renderList(_ctx.weeksInThisMonth, (week, index29) => {
          return openBlock(), createBlock(
            _component_o_datepicker_table_row,
            {
              key: index29,
              "selected-date": _ctx.modelValue,
              day: _ctx.focused.day,
              week,
              month: _ctx.focused.month,
              "min-date": _ctx.minDate,
              "max-date": _ctx.maxDate,
              disabled: _ctx.disabled,
              "unselectable-dates": _ctx.unselectableDates,
              "unselectable-days-of-week": _ctx.unselectableDaysOfWeek,
              "selectable-dates": _ctx.selectableDates,
              events: _ctx.eventsInThisWeek(week),
              indicators: _ctx.indicators,
              "date-creator": _ctx.dateCreator,
              "nearby-month-days": _ctx.nearbyMonthDays,
              "nearby-selectable-month-days": _ctx.nearbySelectableMonthDays,
              "show-week-number": _ctx.showWeekNumber,
              "week-number-clickable": _ctx.weekNumberClickable,
              "first-day-of-week": _ctx.firstDayOfWeek,
              "rules-for-first-week": _ctx.rulesForFirstWeek,
              range: _ctx.range,
              "hovered-date-range": _ctx.hoveredDateRange,
              multiple: _ctx.multiple,
              "table-row-class": _ctx.tableRowClass,
              "table-cell-class": _ctx.tableCellClass,
              "table-cell-selected-class": _ctx.tableCellSelectedClass,
              "table-cell-first-selected-class": _ctx.tableCellFirstSelectedClass,
              "table-cell-invisible-class": _ctx.tableCellInvisibleClass,
              "table-cell-within-selected-class": _ctx.tableCellWithinSelectedClass,
              "table-cell-last-selected-class": _ctx.tableCellLastSelectedClass,
              "table-cell-first-hovered-class": _ctx.tableCellFirstHoveredClass,
              "table-cell-within-hovered-class": _ctx.tableCellWithinHoveredClass,
              "table-cell-last-hovered-class": _ctx.tableCellLastHoveredClass,
              "table-cell-today-class": _ctx.tableCellTodayClass,
              "table-cell-selectable-class": _ctx.tableCellSelectableClass,
              "table-cell-unselectable-class": _ctx.tableCellUnselectableClass,
              "table-cell-nearby-class": _ctx.tableCellNearbyClass,
              "table-cell-events-class": _ctx.tableCellEventsClass,
              "table-events-class": _ctx.tableEventsClass,
              "table-event-variant-class": _ctx.tableEventVariantClass,
              "table-event-class": _ctx.tableEventClass,
              "table-event-indicators-class": _ctx.tableEventIndicatorsClass,
              onSelect: _ctx.updateSelectedDate,
              onRangeHoverEndDate: _ctx.setRangeHoverEndDate,
              "onChange-focus": _ctx.changeFocus
            },
            null,
            8,
            ["selected-date", "day", "week", "month", "min-date", "max-date", "disabled", "unselectable-dates", "unselectable-days-of-week", "selectable-dates", "events", "indicators", "date-creator", "nearby-month-days", "nearby-selectable-month-days", "show-week-number", "week-number-clickable", "first-day-of-week", "rules-for-first-week", "range", "hovered-date-range", "multiple", "table-row-class", "table-cell-class", "table-cell-selected-class", "table-cell-first-selected-class", "table-cell-invisible-class", "table-cell-within-selected-class", "table-cell-last-selected-class", "table-cell-first-hovered-class", "table-cell-within-hovered-class", "table-cell-last-hovered-class", "table-cell-today-class", "table-cell-selectable-class", "table-cell-unselectable-class", "table-cell-nearby-class", "table-cell-events-class", "table-events-class", "table-event-variant-class", "table-event-class", "table-event-indicators-class", "onSelect", "onRangeHoverEndDate", "onChange-focus"]
          );
        }),
        128
      ))],
      2
    )],
    2
  );
}
script$14.render = render$13;
script$14.__file = "src/components/datepicker/DatepickerTable.vue";
var DatepickerMixin = {
  methods: {
    manageKeydown(event, weekDay) {
      const { key } = event;
      let preventDefault = true;
      switch (key) {
        case "Tab": {
          preventDefault = false;
          break;
        }
        case " ":
        case "Space":
        case "Spacebar":
        case "Enter": {
          this.emitChosenDate(weekDay);
          break;
        }
        case "ArrowLeft":
        case "Left": {
          this.changeFocus(weekDay, -1);
          break;
        }
        case "ArrowRight":
        case "Right": {
          this.changeFocus(weekDay, 1);
          break;
        }
        case "ArrowUp":
        case "Up": {
          this.changeFocus(weekDay, -7);
          break;
        }
        case "ArrowDown":
        case "Down": {
          this.changeFocus(weekDay, 7);
          break;
        }
      }
      if (preventDefault) {
        event.preventDefault();
      }
    }
  }
};
var script$2 = {
  name: "ODatepickerMonth",
  mixins: [BaseComponentMixin, DatepickerMixin],
  configField: "datepicker",
  emits: ["update:modelValue", "range-start", "range-end", "updated:focused"],
  props: {
    modelValue: {
      type: [Date, Array]
    },
    monthNames: Array,
    events: Array,
    indicators: String,
    minDate: Date,
    maxDate: Date,
    focused: Object,
    disabled: Boolean,
    dateCreator: Function,
    unselectableDates: [Array, Function],
    unselectableDaysOfWeek: Array,
    selectableDates: [Array, Function],
    range: Boolean,
    multiple: Boolean,
    monthClass: [String, Function, Array],
    monthBodyClass: [String, Function, Array],
    monthTableClass: [String, Function, Array],
    monthCellClass: [String, Function, Array],
    monthCellSelectedClass: [String, Function, Array],
    monthCellFirstSelectedClass: [String, Function, Array],
    monthCellWithinSelectedClass: [String, Function, Array],
    monthCellLastSelectedClass: [String, Function, Array],
    monthCellWithinHoveredRangeClass: [String, Function, Array],
    monthCellFirstHoveredClass: [String, Function, Array],
    monthCellWithinHoveredClass: [String, Function, Array],
    monthCellLastHoveredClass: [String, Function, Array],
    monthCellTodayClass: [String, Function, Array],
    monthCellSelectableClass: [String, Function, Array],
    monthCellUnselectableClass: [String, Function, Array],
    monthCellEventsClass: [String, Function, Array]
  },
  data() {
    return {
      selectedBeginDate: void 0,
      selectedEndDate: void 0,
      hoveredEndDate: void 0,
      multipleSelectedDates: this.multiple && this.modelValue ? this.modelValue : []
    };
  },
  computed: {
    monthClasses() {
      return [
        this.computedClass("monthClass", "o-dpck__month")
      ];
    },
    monthBodyClasses() {
      return [
        this.computedClass("monthBodyClass", "o-dpck__month__body")
      ];
    },
    monthTableClasses() {
      return [
        this.computedClass("monthTableClass", "o-dpck__month__table")
      ];
    },
    monthCellClasses() {
      return [
        this.computedClass("monthCellClass", "o-dpck__month__cell")
      ];
    },
    hasEvents() {
      return this.events && this.events.length;
    },
    eventsInThisYear() {
      if (!this.events)
        return [];
      const yearEvents = [];
      for (let i = 0; i < this.events.length; i++) {
        let event = this.events[i];
        if (!Object.prototype.hasOwnProperty.call(event, "date")) {
          event = { date: event };
        }
        if (!Object.prototype.hasOwnProperty.call(event, "type")) {
          event.type = "is-primary";
        }
        if (event.date.getFullYear() === this.focused.year) {
          yearEvents.push(event);
        }
      }
      return yearEvents;
    },
    monthDates() {
      const year = this.focused.year;
      const months = [];
      for (let i = 0; i < 12; i++) {
        const d = new Date(year, i, 1);
        d.setHours(0, 0, 0, 0);
        months.push(d);
      }
      return months;
    },
    focusedMonth() {
      return this.focused.month;
    },
    hoveredDateRange() {
      if (!this.range) {
        return [];
      }
      if (!isNaN(this.selectedEndDate)) {
        return [];
      }
      if (this.hoveredEndDate < this.selectedBeginDate) {
        return [this.hoveredEndDate, this.selectedBeginDate].filter(isDefined);
      }
      return [this.selectedBeginDate, this.hoveredEndDate].filter(isDefined);
    }
  },
  watch: {
    focusedMonth(month) {
      const refName = `month-${month}`;
      if (this.$refs[refName] && this.$refs[refName].length > 0) {
        this.$nextTick(() => {
          if (this.$refs[refName][0]) {
            this.$refs[refName][0].focus();
          }
        });
      }
    }
  },
  methods: {
    selectMultipleDates(date) {
      const multipleSelect = this.multipleSelectedDates.filter((selectedDate) => selectedDate.getDate() === date.getDate() && selectedDate.getFullYear() === date.getFullYear() && selectedDate.getMonth() === date.getMonth());
      if (multipleSelect.length) {
        this.multipleSelectedDates = this.multipleSelectedDates.filter((selectedDate) => selectedDate.getDate() !== date.getDate() || selectedDate.getFullYear() !== date.getFullYear() || selectedDate.getMonth() !== date.getMonth());
      } else {
        this.multipleSelectedDates.push(date);
      }
      this.$emit("update:modelValue", this.multipleSelectedDates);
    },
    selectableDate(day) {
      const validity = [];
      if (this.minDate) {
        validity.push(day >= this.minDate);
      }
      if (this.maxDate) {
        validity.push(day <= this.maxDate);
      }
      validity.push(day.getFullYear() === this.focused.year);
      if (this.selectableDates) {
        if (typeof this.selectableDates === "function") {
          if (this.selectableDates(day)) {
            return true;
          } else {
            validity.push(false);
          }
        } else {
          for (let i = 0; i < this.selectableDates.length; i++) {
            const enabledDate = this.selectableDates[i];
            if (day.getFullYear() === enabledDate.getFullYear() && day.getMonth() === enabledDate.getMonth()) {
              return true;
            } else {
              validity.push(false);
            }
          }
        }
      }
      if (this.unselectableDates) {
        if (typeof this.unselectableDates === "function") {
          validity.push(!this.unselectableDates(day));
        } else {
          for (let i = 0; i < this.unselectableDates.length; i++) {
            const disabledDate = this.unselectableDates[i];
            validity.push(day.getFullYear() !== disabledDate.getFullYear() || day.getMonth() !== disabledDate.getMonth());
          }
        }
      }
      if (this.unselectableDaysOfWeek) {
        for (let i = 0; i < this.unselectableDaysOfWeek.length; i++) {
          const dayOfWeek = this.unselectableDaysOfWeek[i];
          validity.push(day.getDay() !== dayOfWeek);
        }
      }
      return validity.indexOf(false) < 0;
    },
    eventsDateMatch(day) {
      if (!this.eventsInThisYear.length)
        return false;
      const monthEvents = [];
      for (let i = 0; i < this.eventsInThisYear.length; i++) {
        if (this.eventsInThisYear[i].date.getMonth() === day.getMonth()) {
          monthEvents.push(this.events[i]);
        }
      }
      if (!monthEvents.length) {
        return false;
      }
      return monthEvents;
    },
    cellClasses(day) {
      function dateMatch(dateOne, dateTwo, multiple = false) {
        if (!dateOne || !dateTwo || multiple) {
          return false;
        }
        if (Array.isArray(dateTwo)) {
          return dateTwo.some((date) => dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth());
        }
        return dateOne.getFullYear() === dateTwo.getFullYear() && dateOne.getMonth() === dateTwo.getMonth();
      }
      function dateWithin(dateOne, dates, multiple = false) {
        if (!Array.isArray(dates) || multiple) {
          return false;
        }
        return dateOne > dates[0] && dateOne < dates[1];
      }
      function dateMultipleSelected(dateOne, dates, multiple = false) {
        if (!Array.isArray(dates) || !multiple) {
          return false;
        }
        return dates.some((date) => dateOne.getDate() === date.getDate() && dateOne.getFullYear() === date.getFullYear() && dateOne.getMonth() === date.getMonth());
      }
      return [
        ...this.monthCellClasses,
        {
          [this.computedClass("monthCellSelectedClass", "o-dpck__month__cell--selected")]: dateMatch(day, this.modelValue, this.multiple) || dateWithin(day, this.modelValue, this.multiple) || dateMultipleSelected(day, this.multipleSelectedDates, this.multiple)
        },
        {
          [this.computedClass("monthCellFirstSelectedClass", "o-dpck__month__cell--first-selected")]: dateMatch(day, Array.isArray(this.modelValue) && this.modelValue[0], this.multiple)
        },
        {
          [this.computedClass("monthCellWithinSelectedClass", "o-dpck__month__cell--within-selected")]: dateWithin(day, this.modelValue, this.multiple)
        },
        {
          [this.computedClass("monthCellLastSelectedClass", "o-dpck__month__cell--last-selected")]: dateMatch(day, Array.isArray(this.modelValue) && this.modelValue[1], this.multiple)
        },
        {
          [this.computedClass("monthCellWithinHoveredRangeClass", "o-dpck__month__cell--within-hovered-range")]: this.hoveredDateRange && this.hoveredDateRange.length === 2 && (dateMatch(day, this.hoveredDateRange) || dateWithin(day, this.hoveredDateRange))
        },
        {
          [this.computedClass("monthCellFirstHoveredClass", "o-dpck__month__cell--first-hovered")]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[0])
        },
        {
          [this.computedClass("monthCellWithinHoveredClass", "o-dpck__month__cell--within-hovered")]: dateWithin(day, this.hoveredDateRange)
        },
        {
          [this.computedClass("monthCellLastHoveredClass", "o-dpck__month__cell--last-hovered")]: dateMatch(day, Array.isArray(this.hoveredDateRange) && this.hoveredDateRange[1])
        },
        {
          [this.computedClass("monthCellTodayClass", "o-dpck__month__cell--today")]: dateMatch(day, this.dateCreator())
        },
        {
          [this.computedClass("monthCellSelectableclass", "o-dpck__month__cell--selectable")]: this.selectableDate(day) && !this.disabled
        },
        {
          [this.computedClass("monthCellUnselectableClass", "o-dpck__month__cell--unselectable")]: !this.selectableDate(day) || this.disabled
        },
        {
          [this.computedClass("monthCellEventsClass", "o-dpck__month__cell--events")]: this.hasEvents
        }
      ];
    },
    updateSelectedDate(date) {
      if (!this.range && !this.multiple) {
        this.emitChosenDate(date);
      } else if (this.range) {
        this.handleSelectRangeDate(date);
      } else if (this.multiple) {
        this.selectMultipleDates(date);
      }
    },
    emitChosenDate(day) {
      if (this.disabled)
        return;
      if (!this.multiple) {
        if (this.selectableDate(day)) {
          this.$emit("update:modelValue", day);
        }
      } else {
        this.selectMultipleDates(day);
      }
    },
    handleSelectRangeDate(date) {
      if (this.disabled)
        return;
      if (this.selectedBeginDate && this.selectedEndDate) {
        this.selectedBeginDate = date;
        this.selectedEndDate = void 0;
        this.$emit("range-start", date);
      } else if (this.selectedBeginDate && !this.selectedEndDate) {
        if (this.selectedBeginDate > date) {
          this.selectedEndDate = this.selectedBeginDate;
          this.selectedBeginDate = date;
        } else {
          this.selectedEndDate = date;
        }
        this.$emit("range-end", date);
        this.$emit("update:modelValue", [this.selectedBeginDate, this.selectedEndDate]);
      } else {
        this.selectedBeginDate = date;
        this.$emit("range-start", date);
      }
    },
    setRangeHoverEndDate(day) {
      if (this.range) {
        this.hoveredEndDate = day;
      }
    },
    changeFocus(month, inc) {
      const nextMonth = month;
      nextMonth.setMonth(month.getMonth() + inc);
      this.$emit("update:focused", nextMonth);
    }
  }
};
var _hoisted_13 = {
  key: 0,
  class: "events"
};
function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "section",
    {
      class: $options.monthClasses
    },
    [createVNode(
      "div",
      {
        class: $options.monthBodyClasses
      },
      [createVNode(
        "div",
        {
          class: $options.monthTableClasses
        },
        [(openBlock(true), createBlock(
          Fragment,
          null,
          renderList($options.monthDates, (date, index29) => {
            return openBlock(), createBlock(
              Fragment,
              {
                key: index29
              },
              [$options.selectableDate(date) && !$props.disabled ? (openBlock(), createBlock(
                "a",
                {
                  key: 0,
                  ref: `month-${date.getMonth()}`,
                  class: $options.cellClasses(date),
                  role: "button",
                  href: "#",
                  disabled: $props.disabled,
                  onClick: withModifiers(($event) => $options.updateSelectedDate(date), ["prevent"]),
                  onMouseenter: ($event) => $options.setRangeHoverEndDate(date),
                  onKeydown: withModifiers(($event) => _ctx.manageKeydown($event, date), ["prevent"]),
                  tabindex: $props.focused.month === date.getMonth() ? null : -1
                },
                [createTextVNode(
                  toDisplayString($props.monthNames[date.getMonth()]) + " ",
                  1
                ), $options.eventsDateMatch(date) ? (openBlock(), createBlock("div", _hoisted_13, [(openBlock(true), createBlock(
                  Fragment,
                  null,
                  renderList($options.eventsDateMatch(date), (event, index30) => {
                    return openBlock(), createBlock(
                      "div",
                      {
                        class: ["event", event.type],
                        key: index30
                      },
                      null,
                      2
                    );
                  }),
                  128
                ))])) : createCommentVNode("v-if", true)],
                42,
                ["disabled", "onClick", "onMouseenter", "onKeydown", "tabindex"]
              )) : (openBlock(), createBlock(
                "div",
                {
                  key: 1,
                  class: $options.cellClasses(date)
                },
                toDisplayString($props.monthNames[date.getMonth()]),
                3
              ))],
              64
            );
          }),
          128
        ))],
        2
      )],
      2
    )],
    2
  );
}
script$2.render = render$2;
script$2.__file = "src/components/datepicker/DatepickerMonth.vue";
var defaultDateFormatter = (date, vm) => {
  const targetDates = Array.isArray(date) ? date : [date];
  const dates = targetDates.map((date2) => {
    const d = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate(), 12);
    return !vm.isTypeMonth ? vm.dtf.format(d) : vm.dtfMonth.format(d);
  });
  return !vm.multiple ? dates.join(" - ") : dates.join(", ");
};
var defaultDateParser = (date, vm) => {
  if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === "function") {
    const formatRegex = (vm.isTypeMonth ? vm.dtfMonth : vm.dtf).formatToParts(new Date(2e3, 11, 25)).map((part) => {
      if (part.type === "literal") {
        return part.value;
      }
      return `((?!=<${part.type}>)\\d+)`;
    }).join("");
    const dateGroups = matchWithGroups(formatRegex, date);
    if (dateGroups.year && dateGroups.year.length === 4 && dateGroups.month && dateGroups.month <= 12) {
      if (vm.isTypeMonth)
        return new Date(dateGroups.year, dateGroups.month - 1);
      else if (dateGroups.day && dateGroups.day <= 31) {
        return new Date(dateGroups.year, dateGroups.month - 1, dateGroups.day, 12);
      }
    }
  }
  if (!vm.isTypeMonth)
    return new Date(Date.parse(date));
  if (date) {
    const s = date.split("/");
    const year = s[0].length === 4 ? s[0] : s[1];
    const month = s[0].length === 2 ? s[0] : s[1];
    if (year && month) {
      return new Date(parseInt(year, 10), parseInt(month, 10) - 1, 1, 0, 0, 0, 0);
    }
  }
  return null;
};
var script$3 = defineComponent({
  name: "ODatepicker",
  components: {
    [script$14.name]: script$14,
    [script$2.name]: script$2,
    [script$13.name]: script$13,
    [script2.name]: script2,
    [script10.name]: script10,
    [script.name]: script,
    [script8.name]: script8,
    [script$12.name]: script$12
  },
  configField: "datepicker",
  mixins: [BaseComponentMixin, FormElementMixin, MatchMediaMixin],
  inheritAttrs: false,
  provide() {
    return {
      $datepicker: this
    };
  },
  emits: ["update:modelValue", "focus", "blur", "change-month", "change-year", "range-start", "range-end", "active-change", "icon-right-click"],
  props: {
    modelValue: {
      type: [Date, Array]
    },
    dayNames: {
      type: Array,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.dayNames", void 0);
      }
    },
    monthNames: {
      type: Array,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.monthNames", void 0);
      }
    },
    firstDayOfWeek: {
      type: Number,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.firstDayOfWeek", 0);
      }
    },
    size: String,
    inline: Boolean,
    minDate: Date,
    maxDate: Date,
    focusedDate: Date,
    placeholder: String,
    editable: Boolean,
    disabled: Boolean,
    unselectableDates: Array,
    unselectableDaysOfWeek: {
      type: Array,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.unselectableDaysOfWeek", void 0);
      }
    },
    selectableDates: Array,
    dateFormatter: {
      type: Function,
      default: (date, vm) => {
        const dateFormatter = getValueByPath(getOptions(), "datepicker.dateFormatter", void 0);
        if (typeof dateFormatter === "function") {
          return dateFormatter(date);
        } else {
          return defaultDateFormatter(date, vm);
        }
      }
    },
    dateParser: {
      type: Function,
      default: (date, vm) => {
        const dateParser = getValueByPath(getOptions(), "datepicker.dateParser", void 0);
        if (typeof dateParser === "function") {
          return dateParser(date);
        } else {
          return defaultDateParser(date, vm);
        }
      }
    },
    dateCreator: {
      type: Function,
      default: () => {
        const dateCreator = getValueByPath(getOptions(), "datepicker.dateCreator", void 0);
        if (typeof dateCreator === "function") {
          return dateCreator();
        } else {
          return new Date();
        }
      }
    },
    mobileNative: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.mobileNative", true);
      }
    },
    position: String,
    iconRight: String,
    iconRightClickable: Boolean,
    events: Array,
    indicators: {
      type: String,
      default: "dots"
    },
    openOnFocus: Boolean,
    iconPrev: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.iconPrev", "chevron-left");
      }
    },
    iconNext: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.iconNext", "chevron-right");
      }
    },
    yearsRange: {
      type: Array,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.yearsRange", [-100, 10]);
      }
    },
    type: {
      type: String,
      validator: (value) => {
        return [
          "month"
        ].indexOf(value) >= 0;
      }
    },
    nearbyMonthDays: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.nearbyMonthDays", true);
      }
    },
    nearbySelectableMonthDays: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.nearbySelectableMonthDays", false);
      }
    },
    showWeekNumber: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.showWeekNumber", false);
      }
    },
    weekNumberClickable: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.weekNumberClickable", false);
      }
    },
    rulesForFirstWeek: {
      type: Number,
      default: () => 4
    },
    range: {
      type: Boolean,
      default: false
    },
    closeOnClick: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean,
      default: false
    },
    mobileModal: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.mobileModal", true);
      }
    },
    trapFocus: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.trapFocus", true);
      }
    },
    locale: {
      type: [String, Array],
      default: () => {
        return getValueByPath(getOptions(), "locale");
      }
    },
    appendToBody: Boolean,
    ariaNextLabel: String,
    ariaPreviousLabel: String,
    rootClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    boxClass: [String, Function, Array],
    headerClass: [String, Function, Array],
    headerButtonsClass: [String, Function, Array],
    headerButtonsSizeClass: [String, Function, Array],
    prevBtnClass: [String, Function, Array],
    nextBtnClass: [String, Function, Array],
    listsClass: [String, Function, Array],
    footerClass: [String, Function, Array],
    tableClass: [String, Function, Array],
    tableHeadClass: [String, Function, Array],
    tableHeadCellClass: [String, Function, Array],
    tableBodyClass: [String, Function, Array],
    tableRowClass: [String, Function, Array],
    tableCellClass: [String, Function, Array],
    tableCellSelectedClass: [String, Function, Array],
    tableCellFirstSelectedClass: [String, Function, Array],
    tableCellInvisibleClass: [String, Function, Array],
    tableCellWithinSelectedClass: [String, Function, Array],
    tableCellLastSelectedClass: [String, Function, Array],
    tableCellFirstHoveredClass: [String, Function, Array],
    tableCellWithinHoveredClass: [String, Function, Array],
    tableCellLastHoveredClass: [String, Function, Array],
    tableCellTodayClass: [String, Function, Array],
    tableCellSelectableClass: [String, Function, Array],
    tableCellUnselectableClass: [String, Function, Array],
    tableCellNearbyClass: [String, Function, Array],
    tableCellEventsClass: [String, Function, Array],
    tableEventsClass: [String, Function, Array],
    tableEventVariantClass: [String, Function, Array],
    tableEventClass: [String, Function, Array],
    tableEventIndicatorsClass: [String, Function, Array],
    mobileClass: [String, Function, Array],
    monthClass: [String, Function, Array],
    monthBodyClass: [String, Function, Array],
    monthTableClass: [String, Function, Array],
    monthCellClass: [String, Function, Array],
    monthCellSelectedClass: [String, Function, Array],
    monthCellFirstSelectedClass: [String, Function, Array],
    monthCellWithinSelectedClass: [String, Function, Array],
    monthCellLastSelectedClass: [String, Function, Array],
    monthCellWithinHoveredRangeClass: [String, Function, Array],
    monthCellFirstHoveredClass: [String, Function, Array],
    monthCellWithinHoveredClass: [String, Function, Array],
    monthCellLastHoveredClass: [String, Function, Array],
    monthCellTodayClass: [String, Function, Array],
    monthCellSelectableClass: [String, Function, Array],
    monthCellUnselectableClass: [String, Function, Array],
    monthCellEventsClass: [String, Function, Array],
    inputClasses: {
      type: Object,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.inputClasses", {});
      }
    },
    dropdownClasses: {
      type: Object,
      default: () => {
        return getValueByPath(getOptions(), "datepicker.dropdownClasses", {});
      }
    },
    selectListClasses: Object
  },
  data() {
    const focusedDate = (Array.isArray(this.modelValue) ? this.modelValue[0] : this.modelValue) || this.focusedDate || this.dateCreator();
    if (!this.modelValue && this.maxDate && this.maxDate.getFullYear() < focusedDate.getFullYear()) {
      focusedDate.setFullYear(this.maxDate.getFullYear());
    }
    return {
      dateSelected: this.modelValue,
      focusedDateData: {
        day: focusedDate.getDate(),
        month: focusedDate.getMonth(),
        year: focusedDate.getFullYear()
      }
    };
  },
  computed: {
    inputBind() {
      return {
        ...this.$attrs,
        ...this.inputClasses
      };
    },
    dropdownBind() {
      return {
        "root-class": this.computedClass("dropdownClasses.rootClass", "o-dpck__dropdown"),
        ...this.dropdownClasses
      };
    },
    selectListBind() {
      return {
        ...this.selectListClasses
      };
    },
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-dpck"),
        { [this.computedClass("sizeClass", "o-dpck--", this.size)]: this.size },
        { [this.computedClass("mobileClass", "o-dpck--mobile")]: this.isMatchMedia }
      ];
    },
    boxClasses() {
      return [
        this.computedClass("boxClass", "o-dpck__box")
      ];
    },
    headerClasses() {
      return [
        this.computedClass("headerClass", "o-dpck__header")
      ];
    },
    headerButtonsClasses() {
      return [
        this.computedClass("headerButtonsClass", "o-dpck__header__buttons"),
        { [this.computedClass("headerButtonsSizeClass", "o-dpck__header__buttons--", this.size)]: this.size }
      ];
    },
    prevBtnClasses() {
      return [
        this.computedClass("prevBtnClass", "o-dpck__header__previous")
      ];
    },
    nextBtnClasses() {
      return [
        this.computedClass("nextBtnClass", "o-dpck__header__next")
      ];
    },
    listsClasses() {
      return [
        this.computedClass("listsClass", "o-dpck__header__list")
      ];
    },
    footerClasses() {
      return [
        this.computedClass("footerClass", "o-dpck__footer")
      ];
    },
    computedValue: {
      get() {
        return this.dateSelected;
      },
      set(value) {
        this.updateInternalState(value);
        if (!this.multiple)
          this.togglePicker(false);
        this.$emit("update:modelValue", value);
        if (this.useHtml5Validation) {
          this.$nextTick(() => {
            this.checkHtml5Validity();
          });
        }
      }
    },
    formattedValue() {
      return this.formatValue(this.computedValue);
    },
    localeOptions() {
      return new Intl.DateTimeFormat(this.locale, {
        year: "numeric",
        month: "numeric"
      }).resolvedOptions();
    },
    dtf() {
      return new Intl.DateTimeFormat(this.locale);
    },
    dtfMonth() {
      return new Intl.DateTimeFormat(this.locale, {
        year: this.localeOptions.year || "numeric",
        month: this.localeOptions.month || "2-digit"
      });
    },
    newMonthNames() {
      if (Array.isArray(this.monthNames)) {
        return this.monthNames;
      }
      return getMonthNames(this.locale);
    },
    newDayNames() {
      if (Array.isArray(this.dayNames)) {
        return this.dayNames;
      }
      return getWeekdayNames(this.locale);
    },
    listOfMonths() {
      let minMonth = 0;
      let maxMonth = 12;
      if (this.minDate && this.focusedDateData.year === this.minDate.getFullYear()) {
        minMonth = this.minDate.getMonth();
      }
      if (this.maxDate && this.focusedDateData.year === this.maxDate.getFullYear()) {
        maxMonth = this.maxDate.getMonth();
      }
      return this.newMonthNames.map((name, index29) => {
        return {
          name,
          index: index29,
          disabled: index29 < minMonth || index29 > maxMonth
        };
      });
    },
    listOfYears() {
      let latestYear = this.focusedDateData.year + this.yearsRange[1];
      if (this.maxDate && this.maxDate.getFullYear() < latestYear) {
        latestYear = Math.max(this.maxDate.getFullYear(), this.focusedDateData.year);
      }
      let earliestYear = this.focusedDateData.year + this.yearsRange[0];
      if (this.minDate && this.minDate.getFullYear() > earliestYear) {
        earliestYear = Math.min(this.minDate.getFullYear(), this.focusedDateData.year);
      }
      const arrayOfYears = [];
      for (let i = earliestYear; i <= latestYear; i++) {
        arrayOfYears.push(i);
      }
      return arrayOfYears.reverse();
    },
    showPrev() {
      if (!this.minDate)
        return false;
      if (this.isTypeMonth) {
        return this.focusedDateData.year <= this.minDate.getFullYear();
      }
      const dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month);
      const date = new Date(this.minDate.getFullYear(), this.minDate.getMonth());
      return dateToCheck <= date;
    },
    showNext() {
      if (!this.maxDate)
        return false;
      if (this.isTypeMonth) {
        return this.focusedDateData.year >= this.maxDate.getFullYear();
      }
      const dateToCheck = new Date(this.focusedDateData.year, this.focusedDateData.month);
      const date = new Date(this.maxDate.getFullYear(), this.maxDate.getMonth());
      return dateToCheck >= date;
    },
    isMobile() {
      return this.mobileNative && isMobile.any();
    },
    isTypeMonth() {
      return this.type === "month";
    },
    ariaRole() {
      return !this.inline ? "dialog" : void 0;
    },
    $elementRef() {
      return "input";
    }
  },
  watch: {
    modelValue(value) {
      this.updateInternalState(value);
      if (!this.multiple)
        this.togglePicker(false);
    },
    focusedDate(value) {
      if (value) {
        this.focusedDateData = {
          day: value.getDate(),
          month: value.getMonth(),
          year: value.getFullYear()
        };
      }
    },
    "focusedDateData.month"(value) {
      this.$emit("change-month", value);
    },
    "focusedDateData.year"(value) {
      this.$emit("change-year", value);
    }
  },
  methods: {
    onChange(value) {
      const date = this.dateParser(value, this);
      if (date && (!isNaN(date) || Array.isArray(date) && date.length === 2 && !isNaN(date[0]) && !isNaN(date[1]))) {
        this.computedValue = date;
      } else {
        this.computedValue = null;
        if (this.$refs.input) {
          this.$refs.input.newValue = this.computedValue;
        }
      }
    },
    formatValue(value) {
      if (Array.isArray(value)) {
        const isArrayWithValidDates = Array.isArray(value) && value.every((v) => !isNaN(v));
        return isArrayWithValidDates ? this.dateFormatter([...value], this) : null;
      }
      return value && !isNaN(value) ? this.dateFormatter(value, this) : null;
    },
    prev() {
      if (this.disabled)
        return;
      if (this.isTypeMonth) {
        this.focusedDateData.year -= 1;
      } else {
        if (this.focusedDateData.month > 0) {
          this.focusedDateData.month -= 1;
        } else {
          this.focusedDateData.month = 11;
          this.focusedDateData.year -= 1;
        }
      }
    },
    next() {
      if (this.disabled)
        return;
      if (this.isTypeMonth) {
        this.focusedDateData.year += 1;
      } else {
        if (this.focusedDateData.month < 11) {
          this.focusedDateData.month += 1;
        } else {
          this.focusedDateData.month = 0;
          this.focusedDateData.year += 1;
        }
      }
    },
    formatNative(value) {
      return this.isTypeMonth ? this.formatYYYYMM(value) : this.formatYYYYMMDD(value);
    },
    formatYYYYMMDD(value) {
      const date = new Date(value);
      if (value && !isNaN(date.getTime())) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        return year + "-" + ((month < 10 ? "0" : "") + month) + "-" + ((day < 10 ? "0" : "") + day);
      }
      return "";
    },
    formatYYYYMM(value) {
      const date = new Date(value);
      if (value && !isNaN(date.getTime())) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        return year + "-" + ((month < 10 ? "0" : "") + month);
      }
      return "";
    },
    onChangeNativePicker(event) {
      const date = event.target.value;
      const s = date ? date.split("-") : [];
      if (s.length === 3) {
        const year = parseInt(s[0], 10);
        const month = parseInt(s[1]) - 1;
        const day = parseInt(s[2]);
        this.computedValue = new Date(year, month, day);
      } else {
        this.computedValue = null;
      }
    },
    updateInternalState(value) {
      if (this.dateSelected === value)
        return;
      const isArray = Array.isArray(value);
      const currentDate = isArray ? !value.length ? this.dateCreator() : value[value.length - 1] : !value ? this.dateCreator() : value;
      if (!isArray || isArray && this.dateSelected && value.length > this.dateSelected.length) {
        this.focusedDateData = {
          day: currentDate.getDate(),
          month: currentDate.getMonth(),
          year: currentDate.getFullYear()
        };
      }
      this.dateSelected = value;
    },
    togglePicker(active) {
      if (this.$refs.dropdown) {
        const isActive = typeof active === "boolean" ? active : !this.$refs.dropdown.isActive;
        if (isActive) {
          this.$refs.dropdown.isActive = isActive;
        } else if (this.closeOnClick) {
          this.$refs.dropdown.isActive = isActive;
        }
      }
    },
    handleOnFocus(event) {
      this.onFocus(event);
      if (this.openOnFocus) {
        this.togglePicker(true);
      }
    },
    toggle() {
      if (this.mobileNative && this.isMobile) {
        const input = this.$refs.input.$refs.input;
        input.focus();
        input.click();
        return;
      }
      this.$refs.dropdown.toggle();
    },
    onInputClick(event) {
      if (this.$refs.dropdown.isActive) {
        event.stopPropagation();
      }
    },
    keyPress({ key }) {
      if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === "Escape" || key === "Esc")) {
        this.togglePicker(false);
      }
    },
    onActiveChange(value) {
      if (!value) {
        this.onBlur();
      }
      this.$emit("active-change", value);
    },
    changeFocus(day) {
      this.focusedDateData = {
        day: day.getDate(),
        month: day.getMonth(),
        year: day.getFullYear()
      };
    }
  },
  created() {
    if (typeof window !== "undefined") {
      document.addEventListener("keyup", this.keyPress);
    }
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      document.removeEventListener("keyup", this.keyPress);
    }
  }
});
function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_input = resolveComponent("o-input");
  const _component_o_icon = resolveComponent("o-icon");
  const _component_o_select = resolveComponent("o-select");
  const _component_o_datepicker_table = resolveComponent("o-datepicker-table");
  const _component_o_datepicker_month = resolveComponent("o-datepicker-month");
  const _component_o_dropdown_item = resolveComponent("o-dropdown-item");
  const _component_o_dropdown = resolveComponent("o-dropdown");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses
    },
    [!_ctx.isMobile || _ctx.inline ? createVNode(
      _component_o_dropdown,
      mergeProps({
        key: 0,
        ref: "dropdown"
      }, _ctx.dropdownBind, {
        position: _ctx.position,
        disabled: _ctx.disabled,
        inline: _ctx.inline,
        "mobile-modal": _ctx.mobileModal,
        "trap-focus": _ctx.trapFocus,
        "aria-role": _ctx.ariaRole,
        "aria-modal": !_ctx.inline,
        "append-to-body": _ctx.appendToBody,
        "append-to-body-copy-parent": "",
        "onActive-change": _ctx.onActiveChange
      }),
      createSlots({
        default: withCtx(() => [createVNode(
          _component_o_dropdown_item,
          {
            override: "",
            tag: "div",
            "item-class": _ctx.boxClasses,
            disabled: _ctx.disabled,
            clickable: false
          },
          {
            default: withCtx(() => [createVNode(
              "header",
              {
                class: _ctx.headerClasses
              },
              [renderSlot(_ctx.$slots, "header", {}, () => [createVNode(
                "div",
                {
                  class: _ctx.headerButtonsClasses
                },
                [withDirectives(createVNode(
                  "a",
                  {
                    class: _ctx.prevBtnClasses,
                    role: "button",
                    href: "#",
                    "aria-label": _ctx.ariaPreviousLabel,
                    onClick: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.prev(...args), ["prevent"])),
                    onKeydown: [_cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.prev(...args), ["prevent"]), ["enter"])), _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.prev(...args), ["prevent"]), ["space"]))]
                  },
                  [createVNode(
                    _component_o_icon,
                    {
                      icon: _ctx.iconPrev,
                      pack: _ctx.iconPack,
                      both: "",
                      clickable: ""
                    },
                    null,
                    8,
                    ["icon", "pack"]
                  )],
                  42,
                  ["aria-label"]
                ), [[vShow, !_ctx.showPrev && !_ctx.disabled]]), withDirectives(createVNode(
                  "a",
                  {
                    class: _ctx.nextBtnClasses,
                    role: "button",
                    href: "#",
                    "aria-label": _ctx.ariaNextLabel,
                    onClick: _cache[7] || (_cache[7] = withModifiers((...args) => _ctx.next(...args), ["prevent"])),
                    onKeydown: [_cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.next(...args), ["prevent"]), ["enter"])), _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.next(...args), ["prevent"]), ["space"]))]
                  },
                  [createVNode(
                    _component_o_icon,
                    {
                      icon: _ctx.iconNext,
                      pack: _ctx.iconPack,
                      both: "",
                      clickable: ""
                    },
                    null,
                    8,
                    ["icon", "pack"]
                  )],
                  42,
                  ["aria-label"]
                ), [[vShow, !_ctx.showNext && !_ctx.disabled]]), createVNode(
                  "div",
                  {
                    class: _ctx.listsClasses
                  },
                  [!_ctx.isTypeMonth ? createVNode(
                    _component_o_select,
                    mergeProps({
                      key: 0,
                      modelValue: _ctx.focusedDateData.month,
                      "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => _ctx.focusedDateData.month = $event),
                      disabled: _ctx.disabled,
                      size: _ctx.size
                    }, _ctx.selectListBind),
                    {
                      default: withCtx(() => [(openBlock(true), createBlock(
                        Fragment,
                        null,
                        renderList(_ctx.listOfMonths, (month) => {
                          return openBlock(), createBlock(
                            "option",
                            {
                              value: month.index,
                              key: month.name,
                              disabled: month.disabled
                            },
                            toDisplayString(month.name),
                            9,
                            ["value", "disabled"]
                          );
                        }),
                        128
                      ))]),
                      _: 1
                    },
                    16,
                    ["modelValue", "disabled", "size"]
                  ) : createCommentVNode("v-if", true), createVNode(
                    _component_o_select,
                    mergeProps({
                      modelValue: _ctx.focusedDateData.year,
                      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => _ctx.focusedDateData.year = $event),
                      disabled: _ctx.disabled,
                      size: _ctx.size
                    }, _ctx.selectListBind),
                    {
                      default: withCtx(() => [(openBlock(true), createBlock(
                        Fragment,
                        null,
                        renderList(_ctx.listOfYears, (year) => {
                          return openBlock(), createBlock(
                            "option",
                            {
                              value: year,
                              key: year
                            },
                            toDisplayString(year),
                            9,
                            ["value"]
                          );
                        }),
                        128
                      ))]),
                      _: 1
                    },
                    16,
                    ["modelValue", "disabled", "size"]
                  )],
                  2
                )],
                2
              )])],
              2
            ), renderSlot(_ctx.$slots, "table", {}, () => [!_ctx.isTypeMonth ? createVNode(
              _component_o_datepicker_table,
              {
                key: 0,
                modelValue: _ctx.computedValue,
                "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => _ctx.computedValue = $event),
                "day-names": _ctx.newDayNames,
                "month-names": _ctx.newMonthNames,
                "first-day-of-week": _ctx.firstDayOfWeek,
                "rules-for-first-week": _ctx.rulesForFirstWeek,
                "min-date": _ctx.minDate,
                "max-date": _ctx.maxDate,
                focused: _ctx.focusedDateData,
                disabled: _ctx.disabled,
                "unselectable-dates": _ctx.unselectableDates,
                "unselectable-days-of-week": _ctx.unselectableDaysOfWeek,
                "selectable-dates": _ctx.selectableDates,
                events: _ctx.events,
                indicators: _ctx.indicators,
                "date-creator": _ctx.dateCreator,
                "type-month": _ctx.isTypeMonth,
                "nearby-month-days": _ctx.nearbyMonthDays,
                "nearby-selectable-month-days": _ctx.nearbySelectableMonthDays,
                "show-week-number": _ctx.showWeekNumber,
                "week-number-clickable": _ctx.weekNumberClickable,
                range: _ctx.range,
                multiple: _ctx.multiple,
                "table-class": _ctx.tableClass,
                "table-head-class": _ctx.tableHeadClass,
                "table-head-cell-class": _ctx.tableHeadCellClass,
                "table-body-class": _ctx.tableBodyClass,
                "table-row-class": _ctx.tableRowClass,
                "table-cell-class": _ctx.tableCellClass,
                "table-cell-selected-class": _ctx.tableCellSelectedClass,
                "table-cell-first-selected-class": _ctx.tableCellFirstSelectedClass,
                "table-cell-invisible-class": _ctx.tableCellInvisibleClass,
                "table-cell-within-selected-class": _ctx.tableCellWithinSelectedClass,
                "table-cell-last-selected-class": _ctx.tableCellLastSelectedClass,
                "table-cell-first-hovered-class": _ctx.tableCellFirstHoveredClass,
                "table-cell-within-hovered-class": _ctx.tableCellWithinHoveredClass,
                "table-cell-last-hovered-class": _ctx.tableCellLastHoveredClass,
                "table-cell-today-class": _ctx.tableCellTodayClass,
                "table-cell-selectable-class": _ctx.tableCellSelectableClass,
                "table-cell-unselectable-class": _ctx.tableCellUnselectableClass,
                "table-cell-nearby-class": _ctx.tableCellNearbyClass,
                "table-cell-events-class": _ctx.tableCellEventsClass,
                "table-events-class": _ctx.tableEventsClass,
                "table-event-variant-class": _ctx.tableEventVariantClass,
                "table-event-class": _ctx.tableEventClass,
                "table-event-indicators-class": _ctx.tableEventIndicatorsClass,
                "onRange-start": _cache[13] || (_cache[13] = (date) => _ctx.$emit("range-start", date)),
                "onRange-end": _cache[14] || (_cache[14] = (date) => _ctx.$emit("range-end", date)),
                onClose: _cache[15] || (_cache[15] = ($event) => _ctx.togglePicker(false)),
                "onUpdate:focused": _cache[16] || (_cache[16] = ($event) => _ctx.focusedDateData = $event)
              },
              null,
              8,
              ["modelValue", "day-names", "month-names", "first-day-of-week", "rules-for-first-week", "min-date", "max-date", "focused", "disabled", "unselectable-dates", "unselectable-days-of-week", "selectable-dates", "events", "indicators", "date-creator", "type-month", "nearby-month-days", "nearby-selectable-month-days", "show-week-number", "week-number-clickable", "range", "multiple", "table-class", "table-head-class", "table-head-cell-class", "table-body-class", "table-row-class", "table-cell-class", "table-cell-selected-class", "table-cell-first-selected-class", "table-cell-invisible-class", "table-cell-within-selected-class", "table-cell-last-selected-class", "table-cell-first-hovered-class", "table-cell-within-hovered-class", "table-cell-last-hovered-class", "table-cell-today-class", "table-cell-selectable-class", "table-cell-unselectable-class", "table-cell-nearby-class", "table-cell-events-class", "table-events-class", "table-event-variant-class", "table-event-class", "table-event-indicators-class"]
            ) : createCommentVNode("v-if", true), _ctx.isTypeMonth ? createVNode(
              _component_o_datepicker_month,
              {
                key: 1,
                modelValue: _ctx.computedValue,
                "onUpdate:modelValue": _cache[17] || (_cache[17] = ($event) => _ctx.computedValue = $event),
                "month-names": _ctx.newMonthNames,
                "min-date": _ctx.minDate,
                "max-date": _ctx.maxDate,
                focused: _ctx.focusedDateData,
                disabled: _ctx.disabled,
                "unselectable-dates": _ctx.unselectableDates,
                "unselectable-days-of-week": _ctx.unselectableDaysOfWeek,
                "selectable-dates": _ctx.selectableDates,
                events: _ctx.events,
                indicators: _ctx.indicators,
                "date-creator": _ctx.dateCreator,
                range: _ctx.range,
                multiple: _ctx.multiple,
                "month-class": _ctx.monthClass,
                "month-body-class": _ctx.monthBodyClass,
                "month-table-class": _ctx.monthTableClass,
                "month-cell-class": _ctx.monthCellClass,
                "month-cell-selected-class": _ctx.monthCellSelectedClass,
                "month-cell-first-selected-class": _ctx.monthCellFirstSelectedClass,
                "month-cell-within-selected-class": _ctx.monthCellWithinSelectedClass,
                "month-cell-last-selected-class": _ctx.monthCellLastSelectedClass,
                "month-cell-within-hovered-range-class": _ctx.monthCellWithinHoveredRangeClass,
                "month-cell-first-hovered-class": _ctx.monthCellFirstHoveredClass,
                "month-cell-within-hovered-class": _ctx.monthCellWithinHoveredClass,
                "month-cell-last-hovered-class": _ctx.monthCellLastHoveredClass,
                "month-cell-today-class": _ctx.monthCellTodayClass,
                "month-cell-selectable-class": _ctx.monthCellSelectableClass,
                "month-cell-unselectable-class": _ctx.monthCellUnselectableClass,
                "month-cell-events-class": _ctx.monthCellEventsClass,
                "onRange-start": _cache[18] || (_cache[18] = (date) => _ctx.$emit("range-start", date)),
                "onRange-end": _cache[19] || (_cache[19] = (date) => _ctx.$emit("range-end", date)),
                onClose: _cache[20] || (_cache[20] = ($event) => _ctx.togglePicker(false)),
                "onChange-focus": _ctx.changeFocus,
                "onUpdate:focused": _cache[21] || (_cache[21] = ($event) => _ctx.focusedDateData = $event)
              },
              null,
              8,
              ["modelValue", "month-names", "min-date", "max-date", "focused", "disabled", "unselectable-dates", "unselectable-days-of-week", "selectable-dates", "events", "indicators", "date-creator", "range", "multiple", "month-class", "month-body-class", "month-table-class", "month-cell-class", "month-cell-selected-class", "month-cell-first-selected-class", "month-cell-within-selected-class", "month-cell-last-selected-class", "month-cell-within-hovered-range-class", "month-cell-first-hovered-class", "month-cell-within-hovered-class", "month-cell-last-hovered-class", "month-cell-today-class", "month-cell-selectable-class", "month-cell-unselectable-class", "month-cell-events-class", "onChange-focus"]
            ) : createCommentVNode("v-if", true)]), _ctx.$slots.footer !== void 0 ? (openBlock(), createBlock(
              "footer",
              {
                key: 0,
                class: _ctx.footerClasses
              },
              [renderSlot(_ctx.$slots, "footer")],
              2
            )) : createCommentVNode("v-if", true)]),
            _: 3
          },
          8,
          ["item-class", "disabled"]
        )]),
        _: 2
      }, [!_ctx.inline ? {
        name: "trigger",
        fn: withCtx(() => [renderSlot(_ctx.$slots, "trigger", {}, () => [createVNode(
          _component_o_input,
          mergeProps({
            ref: "input",
            autocomplete: "off",
            "model-value": _ctx.formattedValue,
            expanded: _ctx.expanded,
            placeholder: _ctx.placeholder,
            size: _ctx.size,
            icon: _ctx.icon,
            "icon-right": _ctx.iconRight,
            "icon-right-clickable": _ctx.iconRightClickable,
            "icon-pack": _ctx.iconPack,
            rounded: _ctx.rounded,
            disabled: _ctx.disabled,
            readonly: !_ctx.editable
          }, _ctx.inputBind, {
            "use-html5-validation": false,
            onClick: _ctx.onInputClick,
            "onIcon-right-click": _cache[1] || (_cache[1] = ($event) => _ctx.$emit("icon-right-click")),
            onKeyup: _cache[2] || (_cache[2] = withKeys(($event) => _ctx.togglePicker(true), ["enter"])),
            onChange: _cache[3] || (_cache[3] = ($event) => _ctx.onChange($event.target.value)),
            onFocus: _ctx.handleOnFocus
          }),
          null,
          16,
          ["model-value", "expanded", "placeholder", "size", "icon", "icon-right", "icon-right-clickable", "icon-pack", "rounded", "disabled", "readonly", "onClick", "onFocus"]
        )])])
      } : void 0]),
      1040,
      ["position", "disabled", "inline", "mobile-modal", "trap-focus", "aria-role", "aria-modal", "append-to-body", "onActive-change"]
    ) : createVNode(
      _component_o_input,
      mergeProps({
        key: 1,
        ref: "input",
        type: !_ctx.isTypeMonth ? "date" : "month",
        autocomplete: "off",
        value: _ctx.formatNative(_ctx.computedValue),
        placeholder: _ctx.placeholder,
        size: _ctx.size,
        icon: _ctx.icon,
        "icon-pack": _ctx.iconPack,
        rounded: _ctx.rounded,
        max: _ctx.formatNative(_ctx.maxDate),
        min: _ctx.formatNative(_ctx.minDate),
        disabled: _ctx.disabled,
        readonly: false
      }, _ctx.$attrs, {
        "use-html5-validation": false,
        onChange: _ctx.onChangeNativePicker,
        onFocus: _ctx.onFocus,
        onBlur: _ctx.onBlur
      }),
      null,
      16,
      ["type", "value", "placeholder", "size", "icon", "icon-pack", "rounded", "max", "min", "disabled", "onChange", "onFocus", "onBlur"]
    )],
    2
  );
}
script$3.render = render$3;
script$3.__file = "src/components/datepicker/Datepicker.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/datepicker.mjs
var index6 = {
  install(app) {
    registerComponent(app, script$3);
  }
};
var datepicker_default = index6;

// node_modules/@oruga-ui/oruga-next/dist/esm/Timepicker-34d0b26e.mjs
var AM = "AM";
var PM = "PM";
var HOUR_FORMAT_24 = "24";
var HOUR_FORMAT_12 = "12";
var defaultTimeFormatter = (date, vm) => {
  return vm.dtf.format(date);
};
var defaultTimeParser = (timeString, vm) => {
  if (timeString) {
    let d = null;
    if (vm.computedValue && !isNaN(vm.computedValue)) {
      d = new Date(vm.computedValue);
    } else {
      d = vm.timeCreator();
      d.setMilliseconds(0);
    }
    if (vm.dtf.formatToParts && typeof vm.dtf.formatToParts === "function") {
      const formatRegex = vm.dtf.formatToParts(d).map((part) => {
        if (part.type === "literal") {
          return part.value.replace(/ /g, "\\s?");
        } else if (part.type === "dayPeriod") {
          return `((?!=<${part.type}>)(${vm.amString}|${vm.pmString}|${AM}|${PM}|${AM.toLowerCase()}|${PM.toLowerCase()})?)`;
        }
        return `((?!=<${part.type}>)\\d+)`;
      }).join("");
      const timeGroups = matchWithGroups(formatRegex, timeString);
      timeGroups.hour = timeGroups.hour ? parseInt(timeGroups.hour, 10) : null;
      timeGroups.minute = timeGroups.minute ? parseInt(timeGroups.minute, 10) : null;
      timeGroups.second = timeGroups.second ? parseInt(timeGroups.second, 10) : null;
      if (timeGroups.hour && timeGroups.hour >= 0 && timeGroups.hour < 24 && timeGroups.minute && timeGroups.minute >= 0 && timeGroups.minute < 59) {
        if (timeGroups.dayPeriod && (timeGroups.dayPeriod.toLowerCase() === vm.pmString.toLowerCase() || timeGroups.dayPeriod.toLowerCase() === PM.toLowerCase()) && timeGroups.hour < 12) {
          timeGroups.hour += 12;
        }
        d.setHours(timeGroups.hour);
        d.setMinutes(timeGroups.minute);
        d.setSeconds(timeGroups.second || 0);
        return d;
      }
    }
    let am = false;
    if (vm.hourFormat === HOUR_FORMAT_12) {
      const dateString12 = timeString.split(" ");
      timeString = dateString12[0];
      am = dateString12[1] === vm.amString || dateString12[1] === AM;
    }
    const time = timeString.split(":");
    let hours = parseInt(time[0], 10);
    const minutes = parseInt(time[1], 10);
    const seconds = vm.enableSeconds ? parseInt(time[2], 10) : 0;
    if (isNaN(hours) || hours < 0 || hours > 23 || vm.hourFormat === HOUR_FORMAT_12 && (hours < 1 || hours > 12) || isNaN(minutes) || minutes < 0 || minutes > 59) {
      return null;
    }
    d.setSeconds(seconds);
    d.setMinutes(minutes);
    if (vm.hourFormat === HOUR_FORMAT_12) {
      if (am && hours === 12) {
        hours = 0;
      } else if (!am && hours !== 12) {
        hours += 12;
      }
    }
    d.setHours(hours);
    return new Date(d.getTime());
  }
  return null;
};
var TimepickerMixin = defineComponent({
  mixins: [FormElementMixin],
  inheritAttrs: false,
  emits: ["update:modelValue"],
  props: {
    modelValue: Date,
    inline: Boolean,
    minTime: Date,
    maxTime: Date,
    placeholder: String,
    editable: Boolean,
    disabled: Boolean,
    size: String,
    hourFormat: {
      type: String
    },
    incrementHours: {
      type: Number,
      default: 1
    },
    incrementMinutes: {
      type: Number,
      default: 1
    },
    incrementSeconds: {
      type: Number,
      default: 1
    },
    timeFormatter: {
      type: Function,
      default: (date, vm) => {
        const timeFormatter = getValueByPath(getOptions(), "timepicker.timeFormatter", void 0);
        if (typeof timeFormatter === "function") {
          return timeFormatter(date);
        } else {
          return defaultTimeFormatter(date, vm);
        }
      }
    },
    timeParser: {
      type: Function,
      default: (date, vm) => {
        const timeParser = getValueByPath(getOptions(), "timepicker.timeParser", void 0);
        if (typeof timeParser === "function") {
          return timeParser(date);
        } else {
          return defaultTimeParser(date, vm);
        }
      }
    },
    mobileNative: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "timepicker.mobileNative", true);
      }
    },
    timeCreator: {
      type: Function,
      default: () => {
        const timeCreator = getValueByPath(getOptions(), "timepicker.timeCreator", void 0);
        if (typeof timeCreator === "function") {
          return timeCreator();
        } else {
          return new Date();
        }
      }
    },
    position: String,
    unselectableTimes: Array,
    openOnFocus: Boolean,
    enableSeconds: Boolean,
    defaultMinutes: Number,
    defaultSeconds: Number,
    appendToBody: Boolean,
    resetOnMeridianChange: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      dateSelected: this.modelValue,
      hoursSelected: null,
      minutesSelected: null,
      secondsSelected: null,
      meridienSelected: null,
      _elementRef: "input"
    };
  },
  computed: {
    computedValue: {
      get() {
        return this.dateSelected;
      },
      set(value) {
        this.dateSelected = value;
        this.$emit("update:modelValue", this.dateSelected);
      }
    },
    localeOptions() {
      return new Intl.DateTimeFormat(this.locale, {
        hour: "numeric",
        minute: "numeric",
        second: this.enableSeconds ? "numeric" : void 0
      }).resolvedOptions();
    },
    dtf() {
      return new Intl.DateTimeFormat(this.locale, {
        hour: this.localeOptions.hour || "numeric",
        minute: this.localeOptions.minute || "numeric",
        second: this.enableSeconds ? this.localeOptions.second || "numeric" : void 0,
        hourCycle: !this.isHourFormat24 ? "h12" : "h23"
      });
    },
    newHourFormat() {
      return this.hourFormat || (this.localeOptions.hour12 ? HOUR_FORMAT_12 : HOUR_FORMAT_24);
    },
    sampleTime() {
      let d = this.timeCreator();
      d.setHours(10);
      d.setSeconds(0);
      d.setMinutes(0);
      d.setMilliseconds(0);
      return d;
    },
    hourLiteral() {
      if (this.dtf.formatToParts && typeof this.dtf.formatToParts === "function") {
        let d = this.sampleTime;
        const parts = this.dtf.formatToParts(d);
        const literal = parts.find((part, idx) => idx > 0 && parts[idx - 1].type === "hour");
        if (literal) {
          return literal.value;
        }
      }
      return ":";
    },
    minuteLiteral() {
      if (this.dtf.formatToParts && typeof this.dtf.formatToParts === "function") {
        let d = this.sampleTime;
        const parts = this.dtf.formatToParts(d);
        const literal = parts.find((part, idx) => idx > 0 && parts[idx - 1].type === "minute");
        if (literal) {
          return literal.value;
        }
      }
      return ":";
    },
    secondLiteral() {
      if (this.dtf.formatToParts && typeof this.dtf.formatToParts === "function") {
        let d = this.sampleTime;
        const parts = this.dtf.formatToParts(d);
        const literal = parts.find((part, idx) => idx > 0 && parts[idx - 1].type === "second");
        if (literal) {
          return literal.value;
        }
      }
    },
    amString() {
      if (this.dtf.formatToParts && typeof this.dtf.formatToParts === "function") {
        let d = this.sampleTime;
        d.setHours(10);
        const dayPeriod = this.dtf.formatToParts(d).find((part) => part.type === "dayPeriod");
        if (dayPeriod) {
          return dayPeriod.value;
        }
      }
      return AM;
    },
    pmString() {
      if (this.dtf.formatToParts && typeof this.dtf.formatToParts === "function") {
        let d = this.sampleTime;
        d.setHours(20);
        const dayPeriod = this.dtf.formatToParts(d).find((part) => part.type === "dayPeriod");
        if (dayPeriod) {
          return dayPeriod.value;
        }
      }
      return PM;
    },
    hours() {
      if (!this.incrementHours || this.incrementHours < 1)
        throw new Error("Hour increment cannot be null or less than 1.");
      const hours = [];
      const numberOfHours = this.isHourFormat24 ? 24 : 12;
      for (let i = 0; i < numberOfHours; i += this.incrementHours) {
        let value = i;
        let label = value;
        if (!this.isHourFormat24) {
          value = i + 1;
          label = value;
          if (this.meridienSelected === this.amString) {
            if (value === 12) {
              value = 0;
            }
          } else if (this.meridienSelected === this.pmString) {
            if (value !== 12) {
              value += 12;
            }
          }
        }
        hours.push({
          label: this.formatNumber(label),
          value
        });
      }
      return hours;
    },
    minutes() {
      if (!this.incrementMinutes || this.incrementMinutes < 1)
        throw new Error("Minute increment cannot be null or less than 1.");
      const minutes = [];
      for (let i = 0; i < 60; i += this.incrementMinutes) {
        minutes.push({
          label: this.formatNumber(i, true),
          value: i
        });
      }
      return minutes;
    },
    seconds() {
      if (!this.incrementSeconds || this.incrementSeconds < 1)
        throw new Error("Second increment cannot be null or less than 1.");
      const seconds = [];
      for (let i = 0; i < 60; i += this.incrementSeconds) {
        seconds.push({
          label: this.formatNumber(i, true),
          value: i
        });
      }
      return seconds;
    },
    meridiens() {
      return [this.amString, this.pmString];
    },
    isMobile() {
      return this.mobileNative && isMobile.any();
    },
    isHourFormat24() {
      return this.newHourFormat === HOUR_FORMAT_24;
    }
  },
  watch: {
    hourFormat() {
      if (this.hoursSelected !== null) {
        this.meridienSelected = this.hoursSelected >= 12 ? this.pmString : this.amString;
      }
    },
    locale() {
      if (!this.value) {
        this.meridienSelected = this.amString;
      }
    },
    modelValue: {
      handler(value) {
        this.updateInternalState(value);
        !this.isValid && this.$refs.input.checkHtml5Validity();
      },
      immediate: true
    }
  },
  methods: {
    onMeridienChange(value) {
      if (this.hoursSelected !== null && this.resetOnMeridianChange) {
        this.hoursSelected = null;
        this.minutesSelected = null;
        this.secondsSelected = null;
        this.computedValue = null;
      } else if (this.hoursSelected !== null) {
        if (value === this.pmString) {
          this.hoursSelected += 12;
        } else if (value === this.amString) {
          this.hoursSelected -= 12;
        }
      }
      this.updateDateSelected(this.hoursSelected, this.minutesSelected, this.enableSeconds ? this.secondsSelected : 0, value);
    },
    onHoursChange(value) {
      if (!this.minutesSelected && typeof this.defaultMinutes !== "undefined") {
        this.minutesSelected = this.defaultMinutes;
      }
      if (!this.secondsSelected && typeof this.defaultSeconds !== "undefined") {
        this.secondsSelected = this.defaultSeconds;
      }
      this.updateDateSelected(parseInt(value, 10), this.minutesSelected, this.enableSeconds ? this.secondsSelected : 0, this.meridienSelected);
    },
    onMinutesChange(value) {
      if (!this.secondsSelected && this.defaultSeconds) {
        this.secondsSelected = this.defaultSeconds;
      }
      this.updateDateSelected(this.hoursSelected, parseInt(value, 10), this.enableSeconds ? this.secondsSelected : 0, this.meridienSelected);
    },
    onSecondsChange(value) {
      this.updateDateSelected(this.hoursSelected, this.minutesSelected, parseInt(value, 10), this.meridienSelected);
    },
    updateDateSelected(hours, minutes, seconds, meridiens) {
      if (hours != null && minutes != null && (!this.isHourFormat24 && meridiens !== null || this.isHourFormat24)) {
        let time = null;
        if (this.computedValue && !isNaN(this.computedValue)) {
          time = new Date(this.computedValue);
        } else {
          time = this.timeCreator();
          time.setMilliseconds(0);
        }
        time.setHours(hours);
        time.setMinutes(minutes);
        time.setSeconds(seconds);
        if (!isNaN(time.getTime())) {
          this.computedValue = new Date(time.getTime());
        }
      }
    },
    updateInternalState(value) {
      if (value) {
        this.hoursSelected = value.getHours();
        this.minutesSelected = value.getMinutes();
        this.secondsSelected = value.getSeconds();
        this.meridienSelected = value.getHours() >= 12 ? this.pmString : this.amString;
      } else {
        this.hoursSelected = null;
        this.minutesSelected = null;
        this.secondsSelected = null;
        this.meridienSelected = this.amString;
      }
      this.dateSelected = value;
    },
    isHourDisabled(hour) {
      let disabled = false;
      if (this.minTime) {
        const minHours = this.minTime.getHours();
        const noMinutesAvailable = this.minutes.every((minute) => {
          return this.isMinuteDisabledForHour(hour, minute.value);
        });
        disabled = hour < minHours || noMinutesAvailable;
      }
      if (this.maxTime) {
        if (!disabled) {
          const maxHours = this.maxTime.getHours();
          disabled = hour > maxHours;
        }
      }
      if (this.unselectableTimes) {
        if (!disabled) {
          const unselectable = this.unselectableTimes.filter((time) => {
            if (this.enableSeconds && this.secondsSelected !== null) {
              return time.getHours() === hour && time.getMinutes() === this.minutesSelected && time.getSeconds() === this.secondsSelected;
            } else if (this.minutesSelected !== null) {
              return time.getHours() === hour && time.getMinutes() === this.minutesSelected;
            }
            return false;
          });
          if (unselectable.length > 0) {
            disabled = true;
          } else {
            disabled = this.minutes.every((minute) => {
              return this.unselectableTimes.filter((time) => {
                return time.getHours() === hour && time.getMinutes() === minute.value;
              }).length > 0;
            });
          }
        }
      }
      return disabled;
    },
    isMinuteDisabledForHour(hour, minute) {
      let disabled = false;
      if (this.minTime) {
        const minHours = this.minTime.getHours();
        const minMinutes = this.minTime.getMinutes();
        disabled = hour === minHours && minute < minMinutes;
      }
      if (this.maxTime) {
        if (!disabled) {
          const maxHours = this.maxTime.getHours();
          const maxMinutes = this.maxTime.getMinutes();
          disabled = hour === maxHours && minute > maxMinutes;
        }
      }
      return disabled;
    },
    isMinuteDisabled(minute) {
      let disabled = false;
      if (this.hoursSelected !== null) {
        if (this.isHourDisabled(this.hoursSelected)) {
          disabled = true;
        } else {
          disabled = this.isMinuteDisabledForHour(this.hoursSelected, minute);
        }
        if (this.unselectableTimes) {
          if (!disabled) {
            const unselectable = this.unselectableTimes.filter((time) => {
              if (this.enableSeconds && this.secondsSelected !== null) {
                return time.getHours() === this.hoursSelected && time.getMinutes() === minute && time.getSeconds() === this.secondsSelected;
              } else {
                return time.getHours() === this.hoursSelected && time.getMinutes() === minute;
              }
            });
            disabled = unselectable.length > 0;
          }
        }
      }
      return disabled;
    },
    isSecondDisabled(second) {
      let disabled = false;
      if (this.minutesSelected !== null) {
        if (this.isMinuteDisabled(this.minutesSelected)) {
          disabled = true;
        } else {
          if (this.minTime) {
            const minHours = this.minTime.getHours();
            const minMinutes = this.minTime.getMinutes();
            const minSeconds = this.minTime.getSeconds();
            disabled = this.hoursSelected === minHours && this.minutesSelected === minMinutes && second < minSeconds;
          }
          if (this.maxTime) {
            if (!disabled) {
              const maxHours = this.maxTime.getHours();
              const maxMinutes = this.maxTime.getMinutes();
              const maxSeconds = this.maxTime.getSeconds();
              disabled = this.hoursSelected === maxHours && this.minutesSelected === maxMinutes && second > maxSeconds;
            }
          }
        }
        if (this.unselectableTimes) {
          if (!disabled) {
            const unselectable = this.unselectableTimes.filter((time) => {
              return time.getHours() === this.hoursSelected && time.getMinutes() === this.minutesSelected && time.getSeconds() === second;
            });
            disabled = unselectable.length > 0;
          }
        }
      }
      return disabled;
    },
    onChange(value) {
      const date = this.timeParser(value, this);
      this.updateInternalState(date);
      if (date && !isNaN(date)) {
        this.computedValue = date;
      } else {
        this.computedValue = null;
        this.$refs.input.newValue = this.computedValue;
      }
    },
    toggle(active) {
      if (this.$refs.dropdown) {
        this.$refs.dropdown.isActive = typeof active === "boolean" ? active : !this.$refs.dropdown.isActive;
      }
    },
    close() {
      this.toggle(false);
    },
    handleOnFocus() {
      this.onFocus();
      if (this.openOnFocus) {
        this.toggle(true);
      }
    },
    formatHHMMSS(value) {
      const date = new Date(value);
      if (value && !isNaN(date.getTime())) {
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        return this.formatNumber(hours, true) + ":" + this.formatNumber(minutes, true) + ":" + this.formatNumber(seconds, true);
      }
      return "";
    },
    onChangeNativePicker(event) {
      const date = event.target.value;
      if (date) {
        let time = null;
        if (this.computedValue && !isNaN(this.computedValue)) {
          time = new Date(this.computedValue);
        } else {
          time = new Date();
          time.setMilliseconds(0);
        }
        const t = date.split(":");
        time.setHours(parseInt(t[0], 10));
        time.setMinutes(parseInt(t[1], 10));
        time.setSeconds(t[2] ? parseInt(t[2], 10) : 0);
        this.computedValue = new Date(time.getTime());
      } else {
        this.computedValue = null;
      }
    },
    formatNumber(value, prependZero) {
      return this.isHourFormat24 || prependZero ? this.pad(value) : value;
    },
    pad(value) {
      return (value < 10 ? "0" : "") + value;
    },
    formatValue(date) {
      if (date && !isNaN(date)) {
        return this.timeFormatter(date, this);
      } else {
        return null;
      }
    },
    keyPress({ key }) {
      if (this.$refs.dropdown && this.$refs.dropdown.isActive && (key === "Escape" || key === "Esc")) {
        this.toggle(false);
      }
    },
    onActiveChange(value) {
      if (!value) {
        this.onBlur();
      }
    }
  },
  created() {
    if (typeof window !== "undefined") {
      document.addEventListener("keyup", this.keyPress);
    }
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      document.removeEventListener("keyup", this.keyPress);
    }
  }
});
var script12 = defineComponent({
  name: "OTimepicker",
  components: {
    [script2.name]: script2,
    [script10.name]: script10,
    [script.name]: script,
    [script8.name]: script8,
    [script$12.name]: script$12
  },
  configField: "timepicker",
  mixins: [BaseComponentMixin, TimepickerMixin, MatchMediaMixin],
  inheritAttrs: false,
  props: {
    rootClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    boxClass: [String, Function, Array],
    separatorClass: [String, Function, Array],
    footerClass: [String, Function, Array],
    inputClasses: {
      type: Object,
      default: () => {
        return getValueByPath(getOptions(), "timepicker.inputClasses", {});
      }
    },
    dropdownClasses: {
      type: Object,
      default: () => {
        return getValueByPath(getOptions(), "timepicker.dropdownClasses", {});
      }
    },
    selectClasses: {
      type: Object,
      default: () => {
        return getValueByPath(getOptions(), "timepicker.selectClasses", {});
      }
    }
  },
  computed: {
    inputBind() {
      return {
        ...this.$attrs,
        ...this.inputClasses
      };
    },
    dropdownBind() {
      return {
        "root-class": this.computedClass("dropdownClasses.rootClass", "o-tpck__dropdown"),
        ...this.dropdownClasses
      };
    },
    selectBind() {
      return {
        "select-class": this.computedClass("selectClasses.selectClass", "o-tpck__select"),
        "placeholder-class": this.computedClass("selectClasses.placeholderClass", "o-tpck__select-placeholder"),
        ...this.selectClasses
      };
    },
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-tpck"),
        { [this.computedClass("sizeClass", "o-tpck--", this.size)]: this.size },
        { [this.computedClass("mobileClass", "o-tpck--mobile")]: this.isMatchMedia }
      ];
    },
    boxClasses() {
      return [
        this.computedClass("boxClass", "o-tpck__box")
      ];
    },
    separatorClasses() {
      return [
        this.computedClass("separatorClass", "o-tpck__separator")
      ];
    },
    footerClasses() {
      return [
        this.computedClass("footerClass", "o-tpck__footer")
      ];
    },
    nativeStep() {
      if (this.enableSeconds)
        return "1";
      return null;
    }
  }
});
function render12(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_input = resolveComponent("o-input");
  const _component_o_select = resolveComponent("o-select");
  const _component_o_dropdown_item = resolveComponent("o-dropdown-item");
  const _component_o_dropdown = resolveComponent("o-dropdown");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses
    },
    [!_ctx.isMobile || _ctx.inline ? createVNode(
      _component_o_dropdown,
      mergeProps({
        key: 0,
        ref: "dropdown"
      }, _ctx.dropdownBind, {
        position: _ctx.position,
        disabled: _ctx.disabled,
        inline: _ctx.inline,
        "append-to-body": _ctx.appendToBody,
        "append-to-body-copy-parent": "",
        "onActive-change": _ctx.onActiveChange
      }),
      createSlots({
        default: withCtx(() => [createVNode(
          _component_o_dropdown_item,
          {
            override: "",
            tag: "div",
            "item-class": _ctx.boxClasses,
            disabled: _ctx.disabled,
            clickable: false
          },
          {
            default: withCtx(() => [createVNode(
              _component_o_select,
              mergeProps({
                override: ""
              }, _ctx.selectBind, {
                modelValue: _ctx.hoursSelected,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.hoursSelected = $event),
                onChange: _cache[4] || (_cache[4] = ($event) => _ctx.onHoursChange($event.target.value)),
                disabled: _ctx.disabled,
                placeholder: "00"
              }),
              {
                default: withCtx(() => [(openBlock(true), createBlock(
                  Fragment,
                  null,
                  renderList(_ctx.hours, (hour) => {
                    return openBlock(), createBlock(
                      "option",
                      {
                        value: hour.value,
                        key: hour.value,
                        disabled: _ctx.isHourDisabled(hour.value)
                      },
                      toDisplayString(hour.label),
                      9,
                      ["value", "disabled"]
                    );
                  }),
                  128
                ))]),
                _: 1
              },
              16,
              ["modelValue", "disabled"]
            ), createVNode(
              "span",
              {
                class: _ctx.separatorClasses
              },
              toDisplayString(_ctx.hourLiteral),
              3
            ), createVNode(
              _component_o_select,
              mergeProps({
                override: ""
              }, _ctx.selectBind, {
                modelValue: _ctx.minutesSelected,
                "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.minutesSelected = $event),
                onChange: _cache[6] || (_cache[6] = ($event) => _ctx.onMinutesChange($event.target.value)),
                disabled: _ctx.disabled,
                placeholder: "00"
              }),
              {
                default: withCtx(() => [(openBlock(true), createBlock(
                  Fragment,
                  null,
                  renderList(_ctx.minutes, (minute) => {
                    return openBlock(), createBlock(
                      "option",
                      {
                        value: minute.value,
                        key: minute.value,
                        disabled: _ctx.isMinuteDisabled(minute.value)
                      },
                      toDisplayString(minute.label),
                      9,
                      ["value", "disabled"]
                    );
                  }),
                  128
                ))]),
                _: 1
              },
              16,
              ["modelValue", "disabled"]
            ), _ctx.enableSeconds ? (openBlock(), createBlock(
              Fragment,
              {
                key: 0
              },
              [createVNode(
                "span",
                {
                  class: _ctx.separatorClasses
                },
                toDisplayString(_ctx.minuteLiteral),
                3
              ), createVNode(
                _component_o_select,
                mergeProps({
                  override: ""
                }, _ctx.selectBind, {
                  modelValue: _ctx.secondsSelected,
                  "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => _ctx.secondsSelected = $event),
                  onChange: _cache[8] || (_cache[8] = ($event) => _ctx.onSecondsChange($event.target.value)),
                  disabled: _ctx.disabled,
                  placeholder: "00"
                }),
                {
                  default: withCtx(() => [(openBlock(true), createBlock(
                    Fragment,
                    null,
                    renderList(_ctx.seconds, (second) => {
                      return openBlock(), createBlock(
                        "option",
                        {
                          value: second.value,
                          key: second.value,
                          disabled: _ctx.isSecondDisabled(second.value)
                        },
                        toDisplayString(second.label),
                        9,
                        ["value", "disabled"]
                      );
                    }),
                    128
                  ))]),
                  _: 1
                },
                16,
                ["modelValue", "disabled"]
              ), createVNode(
                "span",
                {
                  class: _ctx.separatorClasses
                },
                toDisplayString(_ctx.secondLiteral),
                3
              )],
              64
            )) : createCommentVNode("v-if", true), !_ctx.isHourFormat24 ? createVNode(
              _component_o_select,
              mergeProps({
                key: 1,
                override: ""
              }, _ctx.selectBind, {
                modelValue: _ctx.meridienSelected,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => _ctx.meridienSelected = $event),
                onChange: _cache[10] || (_cache[10] = ($event) => _ctx.onMeridienChange($event.target.value)),
                disabled: _ctx.disabled
              }),
              {
                default: withCtx(() => [(openBlock(true), createBlock(
                  Fragment,
                  null,
                  renderList(_ctx.meridiens, (meridien) => {
                    return openBlock(), createBlock(
                      "option",
                      {
                        value: meridien,
                        key: meridien
                      },
                      toDisplayString(meridien),
                      9,
                      ["value"]
                    );
                  }),
                  128
                ))]),
                _: 1
              },
              16,
              ["modelValue", "disabled"]
            ) : createCommentVNode("v-if", true), _ctx.$slots.default !== void 0 ? (openBlock(), createBlock(
              "footer",
              {
                key: 2,
                class: _ctx.footerClasses
              },
              [renderSlot(_ctx.$slots, "default")],
              2
            )) : createCommentVNode("v-if", true)]),
            _: 1
          },
          8,
          ["item-class", "disabled"]
        )]),
        _: 2
      }, [!_ctx.inline ? {
        name: "trigger",
        fn: withCtx(() => [renderSlot(_ctx.$slots, "trigger", {}, () => [createVNode(
          _component_o_input,
          mergeProps({
            ref: "input",
            "model-value": _ctx.formatValue(_ctx.computedValue),
            autocomplete: "off",
            placeholder: _ctx.placeholder,
            size: _ctx.size,
            icon: _ctx.icon,
            "icon-pack": _ctx.iconPack,
            disabled: _ctx.disabled,
            readonly: !_ctx.editable,
            rounded: _ctx.rounded
          }, _ctx.inputBind, {
            "use-html5-validation": _ctx.useHtml5Validation,
            onKeyup: _cache[1] || (_cache[1] = withKeys(($event) => _ctx.toggle(true), ["enter"])),
            onChange: _cache[2] || (_cache[2] = ($event) => _ctx.onChange($event.target.value)),
            onFocus: _ctx.handleOnFocus
          }),
          null,
          16,
          ["model-value", "placeholder", "size", "icon", "icon-pack", "disabled", "readonly", "rounded", "use-html5-validation", "onFocus"]
        )])])
      } : void 0]),
      1040,
      ["position", "disabled", "inline", "append-to-body", "onActive-change"]
    ) : createVNode(
      _component_o_input,
      mergeProps({
        key: 1,
        ref: "input"
      }, _ctx.inputBind, {
        type: "time",
        step: _ctx.nativeStep,
        autocomplete: "off",
        value: _ctx.formatHHMMSS(_ctx.computedValue),
        placeholder: _ctx.placeholder,
        size: _ctx.size,
        icon: _ctx.icon,
        "icon-pack": _ctx.iconPack,
        rounded: _ctx.rounded,
        max: _ctx.formatHHMMSS(_ctx.maxTime),
        min: _ctx.formatHHMMSS(_ctx.minTime),
        disabled: _ctx.disabled,
        readonly: false,
        "use-html5-validation": _ctx.useHtml5Validation,
        onChange: _cache[11] || (_cache[11] = ($event) => _ctx.onChange($event.target.value)),
        onFocus: _ctx.handleOnFocus,
        onBlur: _cache[12] || (_cache[12] = ($event) => _ctx.onBlur() && _ctx.checkHtml5Validity())
      }),
      null,
      16,
      ["step", "value", "placeholder", "size", "icon", "icon-pack", "rounded", "max", "min", "disabled", "use-html5-validation", "onFocus"]
    )],
    2
  );
}
script12.render = render12;
script12.__file = "src/components/timepicker/Timepicker.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/datetimepicker.mjs
var AM2 = "AM";
var PM2 = "PM";
var script13 = defineComponent({
  name: "ODatetimepicker",
  components: {
    [script$3.name]: script$3,
    [script12.name]: script12
  },
  configField: "datetimepicker",
  mixins: [FormElementMixin, BaseComponentMixin],
  inheritAttrs: false,
  emits: ["update:modelValue", "change-year", "change-month", "icon-right-click", "active-change"],
  props: {
    modelValue: {
      type: Date
    },
    editable: {
      type: Boolean,
      default: false
    },
    size: String,
    placeholder: String,
    disabled: Boolean,
    iconRight: String,
    iconRightClickable: Boolean,
    inline: Boolean,
    openOnFocus: Boolean,
    position: String,
    mobileNative: {
      type: Boolean,
      default: true
    },
    minDatetime: Date,
    maxDatetime: Date,
    datetimeFormatter: {
      type: Function
    },
    datetimeParser: {
      type: Function
    },
    datetimeCreator: {
      type: Function,
      default: (date) => {
        const datetimeCreator = getValueByPath(getOptions(), "datetimepicker.datetimeCreator", void 0);
        if (typeof datetimeCreator === "function") {
          return datetimeCreator(date);
        } else {
          return date;
        }
      }
    },
    datepicker: Object,
    timepicker: Object,
    locale: {
      type: [String, Array],
      default: () => {
        return getValueByPath(getOptions(), "locale");
      }
    },
    appendToBody: Boolean,
    datepickerWrapperClass: [String, Function, Array],
    timepickerWrapperClass: [String, Function, Array]
  },
  data() {
    return {
      newValue: this.modelValue
    };
  },
  computed: {
    datepickerWrapperClasses() {
      return [
        this.computedClass("datepickerWrapperClass", "o-dtpck__date")
      ];
    },
    timepickerWrapperClasses() {
      return [
        this.computedClass("timepickerWrapperClass", "o-dtpck__time")
      ];
    },
    computedValue: {
      get() {
        return this.newValue;
      },
      set(value) {
        if (value) {
          let val = new Date(value.getTime());
          if (this.newValue) {
            if ((value.getDate() !== this.newValue.getDate() || value.getMonth() !== this.newValue.getMonth() || value.getFullYear() !== this.newValue.getFullYear()) && value.getHours() === 0 && value.getMinutes() === 0 && value.getSeconds() === 0) {
              val.setHours(this.newValue.getHours(), this.newValue.getMinutes(), this.newValue.getSeconds(), 0);
            }
          } else {
            val = this.datetimeCreator(value);
          }
          if (this.minDatetime && val < this.minDatetime) {
            val = this.minDatetime;
          } else if (this.maxDatetime && val > this.maxDatetime) {
            val = this.maxDatetime;
          }
          this.newValue = new Date(val.getTime());
        } else {
          this.newValue = value;
        }
        this.$emit("update:modelValue", this.newValue);
      }
    },
    localeOptions() {
      return new Intl.DateTimeFormat(this.locale, {
        year: "numeric",
        month: "numeric",
        day: "numeric",
        hour: "numeric",
        minute: "numeric",
        second: this.enableSeconds() ? "numeric" : void 0
      }).resolvedOptions();
    },
    dtf() {
      return new Intl.DateTimeFormat(this.locale, {
        year: this.localeOptions.year || "numeric",
        month: this.localeOptions.month || "numeric",
        day: this.localeOptions.day || "numeric",
        hour: this.localeOptions.hour || "numeric",
        minute: this.localeOptions.minute || "numeric",
        second: this.enableSeconds() ? this.localeOptions.second || "numeric" : void 0,
        hourCycle: !this.isHourFormat24() ? "h12" : "h23"
      });
    },
    isMobileNative() {
      return this.mobileNative;
    },
    isMobile() {
      return this.isMobileNative && isMobile.any();
    },
    minDate() {
      if (!this.minDatetime) {
        return this.datepicker ? this.datepicker.minDate : null;
      }
      return new Date(this.minDatetime.getFullYear(), this.minDatetime.getMonth(), this.minDatetime.getDate(), 0, 0, 0, 0);
    },
    maxDate() {
      if (!this.maxDatetime) {
        return this.datepicker ? this.datepicker.maxDate : null;
      }
      return new Date(this.maxDatetime.getFullYear(), this.maxDatetime.getMonth(), this.maxDatetime.getDate(), 0, 0, 0, 0);
    },
    minTime() {
      if (!this.minDatetime || (this.newValue === null || typeof this.newValue === "undefined")) {
        return this.timepicker ? this.timepicker.minTime : null;
      }
      return this.minDatetime;
    },
    maxTime() {
      if (!this.maxDatetime || (this.newValue === null || typeof this.newValue === "undefined")) {
        return this.timepicker ? this.timepicker.maxTime : null;
      }
      return this.maxDatetime;
    },
    datepickerSize() {
      return this.datepicker && this.datepicker.size ? this.datepicker.size : this.size;
    },
    timepickerSize() {
      return this.timepicker && this.timepicker.size ? this.timepicker.size : this.size;
    },
    timepickerDisabled() {
      return this.timepicker && this.timepicker.disabled ? this.timepicker.disabled : this.disabled;
    }
  },
  watch: {
    modelValue(value) {
      this.newValue = value;
    }
  },
  methods: {
    enableSeconds() {
      if (this.$refs.timepicker) {
        return this.$refs.timepicker.enableSeconds;
      }
      return false;
    },
    isHourFormat24() {
      if (this.$refs.timepicker) {
        return this.$refs.timepicker.isHourFormat24;
      }
      return !this.localeOptions.hour12;
    },
    defaultDatetimeParser(date) {
      const datetimeParser = getValueByPath(getOptions(), "datetimepicker.datetimeParser", void 0);
      if (typeof this.datetimeParser === "function") {
        return this.datetimeParser(date);
      } else if (typeof datetimeParser === "function") {
        return datetimeParser(date);
      } else {
        if (this.dtf.formatToParts && typeof this.dtf.formatToParts === "function") {
          let dayPeriods = [AM2, PM2, AM2.toLowerCase(), PM2.toLowerCase()];
          if (this.$refs.timepicker) {
            dayPeriods.push(this.$refs.timepicker.amString);
            dayPeriods.push(this.$refs.timepicker.pmString);
          }
          const parts = this.dtf.formatToParts(new Date());
          const formatRegex = parts.map((part, idx) => {
            if (part.type === "literal") {
              if (idx + 1 < parts.length && parts[idx + 1].type === "hour") {
                return `[^\\d]+`;
              }
              return part.value.replace(/ /g, "\\s?");
            } else if (part.type === "dayPeriod") {
              return `((?!=<${part.type}>)(${dayPeriods.join("|")})?)`;
            }
            return `((?!=<${part.type}>)\\d+)`;
          }).join("");
          const datetimeGroups = matchWithGroups(formatRegex, date);
          if (datetimeGroups.year && datetimeGroups.year.length === 4 && datetimeGroups.month && datetimeGroups.month <= 12 && datetimeGroups.day && datetimeGroups.day <= 31 && datetimeGroups.hour && datetimeGroups.hour >= 0 && datetimeGroups.hour < 24 && datetimeGroups.minute && datetimeGroups.minute >= 0 && datetimeGroups.minute <= 59) {
            const d = new Date(datetimeGroups.year, datetimeGroups.month - 1, datetimeGroups.day, datetimeGroups.hour, datetimeGroups.minute, datetimeGroups.second || 0);
            return d;
          }
        }
        return new Date(Date.parse(date));
      }
    },
    defaultDatetimeFormatter(date) {
      const datetimeFormatter = getValueByPath(getOptions(), "datetimepicker.datetimeFormatter", void 0);
      if (typeof this.datetimeFormatter === "function") {
        return this.datetimeFormatter(date);
      } else if (typeof datetimeFormatter === "function") {
        return datetimeFormatter(date);
      } else {
        return this.dtf.format(date);
      }
    },
    onChangeNativePicker(event) {
      const date = event.target.value;
      const s = date ? date.split(/\D/) : [];
      if (s.length >= 5) {
        const year = parseInt(s[0], 10);
        const month = parseInt(s[1], 10) - 1;
        const day = parseInt(s[2], 10);
        const hours = parseInt(s[3], 10);
        const minutes = parseInt(s[4], 10);
        this.computedValue = new Date(year, month, day, hours, minutes);
      } else {
        this.computedValue = null;
      }
    },
    formatNative(value) {
      const date = new Date(value);
      if (value && !isNaN(date.getTime())) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        return year + "-" + ((month < 10 ? "0" : "") + month) + "-" + ((day < 10 ? "0" : "") + day) + "T" + ((hours < 10 ? "0" : "") + hours) + ":" + ((minutes < 10 ? "0" : "") + minutes) + ":" + ((seconds < 10 ? "0" : "") + seconds);
      }
      return "";
    },
    toggle() {
      this.$refs.datepicker.toggle();
    }
  },
  mounted() {
    if (!this.isMobile || this.inline) {
      if (this.newValue) {
        this.$refs.datepicker.$forceUpdate();
      }
    }
  }
});
function render13(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_timepicker = resolveComponent("o-timepicker");
  const _component_o_datepicker = resolveComponent("o-datepicker");
  const _component_o_input = resolveComponent("o-input");
  return !_ctx.isMobile || _ctx.inline ? createVNode(
    _component_o_datepicker,
    mergeProps({
      key: 0,
      ref: "datepicker",
      modelValue: _ctx.computedValue,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.computedValue = $event)
    }, _ctx.datepicker, {
      class: _ctx.datepickerWrapperClasses,
      rounded: _ctx.rounded,
      "open-on-focus": _ctx.openOnFocus,
      position: _ctx.position,
      inline: _ctx.inline,
      editable: _ctx.editable,
      expanded: _ctx.expanded,
      "close-on-click": false,
      "date-formatter": _ctx.defaultDatetimeFormatter,
      "date-parser": _ctx.defaultDatetimeParser,
      "min-date": _ctx.minDate,
      "max-date": _ctx.maxDate,
      icon: _ctx.icon,
      "icon-right": _ctx.iconRight,
      "icon-right-clickable": _ctx.iconRightClickable,
      "icon-pack": _ctx.iconPack,
      size: _ctx.datepickerSize,
      placeholder: _ctx.placeholder,
      range: false,
      disabled: _ctx.disabled,
      "mobile-native": _ctx.isMobileNative,
      locale: _ctx.locale,
      "append-to-body": _ctx.appendToBody,
      onFocus: _ctx.onFocus,
      onBlur: _ctx.onBlur,
      "onActive-change": _cache[3] || (_cache[3] = ($event) => _ctx.$emit("active-change", $event)),
      "onIcon-right-click": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("icon-right-click")),
      "onChange-month": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("change-month", $event)),
      "onChange-year": _cache[6] || (_cache[6] = ($event) => _ctx.$emit("change-year", $event))
    }),
    {
      footer: withCtx(() => [createVNode(
        "div",
        {
          class: _ctx.timepickerWrapperClasses
        },
        [createVNode(
          _component_o_timepicker,
          mergeProps({
            ref: "timepicker"
          }, _ctx.timepicker, {
            modelValue: _ctx.computedValue,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.computedValue = $event),
            inline: "",
            editable: _ctx.editable,
            "min-time": _ctx.minTime,
            "max-time": _ctx.maxTime,
            size: _ctx.timepickerSize,
            disabled: _ctx.timepickerDisabled,
            "mobile-native": _ctx.isMobileNative,
            locale: _ctx.locale
          }),
          null,
          16,
          ["modelValue", "editable", "min-time", "max-time", "size", "disabled", "mobile-native", "locale"]
        )],
        2
      ), _ctx.$slots.footer !== void 0 ? renderSlot(_ctx.$slots, "footer", {
        key: 0
      }) : createCommentVNode("v-if", true)]),
      _: 1
    },
    16,
    ["modelValue", "class", "rounded", "open-on-focus", "position", "inline", "editable", "expanded", "date-formatter", "date-parser", "min-date", "max-date", "icon", "icon-right", "icon-right-clickable", "icon-pack", "size", "placeholder", "disabled", "mobile-native", "locale", "append-to-body", "onFocus", "onBlur"]
  ) : createVNode(
    _component_o_input,
    mergeProps({
      key: 1,
      ref: "input",
      type: "datetime-local",
      autocomplete: "off",
      value: _ctx.formatNative(_ctx.computedValue),
      placeholder: _ctx.placeholder,
      size: _ctx.datepickerSize,
      icon: _ctx.icon,
      "icon-pack": _ctx.iconPack,
      rounded: _ctx.rounded,
      max: _ctx.formatNative(_ctx.maxDate),
      min: _ctx.formatNative(_ctx.minDate),
      disabled: _ctx.disabled,
      readonly: false
    }, _ctx.$attrs, {
      "use-html5-validation": _ctx.useHtml5Validation,
      onChange: _ctx.onChangeNativePicker,
      onFocus: _ctx.onFocus,
      onBlur: _ctx.onBlur
    }),
    null,
    16,
    ["value", "placeholder", "size", "icon", "icon-pack", "rounded", "max", "min", "disabled", "use-html5-validation", "onChange", "onFocus", "onBlur"]
  );
}
script13.render = render13;
script13.__file = "src/components/datetimepicker/Datetimepicker.vue";
var index7 = {
  install(app) {
    registerComponent(app, script13);
  }
};
var datetimepicker_default = index7;

// node_modules/@oruga-ui/oruga-next/dist/esm/dropdown.mjs
var index8 = {
  install(app) {
    registerComponent(app, script8);
    registerComponent(app, script$12);
  }
};
var dropdown_default = index8;

// node_modules/@oruga-ui/oruga-next/dist/esm/field.mjs
var index9 = {
  install(app) {
    registerComponent(app, script$13);
  }
};
var field_default = index9;

// node_modules/@oruga-ui/oruga-next/dist/esm/icon.mjs
var index10 = {
  install(app) {
    registerComponent(app, script);
  }
};
var icon_default = index10;

// node_modules/@oruga-ui/oruga-next/dist/esm/input.mjs
var index11 = {
  install(app) {
    registerComponent(app, script2);
  }
};
var input_default = index11;

// node_modules/@oruga-ui/oruga-next/dist/esm/inputitems.mjs
var script14 = defineComponent({
  name: "OInputitems",
  components: {
    [script3.name]: script3,
    [script.name]: script
  },
  mixins: [FormElementMixin, BaseComponentMixin],
  inheritAttrs: false,
  configField: "inputitems",
  emits: ["update:modelValue", "focus", "blur", "add", "remove", "typing", "infinite-scroll", "icon-right-click"],
  props: {
    modelValue: {
      type: Array,
      default: () => []
    },
    size: String,
    data: {
      type: Array,
      default: () => []
    },
    variant: String,
    maxitems: {
      type: [Number, String],
      required: false
    },
    hasCounter: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "inputitems.hasCounter", true);
      }
    },
    field: {
      type: String,
      default: "value"
    },
    autocomplete: Boolean,
    groupField: String,
    groupOptions: String,
    nativeAutocomplete: String,
    openOnFocus: Boolean,
    disabled: Boolean,
    closable: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "inputitems.closable", true);
      }
    },
    confirmKeys: {
      type: Array,
      default: () => {
        return getValueByPath(getOptions(), "inputitems.confirmKeys", [",", "Tab", "Enter"]);
      }
    },
    removeOnKeys: {
      type: Array,
      default: () => {
        return getValueByPath(getOptions(), "inputitems.removeOnKeys", ["Backspace"]);
      }
    },
    allowNew: Boolean,
    onPasteSeparators: {
      type: Array,
      default: () => {
        return getValueByPath(getOptions(), "inputitems.onPasteSeparators", [","]);
      }
    },
    beforeAdding: {
      type: Function,
      default: () => true
    },
    allowDuplicates: {
      type: Boolean,
      default: false
    },
    checkInfiniteScroll: {
      type: Boolean,
      default: false
    },
    createItem: {
      type: Function,
      default: (item) => item
    },
    closeIcon: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "inputitems.closeIcon", "close");
      }
    },
    keepFirst: Boolean,
    ariaCloseLabel: String,
    appendToBody: Boolean,
    rootClass: [String, Array, Function],
    expandedClass: [String, Array, Function],
    variantClass: [String, Array, Function],
    closeClass: [String, Array, Function],
    itemClass: [String, Array, Function],
    counterClass: [String, Array, Function],
    autocompleteClasses: {
      type: Object,
      default: () => {
        return getValueByPath(getOptions(), "inputitems.autocompleteClasses", {});
      }
    }
  },
  data() {
    return {
      items: Array.isArray(this.modelValue) ? this.modelValue.slice(0) : this.modelValue || [],
      newItem: "",
      isComposing: false
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-inputit"),
        { [this.computedClass("expandedClass", "o-inputit--expanded")]: this.expanded }
      ];
    },
    containerClasses() {
      return [
        this.computedClass("containerClass", "o-inputit__container"),
        { [this.computedClass("sizeClass", "o-inputit__container--", this.size)]: this.size }
      ];
    },
    itemClasses() {
      return [
        this.computedClass("itemClass", "o-inputit__item"),
        { [this.computedClass("variantClass", "o-inputit__item--", this.variant)]: this.variant }
      ];
    },
    closeClasses() {
      return [
        this.computedClass("closeClass", "o-inputit__item__close")
      ];
    },
    counterClasses() {
      return [
        this.computedClass("counterClass", "o-inputit__counter")
      ];
    },
    autocompleteBind() {
      return {
        ...this.$attrs,
        "root-class": this.computedClass("autocompleteClasses.rootClass", "o-inputit__autocomplete"),
        "input-classes": {
          "input-class": this.computedClass("autocompleteClasses.inputClasses.inputClass", "o-inputit__input")
        },
        ...this.autocompleteClasses
      };
    },
    valueLength() {
      return this.newItem.trim().length;
    },
    hasDefaultSlot() {
      return !!this.$slots.default;
    },
    hasEmptySlot() {
      return !!this.$slots.empty;
    },
    hasHeaderSlot() {
      return !!this.$slots.header;
    },
    hasFooterSlot() {
      return !!this.$slots.footer;
    },
    hasInput() {
      return this.maxitems == null || this.itemsLength < this.maxitems;
    },
    itemsLength() {
      return this.items.length;
    },
    separatorsAsRegExp() {
      const sep = this.onPasteSeparators;
      return sep.length ? new RegExp(sep.map((s) => {
        return s ? s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") : null;
      }).join("|"), "g") : null;
    },
    $elementRef() {
      return "autocomplete";
    }
  },
  watch: {
    modelValue(value) {
      this.items = Array.isArray(value) ? value.slice(0) : value || [];
    },
    hasInput() {
      if (!this.hasInput)
        this.onBlur();
    }
  },
  methods: {
    addItem(item) {
      const itemToAdd = item || this.newItem.trim();
      if (itemToAdd) {
        if (!this.autocomplete) {
          const reg = this.separatorsAsRegExp;
          if (reg && itemToAdd.match(reg)) {
            itemToAdd.split(reg).map((t) => t.trim()).filter((t) => t.length !== 0).map(this.addItem);
            return;
          }
        }
        const add = !this.allowDuplicates ? this.items.indexOf(this.createItem(itemToAdd)) === -1 : true;
        if (add && this.beforeAdding(itemToAdd)) {
          this.items.push(this.createItem(itemToAdd));
          this.$emit("update:modelValue", this.items);
          this.$emit("add", itemToAdd);
        }
      }
      requestAnimationFrame(() => {
        this.newItem = "";
        this.$emit("typing", "");
      });
    },
    getNormalizedItemText(item) {
      if (typeof item === "object") {
        item = getValueByPath(item, this.field);
      }
      return `${item}`;
    },
    customOnBlur(event) {
      if (!this.autocomplete)
        this.addItem();
      this.onBlur(event);
    },
    onSelect(option) {
      if (!option)
        return;
      this.addItem(option);
      this.$nextTick(() => {
        this.newItem = "";
      });
    },
    removeItem(index29, event) {
      const item = this.items.splice(index29, 1)[0];
      this.$emit("update:modelValue", this.items);
      this.$emit("remove", item);
      if (event)
        event.stopPropagation();
      if (this.openOnFocus && this.$refs.autocomplete) {
        this.$refs.autocomplete.focus();
      }
      return item;
    },
    removeLastItem() {
      if (this.itemsLength > 0) {
        this.removeItem(this.itemsLength - 1);
      }
    },
    keydown(event) {
      const { key } = event;
      if (this.removeOnKeys.indexOf(key) !== -1 && !this.newItem.length) {
        this.removeLastItem();
      }
      if (this.autocomplete && !this.allowNew)
        return;
      if (this.confirmKeys.indexOf(key) >= 0) {
        if (key !== "Tab")
          event.preventDefault();
        if (key === "Enter" && this.isComposing)
          return;
        this.addItem();
      }
    },
    onTyping(event) {
      this.$emit("typing", event.trim());
    }
  }
});
function render14(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");
  const _component_o_autocomplete = resolveComponent("o-autocomplete");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses
    },
    [createVNode(
      "div",
      {
        class: _ctx.containerClasses,
        onClick: _cache[6] || (_cache[6] = ($event) => _ctx.hasInput && _ctx.focus($event))
      },
      [renderSlot(_ctx.$slots, "selected", {
        items: _ctx.items
      }, () => [(openBlock(true), createBlock(
        Fragment,
        null,
        renderList(_ctx.items, (item, index29) => {
          return openBlock(), createBlock(
            "span",
            {
              key: _ctx.getNormalizedItemText(item) + index29,
              class: _ctx.itemClasses
            },
            [createVNode(
              "span",
              null,
              toDisplayString(_ctx.getNormalizedItemText(item)),
              1
            ), _ctx.closable ? createVNode(
              _component_o_icon,
              {
                key: 0,
                class: _ctx.closeClasses,
                clickable: "",
                both: "",
                icon: _ctx.closeIcon,
                onClick: ($event) => _ctx.removeItem(index29, $event),
                "aria-label": _ctx.ariaCloseLabel
              },
              null,
              8,
              ["class", "icon", "onClick", "aria-label"]
            ) : createCommentVNode("v-if", true)],
            2
          );
        }),
        128
      ))]), _ctx.hasInput ? createVNode(
        _component_o_autocomplete,
        mergeProps({
          key: 0,
          ref: "autocomplete",
          modelValue: _ctx.newItem,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.newItem = $event)
        }, _ctx.autocompleteBind, {
          data: _ctx.data,
          field: _ctx.field,
          icon: _ctx.icon,
          "icon-pack": _ctx.iconPack,
          maxlength: _ctx.maxlength,
          "has-counter": false,
          size: _ctx.size,
          disabled: _ctx.disabled,
          autocomplete: _ctx.nativeAutocomplete,
          "open-on-focus": _ctx.openOnFocus,
          "keep-first": _ctx.keepFirst,
          "keep-open": _ctx.openOnFocus,
          "group-field": _ctx.groupField,
          "group-options": _ctx.groupOptions,
          "use-html5-validation": _ctx.useHtml5Validation,
          "check-infinite-scroll": _ctx.checkInfiniteScroll,
          "append-to-body": _ctx.appendToBody,
          "confirm-keys": _ctx.confirmKeys,
          onTyping: _ctx.onTyping,
          onFocus: _ctx.onFocus,
          onBlur: _ctx.customOnBlur,
          onKeydown: _ctx.keydown,
          onCompositionstart: _cache[2] || (_cache[2] = ($event) => _ctx.isComposing = true),
          onCompositionend: _cache[3] || (_cache[3] = ($event) => _ctx.isComposing = false),
          onSelect: _ctx.onSelect,
          "onInfinite-scroll": _cache[4] || (_cache[4] = ($event) => _ctx.$emit("infinite-scroll", $event)),
          "onIcon-right-click": _cache[5] || (_cache[5] = ($event) => _ctx.$emit("icon-right-click", $event))
        }),
        createSlots({
          _: 2
        }, [_ctx.hasHeaderSlot ? {
          name: "header",
          fn: withCtx(() => [renderSlot(_ctx.$slots, "header")])
        } : void 0, _ctx.hasDefaultSlot ? {
          name: "default",
          fn: withCtx((props) => [renderSlot(_ctx.$slots, "default", {
            option: props.option,
            index: props.index
          })])
        } : void 0, _ctx.hasEmptySlot ? {
          name: "empty",
          fn: withCtx(() => [renderSlot(_ctx.$slots, "empty")])
        } : void 0, _ctx.hasFooterSlot ? {
          name: "footer",
          fn: withCtx(() => [renderSlot(_ctx.$slots, "footer")])
        } : void 0]),
        1040,
        ["modelValue", "data", "field", "icon", "icon-pack", "maxlength", "size", "disabled", "autocomplete", "open-on-focus", "keep-first", "keep-open", "group-field", "group-options", "use-html5-validation", "check-infinite-scroll", "append-to-body", "confirm-keys", "onTyping", "onFocus", "onBlur", "onKeydown", "onSelect"]
      ) : createCommentVNode("v-if", true)],
      2
    ), _ctx.hasCounter && (_ctx.maxitems || _ctx.maxlength) ? (openBlock(), createBlock(
      "small",
      {
        key: 0,
        class: _ctx.counterClasses
      },
      [_ctx.maxlength && _ctx.valueLength > 0 ? (openBlock(), createBlock(
        Fragment,
        {
          key: 0
        },
        [createTextVNode(
          toDisplayString(_ctx.valueLength) + " / " + toDisplayString(_ctx.maxlength),
          1
        )],
        64
      )) : _ctx.maxitems ? (openBlock(), createBlock(
        Fragment,
        {
          key: 1
        },
        [createTextVNode(
          toDisplayString(_ctx.itemsLength) + " / " + toDisplayString(_ctx.maxitems),
          1
        )],
        64
      )) : createCommentVNode("v-if", true)],
      2
    )) : createCommentVNode("v-if", true)],
    2
  );
}
script14.render = render14;
script14.__file = "src/components/inputitems/Inputitems.vue";
var index12 = {
  install(Vue) {
    registerComponent(Vue, script14);
  }
};
var inputitems_default = index12;

// node_modules/@oruga-ui/oruga-next/dist/esm/ssr-85c76d50.mjs
var isSSR = typeof window === "undefined";
var HTMLElement = isSSR ? Object : window.HTMLElement;
var File = isSSR ? Object : window.File;

// node_modules/@oruga-ui/oruga-next/dist/esm/Loading-a9c1b8b8.mjs
var script15 = defineComponent({
  name: "OLoading",
  components: {
    [script.name]: script
  },
  mixins: [BaseComponentMixin],
  configField: "loading",
  emits: ["update:active", "close", "update:full-page"],
  props: {
    active: Boolean,
    programmatic: [Boolean, Object],
    promise: Object,
    container: [Object, Function, HTMLElement],
    fullPage: {
      type: Boolean,
      default: true
    },
    animation: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "loading.animation", "fade");
      }
    },
    canCancel: {
      type: Boolean,
      default: false
    },
    onCancel: {
      type: Function,
      default: () => {
      }
    },
    icon: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "loading.icon", "loading");
      }
    },
    iconSpin: {
      type: Boolean,
      default: true
    },
    iconSize: {
      type: String,
      default: "medium"
    },
    rootClass: [String, Function, Array],
    overlayClass: [String, Function, Array],
    iconClass: [String, Function, Array],
    fullPageClass: [String, Function, Array]
  },
  data() {
    return {
      isActive: this.active || false,
      displayInFullPage: this.fullPage
    };
  },
  watch: {
    active(value) {
      this.isActive = value;
    },
    fullPage(value) {
      this.displayInFullPage = value;
    }
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-load"),
        { [this.computedClass("fullPageClass", "o-load--fullpage")]: this.displayInFullPage }
      ];
    },
    overlayClasses() {
      return [
        this.computedClass("overlayClass", "o-load__overlay")
      ];
    },
    iconClasses() {
      return [
        this.computedClass("iconClass", "o-load__icon")
      ];
    }
  },
  methods: {
    cancel(method) {
      if (!this.canCancel || !this.isActive)
        return;
      this.close({ action: "cancel", method });
    },
    close() {
      this.onCancel.apply(null, arguments);
      this.$emit("close");
      this.$emit("update:active", false);
      if (this.programmatic) {
        if (this.programmatic.resolve) {
          this.programmatic.resolve.apply(null, arguments);
        }
        this.isActive = false;
        window.requestAnimationFrame(() => {
          removeElement(this.$el);
        });
      }
    },
    keyPress({ key }) {
      if (key === "Escape" || key === "Esc")
        this.cancel("escape");
    }
  },
  created() {
    if (typeof window !== "undefined") {
      document.addEventListener("keyup", this.keyPress);
    }
  },
  mounted() {
    if (this.programmatic) {
      if (!this.container) {
        document.body.appendChild(this.$el);
      } else {
        this.displayInFullPage = false;
        this.$emit("update:full-page", false);
        this.container.appendChild(this.$el);
      }
      this.isActive = true;
    }
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      document.removeEventListener("keyup", this.keyPress);
    }
  }
});
function render15(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");
  return openBlock(), createBlock(
    Transition,
    {
      name: _ctx.animation
    },
    {
      default: withCtx(() => [_ctx.isActive ? (openBlock(), createBlock(
        "div",
        {
          key: 0,
          class: _ctx.rootClasses
        },
        [createVNode(
          "div",
          {
            class: _ctx.overlayClasses,
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.cancel("outside"))
          },
          null,
          2
        ), renderSlot(_ctx.$slots, "default", {}, () => [createVNode(
          _component_o_icon,
          {
            icon: _ctx.icon,
            spin: _ctx.iconSpin,
            size: _ctx.iconSize,
            class: _ctx.iconClasses,
            both: ""
          },
          null,
          8,
          ["icon", "spin", "size", "class"]
        )])],
        2
      )) : createCommentVNode("v-if", true)]),
      _: 1
    },
    8,
    ["name"]
  );
}
script15.render = render15;
script15.__file = "src/components/loading/Loading.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/loading.mjs
var localVueInstance;
var LoadingProgrammatic = {
  open(params) {
    const defaultParam = {
      programmatic: true
    };
    const propsData = merge(defaultParam, params);
    let resolve, reject;
    propsData.promise = new Promise((p1, p2) => {
      resolve = p1;
      reject = p2;
    });
    propsData.programmatic = { resolve, reject };
    const app = localVueInstance || VueInstance;
    const vnode = createVNode(script15, propsData);
    vnode.appContext = app._context;
    render(vnode, document.createElement("div"));
    return vnode.component.proxy;
  }
};
var index13 = {
  install(app) {
    localVueInstance = app;
    registerComponent(app, script15);
    registerComponentProgrammatic(app, "loading", LoadingProgrammatic);
  }
};
var loading_default = index13;

// node_modules/@oruga-ui/oruga-next/dist/esm/modal.mjs
var script16 = defineComponent({
  name: "OModal",
  components: {
    [script.name]: script
  },
  configField: "modal",
  directives: {
    trapFocus: directive
  },
  mixins: [BaseComponentMixin, MatchMediaMixin],
  emits: ["update:active", "close"],
  props: {
    active: Boolean,
    component: [Object, Function],
    content: String,
    programmatic: [Boolean, Object],
    promise: Object,
    props: Object,
    events: Object,
    width: {
      type: [String, Number],
      default: () => {
        return getValueByPath(getOptions(), "modal.width", 960);
      }
    },
    custom: Boolean,
    animation: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "modal.animation", "zoom-out");
      }
    },
    canCancel: {
      type: [Array, Boolean],
      default: () => {
        return getValueByPath(getOptions(), "modal.canCancel", ["escape", "x", "outside", "button"]);
      }
    },
    onCancel: {
      type: Function,
      default: () => {
      }
    },
    onClose: {
      type: Function,
      default: () => {
      }
    },
    scroll: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "modal.scroll", "keep");
      }
    },
    fullScreen: Boolean,
    trapFocus: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "modal.trapFocus", true);
      }
    },
    ariaRole: {
      type: String,
      validator: (value) => {
        return ["dialog", "alertdialog"].indexOf(value) >= 0;
      }
    },
    ariaModal: Boolean,
    ariaLabel: String,
    destroyOnHide: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "modal.destroyOnHide", true);
      }
    },
    autoFocus: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "modal.autoFocus", true);
      }
    },
    closeIcon: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "modal.closeIcon", "close");
      }
    },
    closeIconSize: {
      type: String,
      default: "medium"
    },
    rootClass: [String, Function, Array],
    overlayClass: [String, Function, Array],
    contentClass: [String, Function, Array],
    closeClass: [String, Function, Array],
    fullScreenClass: [String, Function, Array],
    mobileClass: [String, Function, Array]
  },
  data() {
    return {
      isActive: this.active || false,
      savedScrollTop: null,
      newWidth: toCssDimension(this.width),
      animating: !this.active,
      destroyed: !this.active
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-modal"),
        { [this.computedClass("mobileClass", "o-modal--mobile")]: this.isMatchMedia }
      ];
    },
    overlayClasses() {
      return [
        this.computedClass("overlayClass", "o-modal__overlay")
      ];
    },
    contentClasses() {
      return [
        { [this.computedClass("contentClass", "o-modal__content")]: !this.custom },
        { [this.computedClass("fullScreenClass", "o-modal__content--full-screen")]: this.fullScreen }
      ];
    },
    closeClasses() {
      return [
        this.computedClass("closeClass", "o-modal__close")
      ];
    },
    cancelOptions() {
      return typeof this.canCancel === "boolean" ? this.canCancel ? getValueByPath(getOptions(), "modal.canCancel", ["escape", "x", "outside", "button"]) : [] : this.canCancel;
    },
    showX() {
      return this.cancelOptions.indexOf("x") >= 0;
    },
    customStyle() {
      if (!this.fullScreen) {
        return { maxWidth: this.newWidth };
      }
      return null;
    }
  },
  watch: {
    active(value) {
      this.isActive = value;
    },
    isActive(value) {
      if (value)
        this.destroyed = false;
      this.handleScroll();
      this.$nextTick(() => {
        if (value && this.$el && this.$el.focus && this.autoFocus) {
          this.$el.focus();
        }
      });
    }
  },
  methods: {
    handleScroll() {
      if (typeof window === "undefined")
        return;
      if (this.scroll === "clip") {
        if (this.isActive) {
          document.documentElement.classList.add("o-clipped");
        } else {
          document.documentElement.classList.remove("o-clipped");
        }
        return;
      }
      this.savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;
      if (this.isActive) {
        document.body.classList.add("o-noscroll");
      } else {
        document.body.classList.remove("o-noscroll");
      }
      if (this.isActive) {
        document.body.style.top = `-${this.savedScrollTop}px`;
        return;
      }
      document.documentElement.scrollTop = this.savedScrollTop;
      document.body.style.top = null;
      this.savedScrollTop = null;
    },
    cancel(method) {
      if (this.cancelOptions.indexOf(method) < 0)
        return;
      this.onCancel.apply(null, arguments);
      this.close({ action: "cancel", method });
    },
    close() {
      this.isActive = false;
      if (this.destroyOnHide) {
        this.destroyed = true;
      }
      this.$emit("close");
      this.$emit("update:active", false);
      this.onClose.apply(null, arguments);
      if (this.programmatic) {
        if (this.programmatic.resolve) {
          this.programmatic.resolve.apply(null, arguments);
        }
        window.requestAnimationFrame(() => {
          removeElement(this.$el);
        });
      }
    },
    keyPress({ key }) {
      if (this.isActive && (key === "Escape" || key === "Esc"))
        this.cancel("escape");
    },
    afterEnter() {
      this.animating = false;
    },
    beforeLeave() {
      this.animating = true;
    }
  },
  created() {
    if (typeof window !== "undefined") {
      document.addEventListener("keyup", this.keyPress);
    }
  },
  mounted() {
    if (this.programmatic) {
      document.body.appendChild(this.$el);
      this.isActive = true;
    } else if (this.isActive)
      this.handleScroll();
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      document.removeEventListener("keyup", this.keyPress);
      document.documentElement.classList.remove("o-clipped");
      const savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;
      document.body.classList.remove("o-noscroll");
      document.documentElement.scrollTop = savedScrollTop;
      document.body.style.top = null;
    }
  }
});
var _hoisted_14 = {
  key: 1
};
function render16(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");
  const _directive_trap_focus = resolveDirective("trap-focus");
  return openBlock(), createBlock(
    Transition,
    {
      name: _ctx.animation,
      "onAfter-enter": _ctx.afterEnter,
      "onBefore-leave": _ctx.beforeLeave
    },
    {
      default: withCtx(() => [!_ctx.destroyed ? withDirectives((openBlock(), createBlock(
        "div",
        {
          key: 0,
          class: _ctx.rootClasses,
          tabindex: "-1",
          role: _ctx.ariaRole,
          "aria-label": _ctx.ariaLabel,
          "aria-modal": _ctx.ariaModal
        },
        [createVNode(
          "div",
          {
            class: _ctx.overlayClasses,
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.cancel("outside"))
          },
          null,
          2
        ), createVNode(
          "div",
          {
            class: _ctx.contentClasses,
            style: _ctx.customStyle
          },
          [_ctx.component ? (openBlock(), createBlock(
            resolveDynamicComponent(_ctx.component),
            mergeProps({
              key: 0
            }, _ctx.props, toHandlers(_ctx.events || {}), {
              onClose: _ctx.close
            }),
            null,
            16,
            ["onClose"]
          )) : _ctx.content ? (openBlock(), createBlock(
            "div",
            _hoisted_14,
            toDisplayString(_ctx.content),
            1
          )) : renderSlot(_ctx.$slots, "default", {
            key: 2
          }), _ctx.showX ? withDirectives(createVNode(
            _component_o_icon,
            {
              key: 3,
              clickable: "",
              both: "",
              class: _ctx.closeClasses,
              icon: _ctx.closeIcon,
              size: _ctx.closeIconSize,
              onClick: _cache[2] || (_cache[2] = ($event) => _ctx.cancel("x"))
            },
            null,
            8,
            ["class", "icon", "size"]
          ), [[vShow, !_ctx.animating]]) : createCommentVNode("v-if", true)],
          6
        )],
        10,
        ["role", "aria-label", "aria-modal"]
      )), [[vShow, _ctx.isActive], [_directive_trap_focus, _ctx.trapFocus]]) : createCommentVNode("v-if", true)]),
      _: 1
    },
    8,
    ["name", "onAfter-enter", "onBefore-leave"]
  );
}
script16.render = render16;
script16.__file = "src/components/modal/Modal.vue";
var localVueInstance2;
var ModalProgrammatic = {
  open(params) {
    let newParams;
    if (typeof params === "string") {
      newParams = {
        content: params
      };
    } else {
      newParams = params;
    }
    const defaultParam = {
      programmatic: true
    };
    let slot;
    if (Array.isArray(newParams.content)) {
      slot = newParams.content;
      delete newParams.content;
    }
    const propsData = merge(defaultParam, newParams);
    let resolve, reject;
    propsData.promise = new Promise((p1, p2) => {
      resolve = p1;
      reject = p2;
    });
    propsData.programmatic = { resolve, reject };
    const app = localVueInstance2 || VueInstance;
    const vnode = createVNode(script16, propsData);
    vnode.appContext = app._context;
    render(vnode, document.createElement("div"));
    return vnode.component.proxy;
  }
};
var index14 = {
  install(app) {
    localVueInstance2 = app;
    registerComponent(app, script16);
    registerComponentProgrammatic(app, "modal", ModalProgrammatic);
  }
};
var modal_default = index14;

// node_modules/@oruga-ui/oruga-next/dist/esm/notification.mjs
var MessageMixin = {
  components: {
    [script.name]: script
  },
  props: {
    active: {
      type: Boolean,
      default: true
    },
    closable: {
      type: Boolean,
      default: false
    },
    message: String,
    type: String,
    hasIcon: Boolean,
    icon: String,
    iconPack: String,
    iconSize: {
      type: String,
      default: "large"
    },
    autoClose: {
      type: Boolean,
      default: false
    },
    duration: {
      type: Number,
      default: 2e3
    }
  },
  data() {
    return {
      isActive: this.active
    };
  },
  watch: {
    active(value) {
      this.isActive = value;
    },
    isActive(value) {
      if (value) {
        this.setAutoClose();
      } else {
        if (this.timer) {
          clearTimeout(this.timer);
        }
      }
    }
  },
  computed: {
    computedIcon() {
      if (this.icon) {
        return this.icon;
      }
      switch (this.type) {
        case "info":
          return "information";
        case "success":
          return "check-circle";
        case "warning":
          return "alert";
        case "danger":
          return "alert-circle";
        default:
          return null;
      }
    }
  },
  methods: {
    close() {
      this.isActive = false;
      this.$emit("close", ...arguments);
      this.$emit("update:active", false);
    },
    setAutoClose() {
      if (this.autoClose) {
        this.timer = setTimeout(() => {
          if (this.isActive) {
            this.close({ action: "close", method: "timeout" });
          }
        }, this.duration);
      }
    }
  },
  mounted() {
    this.setAutoClose();
  }
};
var script17 = {
  name: "ONotification",
  configField: "notification",
  mixins: [BaseComponentMixin, MessageMixin],
  emits: ["update:active", "close"],
  props: {
    position: String,
    variant: [String, Object],
    ariaCloseLabel: String,
    closeIconSize: {
      type: String,
      default: "small"
    },
    animation: {
      type: String,
      default: "fade"
    },
    component: [Object, Function],
    props: Object,
    events: {
      type: Object,
      default: {}
    },
    closeIcon: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "notification.closeIcon", "close");
      }
    },
    rootClass: [String, Function, Array],
    closeClass: [String, Function, Array],
    contentClass: [String, Function, Array],
    iconClass: [String, Function, Array],
    positionClass: [String, Function, Array],
    variantClass: [String, Function, Array],
    wrapperClass: [String, Function, Array]
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-notification"),
        { [this.computedClass("variantClass", "o-notification--", this.variant)]: this.variant },
        { [this.computedClass("positionClass", "o-notification--", this.position)]: this.position }
      ];
    },
    wrapperClasses() {
      return [
        this.computedClass("wrapperClass", "o-notification__wrapper")
      ];
    },
    iconClasses() {
      return [
        this.computedClass("iconClass", "o-notification__icon")
      ];
    },
    contentClasses() {
      return [
        this.computedClass("contentClass", "o-notification__content")
      ];
    },
    closeClasses() {
      return [
        this.computedClass("closeClass", "o-notification__close")
      ];
    }
  }
};
function render17(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");
  return openBlock(), createBlock(
    Transition,
    {
      name: $props.animation
    },
    {
      default: withCtx(() => [withDirectives(createVNode(
        "article",
        {
          class: $options.rootClasses
        },
        [_ctx.closable ? (openBlock(), createBlock(
          "button",
          {
            key: 0,
            class: $options.closeClasses,
            type: "button",
            onClick: _cache[1] || (_cache[1] = ($event) => _ctx.close({
              action: "close",
              method: "x"
            })),
            "aria-label": $props.ariaCloseLabel
          },
          [createVNode(
            _component_o_icon,
            {
              clickable: "",
              pack: _ctx.iconPack,
              both: "",
              icon: $props.closeIcon,
              size: $props.closeIconSize
            },
            null,
            8,
            ["pack", "icon", "size"]
          )],
          10,
          ["aria-label"]
        )) : createCommentVNode("v-if", true), $props.component ? (openBlock(), createBlock(
          resolveDynamicComponent($props.component),
          mergeProps({
            key: 1
          }, $props.props, toHandlers($props.events), {
            onClose: _ctx.close
          }),
          null,
          16,
          ["onClose"]
        )) : createCommentVNode("v-if", true), _ctx.$slots.default || _ctx.message ? (openBlock(), createBlock(
          "div",
          {
            key: 2,
            class: $options.wrapperClasses
          },
          [_ctx.computedIcon ? createVNode(
            _component_o_icon,
            {
              key: 0,
              icon: _ctx.computedIcon,
              pack: _ctx.iconPack,
              class: $options.iconClasses,
              both: "",
              size: _ctx.iconSize,
              "aria-hidden": ""
            },
            null,
            8,
            ["icon", "pack", "class", "size"]
          ) : createCommentVNode("v-if", true), createVNode(
            "div",
            {
              class: $options.contentClasses
            },
            [_ctx.message ? (openBlock(), createBlock(
              "span",
              {
                key: 0,
                innerHTML: _ctx.message
              },
              null,
              8,
              ["innerHTML"]
            )) : renderSlot(_ctx.$slots, "default", {
              key: 1,
              closeNotification: _ctx.close
            })],
            2
          )],
          2
        )) : createCommentVNode("v-if", true)],
        2
      ), [[vShow, _ctx.isActive]])]),
      _: 1
    },
    8,
    ["name"]
  );
}
script17.render = render17;
script17.__file = "src/components/notification/Notification.vue";
var NoticeMixin = {
  props: {
    type: {
      type: String
    },
    message: [String, Array],
    duration: {
      type: Number,
      default: () => {
        return getValueByPath(getOptions(), "notification.duration", 1e3);
      }
    },
    queue: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "notification.noticeQueue", void 0);
      }
    },
    indefinite: {
      type: Boolean,
      default: false
    },
    position: {
      type: String,
      default: "top",
      validator(value) {
        return [
          "top-right",
          "top",
          "top-left",
          "bottom-right",
          "bottom",
          "bottom-left"
        ].indexOf(value) > -1;
      }
    },
    container: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "notification.containerElement", void 0);
      }
    },
    programmatic: [Boolean, Object],
    promise: Object,
    onClose: {
      type: Function,
      default: () => {
      }
    }
  },
  data() {
    return {
      isActive: false,
      parentTop: null,
      parentBottom: null,
      newDuration: this.duration,
      newContainer: this.container
    };
  },
  computed: {
    correctParent() {
      switch (this.position) {
        case "top-right":
        case "top":
        case "top-left":
          return this.parentTop;
        case "bottom-right":
        case "bottom":
        case "bottom-left":
          return this.parentBottom;
      }
    },
    transition() {
      switch (this.position) {
        case "top-right":
        case "top":
        case "top-left":
          return {
            enter: "fadeInDown",
            leave: "fadeOut"
          };
        case "bottom-right":
        case "bottom":
        case "bottom-left":
          return {
            enter: "fadeInUp",
            leave: "fadeOut"
          };
      }
    }
  },
  methods: {
    shouldQueue() {
      if (!this.queue)
        return false;
      return this.parentTop.childElementCount > 0 || this.parentBottom.childElementCount > 0;
    },
    close() {
      clearTimeout(this.timer);
      this.$emit("close");
      this.onClose.apply(null, arguments);
      if (this.programmatic && this.programmatic.resolve) {
        this.programmatic.resolve.apply(null, arguments);
      }
      setTimeout(() => {
        this.isActive = false;
        removeElement(this.$el);
      }, 150);
    },
    showNotice() {
      if (this.shouldQueue())
        this.correctParent.innerHTML = "";
      this.correctParent.insertAdjacentElement("afterbegin", this.$el);
      this.isActive = true;
      if (!this.indefinite) {
        this.timer = setTimeout(() => this.timeoutCallback(), this.newDuration);
      }
    },
    setupContainer() {
      this.parentTop = document.querySelector((this.newContainer ? this.newContainer : "body") + `>.${this.rootClasses().join(".")}.${this.positionClasses("top").join(".")}`);
      this.parentBottom = document.querySelector((this.newContainer ? this.newContainer : "body") + `>.${this.rootClasses().join(".")}.${this.positionClasses("bottom").join(".")}`);
      if (this.parentTop && this.parentBottom)
        return;
      if (!this.parentTop) {
        this.parentTop = document.createElement("div");
        this.parentTop.className = `${this.rootClasses().join(" ")} ${this.positionClasses("top").join(" ")}`;
      }
      if (!this.parentBottom) {
        this.parentBottom = document.createElement("div");
        this.parentBottom.className = `${this.rootClasses().join(" ")} ${this.positionClasses("bottom").join(" ")}`;
      }
      const container = document.querySelector(this.newContainer) || document.body;
      container.appendChild(this.parentTop);
      container.appendChild(this.parentBottom);
      if (this.newContainer) {
        this.parentTop.classList.add("has-custom-container");
        this.parentBottom.classList.add("has-custom-container");
      }
    },
    timeoutCallback() {
      return this.close({ action: "close", method: "timeout" });
    }
  },
  beforeMount() {
    this.setupContainer();
  },
  mounted() {
    this.showNotice();
  }
};
var script$15 = defineComponent({
  name: "ONotificationNotice",
  configField: "notification",
  mixins: [BaseComponentMixin, NoticeMixin],
  props: {
    propsNotification: Object,
    noticeClass: [String, Function, Array],
    noticePositionClass: [String, Function, Array]
  },
  emits: ["update:active", "close"],
  methods: {
    rootClasses() {
      return [
        this.computedClass("noticeClass", "o-notices")
      ];
    },
    positionClasses(position) {
      return [
        this.computedClass("noticePositionClass", "o-notices--", position)
      ];
    },
    timeoutCallback() {
      return this.$refs.notification.close({ action: "close", method: "timeout" });
    }
  }
});
function render$14(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_notification = resolveComponent("o-notification");
  return openBlock(), createBlock(
    _component_o_notification,
    mergeProps(_ctx.propsNotification, {
      ref: "notification",
      onClose: _ctx.close
    }),
    {
      default: withCtx(() => [renderSlot(_ctx.$slots, "default")]),
      _: 3
    },
    16,
    ["onClose"]
  );
}
script$15.render = render$14;
script$15.__file = "src/components/notification/NotificationNotice.vue";
var localVueInstance3;
var NotificationProgrammatic = {
  open(params) {
    let newParams;
    if (typeof params === "string") {
      newParams = {
        message: params
      };
    } else {
      newParams = params;
    }
    const defaultParam = {
      programmatic: true,
      position: getValueByPath(getOptions(), "notification.position", "top-right"),
      closable: params.closable || getValueByPath(getOptions(), "notification.closable", false)
    };
    let slot;
    if (Array.isArray(newParams.message)) {
      slot = newParams.message;
      delete newParams.message;
    }
    newParams.active = true;
    const propsData = merge(defaultParam, newParams);
    let resolve, reject;
    propsData.promise = new Promise((p1, p2) => {
      resolve = p1;
      reject = p2;
    });
    propsData.programmatic = { resolve, reject };
    const app = localVueInstance3 || VueInstance;
    propsData.propsNotification = Object.assign({}, propsData);
    propsData.propsNotification.isActive = true;
    const defaultSlot = () => {
      return newParams.message;
    };
    const vnode = createVNode(script$15, propsData, defaultSlot);
    vnode.appContext = app._context;
    render(vnode, document.createElement("div"));
    return vnode.component.proxy;
  }
};
var index15 = {
  install(app) {
    localVueInstance3 = app;
    registerComponent(app, script17);
    registerComponentProgrammatic(app, "notification", NotificationProgrammatic);
  }
};
var notification_default = index15;

// node_modules/@oruga-ui/oruga-next/dist/esm/Pagination-5bfe8f1b.mjs
var script18 = defineComponent({
  name: "OPaginationButton",
  inject: ["$pagination"],
  configField: "pagination",
  props: {
    page: {
      type: Object,
      required: true
    },
    tag: {
      type: String,
      default: "a",
      validator: (value) => getValueByPath(getOptions(), "linkTags", ["a", "button", "input", "router-link", "nuxt-link"]).indexOf(value) >= 0
    },
    disabled: {
      type: Boolean,
      default: false
    },
    linkClass: [String, Array, Object],
    linkCurrentClass: [String, Array, Object]
  },
  computed: {
    linkClasses() {
      return [
        this.linkClass || [...this.$pagination.linkClasses],
        this.page.class,
        { [this.linkCurrentClass || this.$pagination.linkCurrentClasses]: this.page.isCurrent }
      ];
    },
    href() {
      if (this.tag === "a") {
        return "#";
      }
      return "";
    },
    isDisabled() {
      if (this.tag === "a")
        return null;
      return this.disabled || this.page.disabled;
    }
  }
});
function render18(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    resolveDynamicComponent(_ctx.tag),
    mergeProps({
      role: "button",
      href: _ctx.href,
      disabled: _ctx.isDisabled,
      class: _ctx.linkClasses
    }, _ctx.$attrs, {
      onClick: withModifiers(_ctx.page.click, ["prevent"]),
      "aria-label": _ctx.page["aria-label"],
      "aria-current": _ctx.page.isCurrent
    }),
    {
      default: withCtx(() => [renderSlot(_ctx.$slots, "default", {}, () => [createTextVNode(
        toDisplayString(_ctx.page.number),
        1
      )])]),
      _: 3
    },
    16,
    ["href", "disabled", "class", "onClick", "aria-label", "aria-current"]
  );
}
script18.render = render18;
script18.__file = "src/components/pagination/PaginationButton.vue";
var script$16 = defineComponent({
  name: "OPagination",
  components: {
    [script.name]: script,
    [script18.name]: script18
  },
  configField: "pagination",
  mixins: [BaseComponentMixin, MatchMediaMixin],
  provide() {
    return {
      $pagination: this
    };
  },
  emits: ["update:active", "change", "update:current"],
  props: {
    total: [Number, String],
    perPage: {
      type: [Number, String],
      default: () => {
        return getValueByPath(getOptions(), "pagination.perPage", 20);
      }
    },
    current: {
      type: [Number, String],
      default: 1
    },
    rangeBefore: {
      type: [Number, String],
      default: 1
    },
    rangeAfter: {
      type: [Number, String],
      default: 1
    },
    size: String,
    simple: Boolean,
    rounded: Boolean,
    order: String,
    iconPack: String,
    iconPrev: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "pagination.iconPrev", "chevron-left");
      }
    },
    iconNext: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "pagination.iconNext", "chevron-right");
      }
    },
    ariaNextLabel: String,
    ariaPreviousLabel: String,
    ariaPageLabel: String,
    ariaCurrentLabel: String,
    rootClass: [String, Function, Array],
    prevBtnClass: [String, Function, Array],
    nextBtnClass: [String, Function, Array],
    listClass: [String, Function, Array],
    linkClass: [String, Function, Array],
    linkCurrentClass: [String, Function, Array],
    ellipsisClass: [String, Function, Array],
    infoClass: [String, Function, Array],
    orderClass: [String, Function, Array],
    simpleClass: [String, Function, Array],
    roundedClass: [String, Function, Array],
    linkDisabledClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    mobileClass: [String, Function, Array]
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-pag"),
        { [this.computedClass("orderClass", "o-pag--", this.order)]: this.order },
        { [this.computedClass("sizeClass", "o-pag--", this.size)]: this.size },
        { [this.computedClass("simpleClass", "o-pag--simple")]: this.simple },
        { [this.computedClass("mobileClass", "o-pag--mobile")]: this.isMatchMedia }
      ];
    },
    prevBtnClasses() {
      return [
        this.computedClass("prevBtnClass", "o-pag__previous"),
        { [this.computedClass("linkDisabledClass", "o-pag__link--disabled")]: !this.hasPrev }
      ];
    },
    nextBtnClasses() {
      return [
        this.computedClass("nextBtnClass", "o-pag__next"),
        { [this.computedClass("linkDisabledClass", "o-pag__link--disabled")]: !this.hasNext }
      ];
    },
    infoClasses() {
      return [
        this.computedClass("infoClass", "o-pag__info")
      ];
    },
    ellipsisClasses() {
      return [
        this.computedClass("ellipsisClass", "o-pag__ellipsis")
      ];
    },
    listClasses() {
      return [
        this.computedClass("listClass", "o-pag__list")
      ];
    },
    linkClasses() {
      return [
        this.computedClass("linkClass", "o-pag__link"),
        { [this.computedClass("roundedClass", "o-pag__link--rounded")]: this.rounded }
      ];
    },
    linkCurrentClasses() {
      return [
        this.computedClass("linkCurrentClass", "o-pag__link--current")
      ];
    },
    beforeCurrent() {
      return parseInt(this.rangeBefore);
    },
    afterCurrent() {
      return parseInt(this.rangeAfter);
    },
    pageCount() {
      return Math.ceil(this.total / this.perPage);
    },
    firstItem() {
      const firstItem = this.current * this.perPage - this.perPage + 1;
      return firstItem >= 0 ? firstItem : 0;
    },
    hasPrev() {
      return this.current > 1;
    },
    hasFirst() {
      return this.current >= 2 + this.beforeCurrent;
    },
    hasFirstEllipsis() {
      return this.current >= this.beforeCurrent + 4;
    },
    hasLast() {
      return this.current <= this.pageCount - (1 + this.afterCurrent);
    },
    hasLastEllipsis() {
      return this.current < this.pageCount - (2 + this.afterCurrent);
    },
    hasNext() {
      return this.current < this.pageCount;
    },
    pagesInRange() {
      if (this.simple)
        return;
      let left = Math.max(1, this.current - this.beforeCurrent);
      if (left - 1 === 2) {
        left--;
      }
      let right = Math.min(this.current + this.afterCurrent, this.pageCount);
      if (this.pageCount - right === 2) {
        right++;
      }
      const pages = [];
      for (let i = left; i <= right; i++) {
        pages.push(this.getPage(i));
      }
      return pages;
    },
    hasDefaultSlot() {
      return this.$slots.default;
    },
    hasPreviousSlot() {
      return this.$slots.previous;
    },
    hasNextSlot() {
      return this.$slots.next;
    }
  },
  watch: {
    pageCount(value) {
      if (this.current > value)
        this.last();
    }
  },
  methods: {
    prev(event) {
      this.changePage(this.current - 1, event);
    },
    next(event) {
      this.changePage(this.current + 1, event);
    },
    first(event) {
      this.changePage(1, event);
    },
    last(event) {
      this.changePage(this.pageCount, event);
    },
    changePage(num, event) {
      if (this.current === num || num < 1 || num > this.pageCount)
        return;
      this.$emit("change", num);
      this.$emit("update:current", num);
      if (event && event.target) {
        this.$nextTick(() => event.target.focus());
      }
    },
    getPage(num, options = {}) {
      return {
        number: num,
        isCurrent: this.current === num,
        click: (event) => this.changePage(num, event),
        disabled: options.disabled || false,
        class: options.class || "",
        "aria-label": options["aria-label"] || this.getAriaPageLabel(num, this.current === num)
      };
    },
    getAriaPageLabel(pageNumber, isCurrent) {
      if (this.ariaPageLabel && (!isCurrent || !this.ariaCurrentLabel)) {
        return this.ariaPageLabel + " " + pageNumber + ".";
      } else if (this.ariaPageLabel && isCurrent && this.ariaCurrentLabel) {
        return this.ariaCurrentLabel + ", " + this.ariaPageLabel + " " + pageNumber + ".";
      }
      return null;
    }
  }
});
var _hoisted_15 = {
  key: 0
};
var _hoisted_22 = {
  key: 1
};
var _hoisted_3 = {
  key: 2
};
var _hoisted_4 = {
  key: 3
};
function render$15(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");
  const _component_o_pagination_button = resolveComponent("o-pagination-button");
  return openBlock(), createBlock(
    "nav",
    {
      class: _ctx.rootClasses
    },
    [_ctx.hasPreviousSlot ? renderSlot(_ctx.$slots, "previous", {
      key: 0,
      linkClass: _ctx.linkClasses,
      linkCurrentClass: _ctx.linkCurrentClasses,
      page: _ctx.getPage(_ctx.current - 1, {
        class: _ctx.prevBtnClasses,
        "aria-label": _ctx.ariaPreviousLabel
      })
    }, () => [createVNode(
      _component_o_icon,
      {
        icon: _ctx.iconPrev,
        pack: _ctx.iconPack,
        both: "",
        "aria-hidden": "true"
      },
      null,
      8,
      ["icon", "pack"]
    )]) : createVNode(
      _component_o_pagination_button,
      {
        key: 1,
        class: _ctx.prevBtnClasses,
        linkClass: _ctx.linkClasses,
        linkCurrentClass: _ctx.linkCurrentClasses,
        page: _ctx.getPage(_ctx.current - 1)
      },
      {
        default: withCtx(() => [createVNode(
          _component_o_icon,
          {
            icon: _ctx.iconPrev,
            pack: _ctx.iconPack,
            both: "",
            "aria-hidden": "true"
          },
          null,
          8,
          ["icon", "pack"]
        )]),
        _: 1
      },
      8,
      ["class", "linkClass", "linkCurrentClass", "page"]
    ), _ctx.hasNextSlot ? renderSlot(_ctx.$slots, "next", {
      key: 2,
      linkClass: _ctx.linkClasses,
      linkCurrentClass: _ctx.linkCurrentClasses,
      page: _ctx.getPage(_ctx.current + 1, {
        class: _ctx.nextBtnClasses,
        "aria-label": _ctx.ariaNextLabel
      })
    }, () => [createVNode(
      _component_o_icon,
      {
        icon: _ctx.iconNext,
        pack: _ctx.iconPack,
        both: "",
        "aria-hidden": "true"
      },
      null,
      8,
      ["icon", "pack"]
    )]) : createVNode(
      _component_o_pagination_button,
      {
        key: 3,
        class: _ctx.nextBtnClasses,
        linkClass: _ctx.linkClasses,
        linkCurrentClass: _ctx.linkCurrentClasses,
        page: _ctx.getPage(_ctx.current + 1)
      },
      {
        default: withCtx(() => [createVNode(
          _component_o_icon,
          {
            icon: _ctx.iconNext,
            pack: _ctx.iconPack,
            both: "",
            "aria-hidden": "true"
          },
          null,
          8,
          ["icon", "pack"]
        )]),
        _: 1
      },
      8,
      ["class", "linkClass", "linkCurrentClass", "page"]
    ), _ctx.simple ? (openBlock(), createBlock(
      "small",
      {
        key: 4,
        class: _ctx.infoClasses
      },
      [_ctx.perPage == 1 ? (openBlock(), createBlock(
        Fragment,
        {
          key: 0
        },
        [createTextVNode(
          toDisplayString(_ctx.firstItem) + " / " + toDisplayString(_ctx.total),
          1
        )],
        64
      )) : (openBlock(), createBlock(
        Fragment,
        {
          key: 1
        },
        [createTextVNode(
          toDisplayString(_ctx.firstItem) + "-" + toDisplayString(Math.min(_ctx.current * _ctx.perPage, _ctx.total)) + " / " + toDisplayString(_ctx.total),
          1
        )],
        64
      ))],
      2
    )) : (openBlock(), createBlock(
      "ul",
      {
        key: 5,
        class: _ctx.listClasses
      },
      [createCommentVNode("First"), _ctx.hasFirst ? (openBlock(), createBlock("li", _hoisted_15, [_ctx.hasDefaultSlot ? renderSlot(_ctx.$slots, "default", {
        key: 0,
        page: _ctx.getPage(1),
        linkClass: _ctx.linkClasses,
        linkCurrentClass: _ctx.linkCurrentClasses
      }) : createVNode(
        _component_o_pagination_button,
        {
          key: 1,
          linkClass: _ctx.linkClasses,
          linkCurrentClass: _ctx.linkCurrentClasses,
          page: _ctx.getPage(1)
        },
        null,
        8,
        ["linkClass", "linkCurrentClass", "page"]
      )])) : createCommentVNode("v-if", true), _ctx.hasFirstEllipsis ? (openBlock(), createBlock("li", _hoisted_22, [createVNode(
        "span",
        {
          class: _ctx.ellipsisClasses
        },
        "\u2026",
        2
      )])) : createCommentVNode("v-if", true), createCommentVNode("Pages"), (openBlock(true), createBlock(
        Fragment,
        null,
        renderList(_ctx.pagesInRange, (page) => {
          return openBlock(), createBlock("li", {
            key: page.number
          }, [_ctx.hasDefaultSlot ? renderSlot(_ctx.$slots, "default", {
            key: 0,
            page,
            linkClass: _ctx.linkClasses,
            linkCurrentClass: _ctx.linkCurrentClasses
          }) : createVNode(
            _component_o_pagination_button,
            {
              key: 1,
              linkClass: _ctx.linkClasses,
              linkCurrentClass: _ctx.linkCurrentClasses,
              page
            },
            null,
            8,
            ["linkClass", "linkCurrentClass", "page"]
          )]);
        }),
        128
      )), createCommentVNode("Last"), _ctx.hasLastEllipsis ? (openBlock(), createBlock("li", _hoisted_3, [createVNode(
        "span",
        {
          class: _ctx.ellipsisClasses
        },
        "\u2026",
        2
      )])) : createCommentVNode("v-if", true), _ctx.hasLast ? (openBlock(), createBlock("li", _hoisted_4, [_ctx.hasDefaultSlot ? renderSlot(_ctx.$slots, "default", {
        key: 0,
        page: _ctx.getPage(_ctx.pageCount),
        linkClass: _ctx.linkClasses,
        linkCurrentClass: _ctx.linkCurrentClasses
      }) : createVNode(
        _component_o_pagination_button,
        {
          key: 1,
          linkClass: _ctx.linkClasses,
          linkCurrentClass: _ctx.linkCurrentClasses,
          page: _ctx.getPage(_ctx.pageCount)
        },
        null,
        8,
        ["linkClass", "linkCurrentClass", "page"]
      )])) : createCommentVNode("v-if", true)],
      2
    ))],
    2
  );
}
script$16.render = render$15;
script$16.__file = "src/components/pagination/Pagination.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/pagination.mjs
var index16 = {
  install(app) {
    registerComponent(app, script$16);
    registerComponent(app, script18);
  }
};
var pagination_default = index16;

// node_modules/@oruga-ui/oruga-next/dist/esm/radio.mjs
var script19 = defineComponent({
  name: "ORadio",
  mixins: [BaseComponentMixin, CheckRadioMixin],
  configField: "radio",
  emits: [
    "input"
  ],
  props: {
    rootClass: [String, Function, Array],
    disabledClass: [String, Function, Array],
    checkCheckedClass: [String, Function, Array],
    checkClass: [String, Function, Array],
    labelClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    variantClass: [String, Function, Array]
  },
  computed: {
    isChecked() {
      return this.modelValue === this.nativeValue;
    },
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-radio"),
        { [this.computedClass("checkedClass", "o-radio--checked")]: this.isChecked },
        { [this.computedClass("sizeClass", "o-radio--", this.size)]: this.size },
        { [this.computedClass("disabledClass", "o-radio--disabled")]: this.disabled },
        { [this.computedClass("variantClass", "o-radio--", this.variant)]: this.variant }
      ];
    },
    checkClasses() {
      return [
        this.computedClass("checkClass", "o-radio__check"),
        { [this.computedClass("checkCheckedClass", "o-radio__check--checked")]: this.isChecked }
      ];
    },
    labelClasses() {
      return [
        this.computedClass("labelClass", "o-radio__label")
      ];
    }
  }
});
function render19(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "label",
    {
      class: _ctx.rootClasses,
      ref: "label",
      onClick: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.focus(...args), ["stop"])),
      onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.$refs.label.click(), ["prevent"]), ["enter"]))
    },
    [withDirectives(createVNode(
      "input",
      {
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.computedValue = $event),
        type: "radio",
        ref: "input",
        onClick: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["stop"])),
        class: _ctx.checkClasses,
        disabled: _ctx.disabled,
        required: _ctx.required,
        name: _ctx.name,
        value: _ctx.nativeValue
      },
      null,
      10,
      ["disabled", "required", "name", "value"]
    ), [[vModelRadio, _ctx.computedValue]]), createVNode(
      "span",
      {
        class: _ctx.labelClasses
      },
      [renderSlot(_ctx.$slots, "default")],
      2
    )],
    34
  );
}
script19.render = render19;
script19.__file = "src/components/radio/Radio.vue";
var index17 = {
  install(app) {
    registerComponent(app, script19);
  }
};
var radio_default = index17;

// node_modules/@oruga-ui/oruga-next/dist/esm/select.mjs
var index18 = {
  install(app) {
    registerComponent(app, script10);
  }
};
var select_default = index18;

// node_modules/@oruga-ui/oruga-next/dist/esm/skeleton.mjs
var script20 = defineComponent({
  name: "OSkeleton",
  mixins: [BaseComponentMixin],
  configField: "skeleton",
  props: {
    active: {
      type: Boolean,
      default: true
    },
    animated: {
      type: Boolean,
      default: true
    },
    width: [Number, String],
    height: [Number, String],
    circle: Boolean,
    rounded: {
      type: Boolean,
      default: true
    },
    count: {
      type: Number,
      default: 1
    },
    position: {
      type: String,
      default: "left",
      validator(value) {
        return [
          "left",
          "centered",
          "right"
        ].indexOf(value) > -1;
      }
    },
    size: String,
    rootClass: [String, Function, Array],
    animationClass: [String, Function, Array],
    positionClass: [String, Function, Array],
    itemClass: [String, Function, Array],
    itemRoundedClass: [String, Function, Array],
    sizeClass: [String, Function, Array]
  },
  render() {
    if (!this.active)
      return;
    const items2 = [];
    const width = this.width;
    const height = this.height;
    for (let i = 0; i < this.count; i++) {
      items2.push(h("div", {
        class: [
          this.computedClass("itemClass", "o-sklt__item"),
          { [this.computedClass("itemRoundedClass", "o-sklt__item--rounded")]: this.rounded },
          { [this.computedClass("animationClass", "o-sklt__item--animated")]: this.animated },
          { [this.computedClass("sizeClass", "o-sklt__item--", this.size)]: this.size }
        ],
        key: i,
        style: {
          height: toCssDimension(height),
          width: toCssDimension(width),
          borderRadius: this.circle ? "50%" : null
        }
      }));
    }
    return h("div", {
      class: [
        this.computedClass("rootClass", "o-sklt"),
        { [this.computedClass("positionClass", "o-sklt--", this.position)]: this.position }
      ]
    }, items2);
  }
});
script20.__file = "src/components/skeleton/Skeleton.vue";
var index19 = {
  install(app) {
    registerComponent(app, script20);
  }
};
var skeleton_default = index19;

// node_modules/@oruga-ui/oruga-next/dist/esm/sidebar.mjs
var script21 = defineComponent({
  name: "OSidebar",
  mixins: [BaseComponentMixin, MatchMediaMixin],
  configField: "sidebar",
  emits: ["update:open", "close"],
  props: {
    open: Boolean,
    variant: [String, Object],
    overlay: Boolean,
    position: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "sidebar.position", "fixed");
      },
      validator: (value) => {
        return [
          "fixed",
          "absolute",
          "static"
        ].indexOf(value) >= 0;
      }
    },
    fullheight: Boolean,
    fullwidth: Boolean,
    right: Boolean,
    mobile: {
      type: String,
      validator: (value) => {
        return [
          "",
          "fullwidth",
          "reduced",
          "hidden"
        ].indexOf(value) >= 0;
      }
    },
    reduce: Boolean,
    expandOnHover: Boolean,
    expandOnHoverFixed: Boolean,
    canCancel: {
      type: [Array, Boolean],
      default: () => {
        return getValueByPath(getOptions(), "sidebar.canCancel", ["escape", "outside"]);
      }
    },
    onCancel: {
      type: Function,
      default: () => {
      }
    },
    scroll: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "sidebar.scroll", "clip");
      },
      validator: (value) => {
        return [
          "clip",
          "keep"
        ].indexOf(value) >= 0;
      }
    },
    rootClass: [String, Function, Array],
    overlayClass: [String, Function, Array],
    contentClass: [String, Function, Array],
    fixedClass: [String, Function, Array],
    staticClass: [String, Function, Array],
    absoluteClass: [String, Function, Array],
    fullheightClass: [String, Function, Array],
    fullwidthClass: [String, Function, Array],
    rightClass: [String, Function, Array],
    reduceClass: [String, Function, Array],
    expandOnHoverClass: [String, Function, Array],
    expandOnHoverFixedClass: [String, Function, Array],
    variantClass: [String, Function, Array],
    mobileClass: [String, Function, Array]
  },
  data() {
    return {
      isOpen: this.open,
      transitionName: null,
      animating: true,
      savedScrollTop: null
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-side"),
        { [this.computedClass("mobileClass", "o-side--mobile")]: this.isMatchMedia }
      ];
    },
    overlayClasses() {
      return [
        this.computedClass("overlayClass", "o-side__overlay")
      ];
    },
    contentClasses() {
      return [
        this.computedClass("contentClass", "o-side__content"),
        { [this.computedClass("variantClass", "o-side__content--", this.variant)]: this.variant },
        { [this.computedClass("fixedClass", "o-side__content--fixed")]: this.isFixed },
        { [this.computedClass("staticClass", "o-side__content--static")]: this.isStatic },
        { [this.computedClass("absoluteClass", "o-side__content--absolute")]: this.isAbsolute },
        { [this.computedClass("fullheightClass", "o-side__content--fullheight")]: this.fullheight },
        { [this.computedClass("fullwidthClass", "o-side__content--fullwidth")]: this.fullwidth || this.mobile === "fullwidth" && this.isMatchMedia },
        { [this.computedClass("rightClass", "o-side__content--right")]: this.right },
        { [this.computedClass("reduceClass", "o-side__content--mini")]: this.reduce || this.mobile === "reduced" && this.isMatchMedia },
        { [this.computedClass("expandOnHoverClass", "o-side__content--mini-expand")]: this.expandOnHover && this.mobile !== "fullwidth" },
        { [this.computedClass("expandOnHoverFixedClass", "o-side__content--expand-mini-hover-fixed")]: this.expandOnHover && this.expandOnHoverFixed && this.mobile !== "fullwidth" }
      ];
    },
    cancelOptions() {
      return typeof this.canCancel === "boolean" ? this.canCancel ? getValueByPath(getOptions(), "sidebar.canCancel", ["escape", "outside"]) : [] : this.canCancel;
    },
    isStatic() {
      return this.position === "static";
    },
    isFixed() {
      return this.position === "fixed";
    },
    isAbsolute() {
      return this.position === "absolute";
    },
    hideOnMobile() {
      return this.mobile === "hidden" && this.isMatchMedia;
    }
  },
  watch: {
    open: {
      handler(value) {
        this.isOpen = value;
        if (this.overlay) {
          this.handleScroll();
        }
        const open = this.right ? !value : value;
        this.transitionName = !open ? "slide-prev" : "slide-next";
      },
      immediate: true
    }
  },
  methods: {
    keyPress({ key }) {
      if (this.isFixed) {
        if (this.isOpen && (key === "Escape" || key === "Esc"))
          this.cancel("escape");
      }
    },
    cancel(method) {
      if (this.cancelOptions.indexOf(method) < 0)
        return;
      if (this.isStatic)
        return;
      this.onCancel.apply(null, arguments);
      this.close();
    },
    close() {
      this.isOpen = false;
      this.$emit("close");
      this.$emit("update:open", false);
    },
    clickedOutside(event) {
      if (!this.isFixed || !this.isOpen || this.animating) {
        return;
      }
      if (!event.composedPath().includes(this.$refs.sidebarContent)) {
        this.cancel("outside");
      }
    },
    beforeEnter() {
      this.animating = true;
    },
    afterEnter() {
      this.animating = false;
    },
    handleScroll() {
      if (typeof window === "undefined")
        return;
      if (this.scroll === "clip") {
        if (this.open) {
          document.documentElement.classList.add("o-clipped");
        } else {
          document.documentElement.classList.remove("o-clipped");
        }
        return;
      }
      this.savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;
      if (this.open) {
        document.body.classList.add("o-noscroll");
      } else {
        document.body.classList.remove("o-noscroll");
      }
      if (this.open) {
        document.body.style.top = `-${this.savedScrollTop}px`;
        return;
      }
      document.documentElement.scrollTop = this.savedScrollTop;
      document.body.style.top = null;
      this.savedScrollTop = null;
    }
  },
  created() {
    if (typeof window !== "undefined") {
      document.addEventListener("keyup", this.keyPress);
      document.addEventListener("click", this.clickedOutside);
    }
  },
  mounted() {
    if (typeof window !== "undefined") {
      if (this.isFixed) {
        document.body.appendChild(this.$el);
      }
      if (this.overlay && this.open) {
        this.handleScroll();
      }
    }
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      document.removeEventListener("keyup", this.keyPress);
      document.removeEventListener("click", this.clickedOutside);
      if (this.overlay) {
        document.documentElement.classList.remove("o-clipped");
        const savedScrollTop = !this.savedScrollTop ? document.documentElement.scrollTop : this.savedScrollTop;
        document.body.classList.remove("o-noscroll");
        document.documentElement.scrollTop = savedScrollTop;
        document.body.style.top = null;
      }
    }
    if (this.isFixed) {
      removeElement(this.$el);
    }
  }
});
function render20(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses
    },
    [_ctx.overlay && _ctx.isOpen ? (openBlock(), createBlock(
      "div",
      {
        key: 0,
        class: _ctx.overlayClasses
      },
      null,
      2
    )) : createCommentVNode("v-if", true), createVNode(
      Transition,
      {
        name: _ctx.transitionName,
        "onBefore-enter": _ctx.beforeEnter,
        "onAfter-enter": _ctx.afterEnter
      },
      {
        default: withCtx(() => [withDirectives(createVNode(
          "div",
          {
            ref: "sidebarContent",
            class: _ctx.contentClasses
          },
          [renderSlot(_ctx.$slots, "default")],
          2
        ), [[vShow, _ctx.isOpen]])]),
        _: 3
      },
      8,
      ["name", "onBefore-enter", "onAfter-enter"]
    )],
    2
  )), [[vShow, !_ctx.hideOnMobile]]);
}
script21.render = render20;
script21.__file = "src/components/sidebar/Sidebar.vue";
var index20 = {
  install(app) {
    registerComponent(app, script21);
  }
};
var sidebar_default = index20;

// node_modules/@oruga-ui/oruga-next/dist/esm/Tooltip-35ab4d41.mjs
var script22 = defineComponent({
  name: "OTooltip",
  mixins: [BaseComponentMixin],
  configField: "tooltip",
  emits: ["open", "close"],
  props: {
    active: {
      type: Boolean,
      default: true
    },
    label: String,
    delay: Number,
    position: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "tooltip.position", "top");
      },
      validator: (value) => {
        return [
          "top",
          "bottom",
          "left",
          "right"
        ].indexOf(value) > -1;
      }
    },
    triggers: {
      type: Array,
      default: () => {
        return getValueByPath(getOptions(), "tooltip.triggers", ["hover"]);
      }
    },
    always: Boolean,
    animated: {
      type: Boolean,
      default: true
    },
    animation: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "tooltip.animation", "fade");
      }
    },
    autoClose: {
      type: [Array, Boolean],
      default: true
    },
    multiline: Boolean,
    appendToBody: Boolean,
    variant: [String, Function, Array],
    rootClass: [String, Function, Array],
    contentClass: [String, Function, Array],
    orderClass: [String, Function, Array],
    triggerClass: [String, Function, Array],
    multilineClass: [String, Function, Array],
    alwaysClass: [String, Function, Array],
    variantClass: [String, Function, Array],
    arrowClass: [String, Function, Array],
    arrowOrderClass: [String, Function, Array]
  },
  data() {
    return {
      isActive: false,
      triggerStyle: {},
      bodyEl: void 0
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-tip")
      ];
    },
    triggerClasses() {
      return [
        this.computedClass("triggerClass", "o-tip__trigger")
      ];
    },
    arrowClasses() {
      return [
        this.computedClass("arrowClass", "o-tip__arrow"),
        { [this.computedClass("arrowOrderClass", "o-tip__arrow--", this.position)]: this.position },
        { [this.computedClass("variantArrowClass", "o-tip__arrow--", this.variant)]: this.variant }
      ];
    },
    contentClasses() {
      return [
        this.computedClass("contentClass", "o-tip__content"),
        { [this.computedClass("orderClass", "o-tip__content--", this.position)]: this.position },
        { [this.computedClass("variantClass", "o-tip__content--", this.variant)]: this.variant },
        { [this.computedClass("multilineClass", "o-tip__content--multiline")]: this.multiline },
        { [this.computedClass("alwaysClass", "o-tip__content--always")]: this.always }
      ];
    },
    newAnimation() {
      return this.animated ? this.animation : void 0;
    }
  },
  watch: {
    isActive(value) {
      this.$emit(this.isActive ? "open" : "close");
      if (value && this.appendToBody) {
        this.updateAppendToBody();
      }
    }
  },
  methods: {
    updateAppendToBody() {
      const tooltip = this.$refs.tooltip;
      const trigger = this.$refs.trigger;
      if (tooltip && trigger) {
        const tooltipEl = this.$data.bodyEl.children[0];
        tooltipEl.classList.forEach((item) => tooltipEl.classList.remove(...item.split(" ")));
        if (this.$vnode && this.$vnode.data && this.$vnode.data.staticClass) {
          tooltipEl.classList.add(this.$vnode.data.staticClass);
        }
        this.rootClasses.forEach((item) => {
          if (typeof item === "object") {
            Object.keys(item).filter((key) => key && item[key]).forEach((key) => tooltipEl.classList.add(key));
          } else {
            tooltipEl.classList.add(...item.split(" "));
          }
        });
        tooltipEl.style.width = `${trigger.clientWidth}px`;
        tooltipEl.style.height = `${trigger.clientHeight}px`;
        const rect = trigger.getBoundingClientRect();
        const top = rect.top + window.scrollY;
        const left = rect.left + window.scrollX;
        const wrapper = this.$data.bodyEl;
        wrapper.style.position = "absolute";
        wrapper.style.top = `${top}px`;
        wrapper.style.left = `${left}px`;
        wrapper.style.zIndex = this.isActive || this.always ? "99" : "-1";
        this.triggerStyle = { zIndex: this.isActive || this.always ? "100" : void 0 };
      }
    },
    onClick() {
      if (this.triggers.indexOf("click") < 0)
        return;
      this.$nextTick(() => {
        setTimeout(() => this.open());
      });
    },
    onHover() {
      if (this.triggers.indexOf("hover") < 0)
        return;
      this.open();
    },
    onFocus() {
      if (this.triggers.indexOf("focus") < 0)
        return;
      this.open();
    },
    onContextMenu(event) {
      if (this.triggers.indexOf("contextmenu") < 0)
        return;
      event.preventDefault();
      this.open();
    },
    open() {
      if (this.delay) {
        this.timer = setTimeout(() => {
          this.isActive = true;
          this.timer = null;
        }, this.delay);
      } else {
        this.isActive = true;
      }
    },
    close() {
      if (typeof this.autoClose === "boolean") {
        this.isActive = !this.autoClose;
      }
      if (this.autoClose && this.timer)
        clearTimeout(this.timer);
    },
    clickedOutside(event) {
      if (this.isActive) {
        if (Array.isArray(this.autoClose)) {
          if (this.autoClose.indexOf("outside") >= 0) {
            if (!this.isInWhiteList(event.target))
              this.isActive = false;
          }
          if (this.autoClose.indexOf("inside") >= 0) {
            if (this.isInWhiteList(event.target))
              this.isActive = false;
          }
        }
      }
    },
    keyPress({ key }) {
      if (this.isActive && (key === "Escape" || key === "Esc")) {
        if (Array.isArray(this.autoClose)) {
          if (this.autoClose.indexOf("escape") >= 0)
            this.isActive = false;
        }
      }
    },
    isInWhiteList(el) {
      if (el === this.$refs.content)
        return true;
      if (this.$refs.content !== void 0) {
        const children = this.$refs.content.querySelectorAll("*");
        for (const child of children) {
          if (el === child) {
            return true;
          }
        }
      }
      return false;
    }
  },
  mounted() {
    if (this.appendToBody) {
      this.$data.bodyEl = createAbsoluteElement(this.$refs.content);
      this.updateAppendToBody();
    }
  },
  created() {
    if (typeof window !== "undefined") {
      document.addEventListener("click", this.clickedOutside);
      document.addEventListener("keyup", this.keyPress);
    }
  },
  beforeUnmount() {
    if (typeof window !== "undefined") {
      document.removeEventListener("click", this.clickedOutside);
      document.removeEventListener("keyup", this.keyPress);
    }
    if (this.appendToBody) {
      removeElement(this.$data.bodyEl);
    }
  }
});
function render21(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "div",
    {
      ref: "tooltip",
      class: _ctx.rootClasses
    },
    [createVNode(
      Transition,
      {
        name: _ctx.newAnimation
      },
      {
        default: withCtx(() => [withDirectives(createVNode(
          "div",
          {
            ref: "content",
            class: _ctx.contentClasses
          },
          [createVNode(
            "span",
            {
              class: _ctx.arrowClasses
            },
            null,
            2
          ), _ctx.label ? (openBlock(), createBlock(
            Fragment,
            {
              key: 0
            },
            [createTextVNode(
              toDisplayString(_ctx.label),
              1
            )],
            64
          )) : _ctx.$slots.default ? renderSlot(_ctx.$slots, "content", {
            key: 1
          }) : createCommentVNode("v-if", true)],
          2
        ), [[vShow, _ctx.active && (_ctx.isActive || _ctx.always)]])]),
        _: 1
      },
      8,
      ["name"]
    ), createVNode(
      "div",
      {
        ref: "trigger",
        class: _ctx.triggerClasses,
        style: _ctx.triggerStyle,
        onClick: _cache[1] || (_cache[1] = (...args) => _ctx.onClick(...args)),
        onContextmenu: _cache[2] || (_cache[2] = (...args) => _ctx.onContextMenu(...args)),
        onMouseenter: _cache[3] || (_cache[3] = (...args) => _ctx.onHover(...args)),
        onFocusCapture: _cache[4] || (_cache[4] = (...args) => _ctx.onFocus(...args)),
        onBlurCapture: _cache[5] || (_cache[5] = (...args) => _ctx.close(...args)),
        onMouseleave: _cache[6] || (_cache[6] = (...args) => _ctx.close(...args))
      },
      [renderSlot(_ctx.$slots, "default", {
        ref: "slot"
      })],
      38
    )],
    2
  );
}
script22.render = render21;
script22.__file = "src/components/tooltip/Tooltip.vue";

// node_modules/@oruga-ui/oruga-next/dist/esm/slider.mjs
var script23 = defineComponent({
  name: "OSliderThumb",
  components: {
    [script22.name]: script22
  },
  configField: "slider",
  inheritAttrs: false,
  inject: ["$slider"],
  emits: ["update:modelValue", "dragstart", "dragend"],
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    variant: {
      type: String,
      default: ""
    },
    tooltip: {
      type: Boolean,
      default: true
    },
    indicator: {
      type: Boolean,
      default: false
    },
    customFormatter: Function,
    format: {
      type: String,
      default: "raw",
      validator: (value) => {
        return [
          "raw",
          "percent"
        ].indexOf(value) >= 0;
      }
    },
    locale: {
      type: [String, Array],
      default: () => {
        return getValueByPath(getOptions(), "locale");
      }
    },
    tooltipAlways: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      isFocused: false,
      dragging: false,
      startX: 0,
      startPosition: 0,
      newPosition: null,
      oldValue: this.modelValue
    };
  },
  computed: {
    disabled() {
      return this.$parent.disabled;
    },
    max() {
      return this.$parent.max;
    },
    min() {
      return this.$parent.min;
    },
    step() {
      return this.$parent.step;
    },
    precision() {
      return this.$parent.precision;
    },
    currentPosition() {
      return `${(this.modelValue - this.min) / (this.max - this.min) * 100}%`;
    },
    wrapperStyle() {
      return { left: this.currentPosition };
    },
    formattedValue() {
      if (typeof this.customFormatter !== "undefined") {
        return this.customFormatter(this.modelValue);
      }
      if (this.format === "percent") {
        return new Intl.NumberFormat(this.locale, {
          style: "percent"
        }).format((this.modelValue - this.min) / (this.max - this.min));
      }
      return new Intl.NumberFormat(this.locale).format(this.modelValue);
    }
  },
  methods: {
    onFocus() {
      this.isFocused = true;
    },
    onBlur() {
      this.isFocused = false;
    },
    onButtonDown(event) {
      if (this.disabled)
        return;
      event.preventDefault();
      this.onDragStart(event);
      if (typeof window !== "undefined") {
        document.addEventListener("mousemove", this.onDragging);
        document.addEventListener("touchmove", this.onDragging);
        document.addEventListener("mouseup", this.onDragEnd);
        document.addEventListener("touchend", this.onDragEnd);
        document.addEventListener("contextmenu", this.onDragEnd);
      }
    },
    onLeftKeyDown() {
      if (this.disabled || this.modelvalue === this.min)
        return;
      this.newPosition = parseFloat(this.currentPosition) - this.step / (this.max - this.min) * 100;
      this.setPosition(this.newPosition);
      this.$parent.emitValue("change");
    },
    onRightKeyDown() {
      if (this.disabled || this.modelvalue === this.max)
        return;
      this.newPosition = parseFloat(this.currentPosition) + this.step / (this.max - this.min) * 100;
      this.setPosition(this.newPosition);
      this.$parent.emitValue("change");
    },
    onHomeKeyDown() {
      if (this.disabled || this.modelvalue === this.min)
        return;
      this.newPosition = 0;
      this.setPosition(this.newPosition);
      this.$parent.emitValue("change");
    },
    onEndKeyDown() {
      if (this.disabled || this.modelvalue === this.max)
        return;
      this.newPosition = 100;
      this.setPosition(this.newPosition);
      this.$parent.emitValue("change");
    },
    onDragStart(event) {
      this.dragging = true;
      this.$emit("dragstart");
      if (event.type === "touchstart") {
        event.clientX = event.touches[0].clientX;
      }
      this.startX = event.clientX;
      this.startPosition = parseFloat(this.currentPosition);
      this.newPosition = this.startPosition;
    },
    onDragging(event) {
      if (this.dragging) {
        if (event.type === "touchmove") {
          event.clientX = event.touches[0].clientX;
        }
        const diff = (event.clientX - this.startX) / this.$parent.sliderSize() * 100;
        this.newPosition = this.startPosition + diff;
        this.setPosition(this.newPosition);
      }
    },
    onDragEnd() {
      this.dragging = false;
      this.$emit("dragend");
      if (this.modelvalue !== this.oldValue) {
        this.$parent.emitValue("change");
      }
      this.setPosition(this.newPosition);
      if (typeof window !== "undefined") {
        document.removeEventListener("mousemove", this.onDragging);
        document.removeEventListener("touchmove", this.onDragging);
        document.removeEventListener("mouseup", this.onDragEnd);
        document.removeEventListener("touchend", this.onDragEnd);
        document.removeEventListener("contextmenu", this.onDragEnd);
      }
    },
    setPosition(percent) {
      if (percent === null || isNaN(percent))
        return;
      if (percent < 0) {
        percent = 0;
      } else if (percent > 100) {
        percent = 100;
      }
      const stepLength = 100 / ((this.max - this.min) / this.step);
      const steps = Math.round(percent / stepLength);
      let value = steps * stepLength / 100 * (this.max - this.min) + this.min;
      value = parseFloat(value.toFixed(this.precision));
      this.$emit("update:modelValue", value);
      if (!this.dragging && value !== this.oldValue) {
        this.oldValue = value;
      }
    }
  }
});
var _hoisted_16 = {
  key: 0
};
function render22(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_tooltip = resolveComponent("o-tooltip");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.$slider.thumbWrapperClasses,
      style: _ctx.wrapperStyle
    },
    [createVNode(
      _component_o_tooltip,
      {
        label: _ctx.formattedValue,
        variant: _ctx.variant,
        always: _ctx.dragging || _ctx.isFocused || _ctx.tooltipAlways,
        active: !_ctx.disabled && _ctx.tooltip
      },
      {
        default: withCtx(() => [createVNode(
          "div",
          mergeProps(_ctx.$attrs, {
            class: _ctx.$slider.thumbClasses,
            tabindex: _ctx.disabled ? false : 0,
            onMousedown: _cache[1] || (_cache[1] = (...args) => _ctx.onButtonDown(...args)),
            onTouchstart: _cache[2] || (_cache[2] = (...args) => _ctx.onButtonDown(...args)),
            onFocus: _cache[3] || (_cache[3] = (...args) => _ctx.onFocus(...args)),
            onBlur: _cache[4] || (_cache[4] = (...args) => _ctx.onBlur(...args)),
            onKeydown: [_cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.onLeftKeyDown(...args), ["prevent"]), ["left"])), _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.onRightKeyDown(...args), ["prevent"]), ["right"])), _cache[7] || (_cache[7] = withKeys(withModifiers((...args) => _ctx.onLeftKeyDown(...args), ["prevent"]), ["down"])), _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => _ctx.onRightKeyDown(...args), ["prevent"]), ["up"])), _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => _ctx.onHomeKeyDown(...args), ["prevent"]), ["home"])), _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => _ctx.onEndKeyDown(...args), ["prevent"]), ["end"]))]
          }),
          [_ctx.indicator ? (openBlock(), createBlock(
            "span",
            _hoisted_16,
            toDisplayString(_ctx.formattedValue),
            1
          )) : createCommentVNode("v-if", true)],
          16,
          ["tabindex"]
        )]),
        _: 1
      },
      8,
      ["label", "variant", "always", "active"]
    )],
    6
  );
}
script23.render = render22;
script23.__file = "src/components/slider/SliderThumb.vue";
var script$17 = defineComponent({
  name: "OSliderTick",
  mixins: [BaseComponentMixin],
  configField: "slider",
  inject: ["$slider"],
  props: {
    value: {
      variant: Number,
      default: 0
    },
    tickClass: [String, Function, Array],
    tickHiddenClass: [String, Function, Array],
    tickLabelClass: [String, Function, Array]
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("tickClass", "o-slide__tick"),
        { [this.computedClass("tickHiddenClass", "o-slide__tick--hidden")]: this.hidden }
      ];
    },
    tickLabelClasses() {
      return [
        this.computedClass("tickLabelClass", "o-slide__tick-label")
      ];
    },
    position() {
      const pos = (this.value - this.$parent.min) / (this.$parent.max - this.$parent.min) * 100;
      return pos >= 0 && pos <= 100 ? pos : 0;
    },
    hidden() {
      return this.value === this.$parent.min || this.value === this.$parent.max;
    },
    tickStyle() {
      return { "left": this.position + "%" };
    }
  },
  created() {
    if (!this.$slider) {
      throw new Error("You should wrap oSliderTick on a oSlider");
    }
  }
});
function render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses,
      style: _ctx.tickStyle
    },
    [_ctx.$slots.default ? (openBlock(), createBlock(
      "span",
      {
        key: 0,
        class: _ctx.tickLabelClasses
      },
      [renderSlot(_ctx.$slots, "default")],
      2
    )) : createCommentVNode("v-if", true)],
    6
  );
}
script$17.render = render$16;
script$17.__file = "src/components/slider/SliderTick.vue";
var script$22 = defineComponent({
  name: "OSlider",
  components: {
    [script23.name]: script23,
    [script$17.name]: script$17
  },
  configField: "slider",
  mixins: [BaseComponentMixin],
  provide() {
    return {
      $slider: this
    };
  },
  emits: ["update:modelValue", "change", "dragging", "dragstart", "dragend"],
  props: {
    modelValue: {
      type: [Number, Array],
      default: 0
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    },
    variant: {
      type: String
    },
    size: String,
    ticks: {
      type: Boolean,
      default: false
    },
    tooltip: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "slider.tooltip", true);
      }
    },
    tooltipVariant: String,
    rounded: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "slider.rounded", false);
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    lazy: {
      type: Boolean,
      default: false
    },
    customFormatter: Function,
    ariaLabel: [String, Array],
    biggerSliderFocus: {
      type: Boolean,
      default: false
    },
    indicator: {
      type: Boolean,
      default: false
    },
    format: {
      type: String,
      default: "raw",
      validator: (value) => {
        return [
          "raw",
          "percent"
        ].indexOf(value) >= 0;
      }
    },
    locale: {
      type: [String, Array],
      default: () => {
        return getValueByPath(getOptions(), "locale");
      }
    },
    tooltipAlways: {
      type: Boolean,
      default: false
    },
    rootClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    trackClass: [String, Function, Array],
    fillClass: [String, Function, Array],
    thumbRoundedClass: [String, Function, Array],
    thumbDraggingClass: [String, Function, Array],
    disabledClass: [String, Function, Array],
    thumbWrapperClass: [String, Function, Array],
    thumbClass: [String, Function, Array],
    variantClass: [String, Function, Array]
  },
  data() {
    return {
      value1: null,
      value2: null,
      dragging: false,
      isRange: false
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-slide"),
        { [this.computedClass("sizeClass", "o-slide--", this.size)]: this.size },
        { [this.computedClass("disabledClass", "o-slide--disabled")]: this.disabled }
      ];
    },
    trackClasses() {
      return [
        this.computedClass("trackClass", "o-slide__track")
      ];
    },
    fillClasses() {
      return [
        this.computedClass("fillClass", "o-slide__fill"),
        { [this.computedClass("variantClass", "o-slide__fill--", this.variant)]: this.variant }
      ];
    },
    thumbClasses() {
      return [
        this.computedClass("thumbClass", "o-slide__thumb"),
        { [this.computedClass("thumbDraggingClass", "o-slide__thumb--dragging")]: this.dragging },
        { [this.computedClass("thumbRoundedClass", "o-slide__thumb--rounded")]: this.rounded }
      ];
    },
    thumbWrapperClasses() {
      return [
        this.computedClass("thumbWrapperClass", "o-slide__thumb-wrapper")
      ];
    },
    newTooltipVariant() {
      return this.tooltipVariant ? this.tooltipVariant : this.variant;
    },
    tickValues() {
      if (!this.ticks || this.min > this.max || this.step === 0)
        return [];
      const result = [];
      for (let i = this.min + this.step; i < this.max; i = i + this.step) {
        result.push(i);
      }
      return result;
    },
    minValue() {
      return Math.min(this.value1, this.value2);
    },
    maxValue() {
      return Math.max(this.value1, this.value2);
    },
    barSize() {
      return this.isRange ? `${100 * (this.maxValue - this.minValue) / (this.max - this.min)}%` : `${100 * (this.value1 - this.min) / (this.max - this.min)}%`;
    },
    barStart() {
      return this.isRange ? `${100 * (this.minValue - this.min) / (this.max - this.min)}%` : "0%";
    },
    precision() {
      const precisions = [this.min, this.max, this.step].map((item) => {
        const decimal = ("" + item).split(".")[1];
        return decimal ? decimal.length : 0;
      });
      return Math.max(...precisions);
    },
    barStyle() {
      return {
        width: this.barSize,
        left: this.barStart
      };
    }
  },
  watch: {
    value1() {
      this.onInternalValueUpdate();
    },
    value2() {
      this.onInternalValueUpdate();
    },
    min() {
      this.setValues(this.value);
    },
    max() {
      this.setValues(this.value);
    },
    modelValue(value) {
      this.setValues(value);
    }
  },
  methods: {
    setValues(newValue) {
      if (this.min > this.max) {
        return;
      }
      if (Array.isArray(newValue)) {
        this.isRange = true;
        const smallValue = typeof newValue[0] !== "number" || isNaN(newValue[0]) ? this.min : Math.min(Math.max(this.min, newValue[0]), this.max);
        const largeValue = typeof newValue[1] !== "number" || isNaN(newValue[1]) ? this.max : Math.max(Math.min(this.max, newValue[1]), this.min);
        this.value1 = this.isThumbReversed ? largeValue : smallValue;
        this.value2 = this.isThumbReversed ? smallValue : largeValue;
      } else {
        this.isRange = false;
        this.value1 = isNaN(newValue) ? this.min : Math.min(this.max, Math.max(this.min, newValue));
        this.value2 = null;
      }
    },
    onInternalValueUpdate() {
      if (this.isRange) {
        this.isThumbReversed = this.value1 > this.value2;
      }
      if (!this.lazy || !this.dragging) {
        this.emitValue("update:modelValue");
      }
      if (this.dragging) {
        this.emitValue("dragging");
      }
    },
    sliderSize() {
      return this.$refs.slider.getBoundingClientRect().width;
    },
    onSliderClick(event) {
      if (this.disabled || this.isTrackClickDisabled)
        return;
      const sliderOffsetLeft = this.$refs.slider.getBoundingClientRect().left;
      const percent = (event.clientX - sliderOffsetLeft) / this.sliderSize() * 100;
      const targetValue = this.min + percent * (this.max - this.min) / 100;
      const diffFirst = Math.abs(targetValue - this.value1);
      if (!this.isRange) {
        if (diffFirst < this.step / 2)
          return;
        this.$refs.button1.setPosition(percent);
      } else {
        const diffSecond = Math.abs(targetValue - this.value2);
        if (diffFirst <= diffSecond) {
          if (diffFirst < this.step / 2)
            return;
          this.$refs["button1"].setPosition(percent);
        } else {
          if (diffSecond < this.step / 2)
            return;
          this.$refs["button2"].setPosition(percent);
        }
      }
      this.emitValue("change");
    },
    onDragStart() {
      this.dragging = true;
      this.$emit("dragstart");
    },
    onDragEnd() {
      this.isTrackClickDisabled = true;
      setTimeout(() => {
        this.isTrackClickDisabled = false;
      }, 0);
      this.dragging = false;
      this.$emit("dragend");
      if (this.lazy) {
        this.emitValue("update:modelValue");
      }
    },
    emitValue(event) {
      const val = this.isRange ? [this.minValue, this.maxValue] : this.value1;
      this.$emit(event, val);
    }
  },
  created() {
    this.isThumbReversed = false;
    this.isTrackClickDisabled = false;
    this.setValues(this.modelValue);
  }
});
function render$22(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_slider_tick = resolveComponent("o-slider-tick");
  const _component_o_slider_thumb = resolveComponent("o-slider-thumb");
  return openBlock(), createBlock(
    "div",
    {
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.onSliderClick(...args)),
      class: _ctx.rootClasses
    },
    [createVNode(
      "div",
      {
        class: _ctx.trackClasses,
        ref: "slider"
      },
      [createVNode(
        "div",
        {
          class: _ctx.fillClasses,
          style: _ctx.barStyle
        },
        null,
        6
      ), _ctx.ticks ? (openBlock(true), createBlock(
        Fragment,
        {
          key: 0
        },
        renderList(_ctx.tickValues, (val, key) => {
          return openBlock(), createBlock(
            _component_o_slider_tick,
            {
              key,
              value: val
            },
            null,
            8,
            ["value"]
          );
        }),
        128
      )) : createCommentVNode("v-if", true), renderSlot(_ctx.$slots, "default"), createVNode(
        _component_o_slider_thumb,
        {
          modelValue: _ctx.value1,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.value1 = $event),
          variant: _ctx.newTooltipVariant,
          tooltip: _ctx.tooltip,
          "custom-formatter": _ctx.customFormatter,
          indicator: _ctx.indicator,
          ref: "button1",
          role: "slider",
          format: _ctx.format,
          locale: _ctx.locale,
          "tooltip-always": _ctx.tooltipAlways,
          "aria-valuenow": _ctx.value1,
          "aria-valuemin": _ctx.min,
          "aria-valuemax": _ctx.max,
          "aria-orientation": "horizontal",
          "aria-label": Array.isArray(_ctx.ariaLabel) ? _ctx.ariaLabel[0] : _ctx.ariaLabel,
          "aria-disabled": _ctx.disabled,
          onDragstart: _ctx.onDragStart,
          onDragend: _ctx.onDragEnd
        },
        null,
        8,
        ["modelValue", "variant", "tooltip", "custom-formatter", "indicator", "format", "locale", "tooltip-always", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-label", "aria-disabled", "onDragstart", "onDragend"]
      ), _ctx.isRange ? createVNode(
        _component_o_slider_thumb,
        {
          key: 1,
          modelValue: _ctx.value2,
          "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.value2 = $event),
          variant: _ctx.newTooltipVariant,
          tooltip: _ctx.tooltip,
          "custom-formatter": _ctx.customFormatter,
          indicator: _ctx.indicator,
          ref: "button2",
          role: "slider",
          format: _ctx.format,
          locale: _ctx.locale,
          "tooltip-always": _ctx.tooltipAlways,
          "aria-valuenow": _ctx.value2,
          "aria-valuemin": _ctx.min,
          "aria-valuemax": _ctx.max,
          "aria-orientation": "horizontal",
          "aria-label": Array.isArray(_ctx.ariaLabel) ? _ctx.ariaLabel[1] : "",
          "aria-disabled": _ctx.disabled,
          onDragstart: _ctx.onDragStart,
          onDragend: _ctx.onDragEnd
        },
        null,
        8,
        ["modelValue", "variant", "tooltip", "custom-formatter", "indicator", "format", "locale", "tooltip-always", "aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-label", "aria-disabled", "onDragstart", "onDragend"]
      ) : createCommentVNode("v-if", true)],
      2
    )],
    2
  );
}
script$22.render = render$22;
script$22.__file = "src/components/slider/Slider.vue";
var index21 = {
  install(app) {
    registerComponent(app, script$22);
    registerComponent(app, script$17);
  }
};
var slider_default = index21;

// node_modules/@oruga-ui/oruga-next/dist/esm/SlotComponent-11a269f3.mjs
var SlotComponent = defineComponent({
  name: "OSlotComponent",
  props: {
    component: {
      type: Object,
      required: true
    },
    name: {
      type: String,
      default: "default"
    },
    props: {
      type: Object
    },
    tag: {
      type: String,
      default: "div"
    }
  },
  render() {
    const slot = this.component.$slots[this.name](this.props);
    return h(this.tag, {}, slot);
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/TabbedChildMixin-6975e117.mjs
var TabbedMixin = (cmp) => defineComponent({
  mixins: [ProviderParentMixin(cmp, Sorted)],
  components: {
    [script.name]: script,
    [SlotComponent.name]: SlotComponent
  },
  emits: ["update:modelValue"],
  props: {
    modelValue: [String, Number],
    variant: [String, Object],
    size: String,
    animated: {
      type: Boolean,
      default: true
    },
    vertical: {
      type: Boolean,
      default: false
    },
    position: String,
    destroyOnHide: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      activeId: this.modelValue,
      contentHeight: 0,
      isTransitioning: false
    };
  },
  computed: {
    activeItem() {
      return this.activeId !== void 0 && this.activeId !== null ? this.childItems.filter((i) => i.newValue === this.activeId)[0] : this.items[0];
    },
    activeIndex() {
      return this.childItems.findIndex((item) => item.newValue === this.activeId);
    },
    items() {
      return this.sortedItems;
    }
  },
  watch: {
    modelValue(value) {
      if (this.activeId !== value) {
        this.performAction(value);
      }
    }
  },
  methods: {
    childClick(child) {
      if (this.activeId !== child.newValue) {
        this.performAction(child.newValue);
        this.$emit("update:modelValue", this.activeId);
      }
    },
    clickFirstViableChild(startingIndex, forward) {
      let direction = forward ? 1 : -1;
      let newIndex = startingIndex;
      for (; newIndex !== this.activeIndex; newIndex = mod(newIndex + direction, this.childItems.length)) {
        if (this.childItems[newIndex].visible && !this.childItems[newIndex].disabled) {
          break;
        }
      }
      this.childClick(this.childItems[newIndex]);
    },
    next() {
      let newIndex = mod(this.activeIndex + 1, this.childItems.length);
      this.clickFirstViableChild(newIndex, true);
    },
    prev() {
      let newIndex = mod(this.activeIndex - 1, this.childItems.length);
      this.clickFirstViableChild(newIndex, false);
    },
    homePressed() {
      if (this.childItems.length < 1) {
        return;
      }
      this.clickFirstViableChild(0, true);
    },
    endPressed() {
      if (this.childItems.length < 1) {
        return;
      }
      this.clickFirstViableChild(this.childItems.length - 1, false);
    },
    performAction(newId) {
      const oldValue = this.activeId;
      const oldTab = oldValue !== void 0 && oldValue !== null ? this.childItems.filter((i) => i.newValue === oldValue)[0] : this.items[0];
      this.activeId = newId;
      if (oldTab && this.activeItem) {
        oldTab.deactivate(this.activeItem.index);
        this.activeItem.activate(oldTab.index);
      }
    }
  }
});
var TabbedChildMixin = (parentCmp) => defineComponent({
  mixins: [InjectedChildMixin(parentCmp, Sorted$1)],
  props: {
    value: [String, Number],
    label: String,
    icon: String,
    iconPack: String,
    visible: {
      type: Boolean,
      default: true
    },
    headerClass: [String, Array, Object]
  },
  data() {
    return {
      transitionName: void 0,
      newValue: this.value
    };
  },
  computed: {
    isActive() {
      return this.parent.activeItem === this;
    },
    elementClasses() {
      return [];
    }
  },
  methods: {
    activate(oldIndex) {
      this.transitionName = this.index < oldIndex ? this.parent.vertical ? "slide-down" : "slide-next" : this.parent.vertical ? "slide-up" : "slide-prev";
    },
    deactivate(newIndex) {
      this.transitionName = newIndex < this.index ? this.parent.vertical ? "slide-down" : "slide-next" : this.parent.vertical ? "slide-up" : "slide-prev";
    }
  },
  render() {
    if (this.parent.destroyOnHide) {
      if (!this.isActive || !this.visible)
        return;
    }
    const content = this.$slots.default ? this.$slots.default() : [];
    const vnode = withDirectives(h("div", {
      class: this.elementClasses,
      "data-id": `${parentCmp}-${this.newValue}`
    }, content), [[vShow, this.isActive && this.visible]]);
    if (this.parent.animated) {
      return h(Transition, {
        "name": this.transitionName,
        "onBeforeEnter": () => {
          this.parent.isTransitioning = true;
        },
        "onAfterEnter": () => {
          this.parent.isTransitioning = false;
        }
      }, () => [vnode]);
    }
    return vnode;
  }
});

// node_modules/@oruga-ui/oruga-next/dist/esm/steps.mjs
var script24 = defineComponent({
  name: "OSteps",
  components: {
    [script4.name]: script4,
    [script.name]: script
  },
  configField: "steps",
  mixins: [BaseComponentMixin, MatchMediaMixin, TabbedMixin("step")],
  props: {
    iconPack: String,
    iconPrev: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "steps.iconPrev", "chevron-left");
      }
    },
    iconNext: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "steps.iconNext", "chevron-right");
      }
    },
    hasNavigation: {
      type: Boolean,
      default: true
    },
    animated: {
      type: Boolean,
      default: true
    },
    labelPosition: {
      type: String,
      validator(value) {
        return [
          "bottom",
          "right",
          "left"
        ].indexOf(value) > -1;
      },
      default: "bottom"
    },
    rounded: {
      type: Boolean,
      default: true
    },
    ariaNextLabel: String,
    ariaPreviousLabel: String,
    rootClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    verticalClass: [String, Function, Array],
    positionClass: [String, Function, Array],
    stepsClass: [String, Function, Array],
    animatedClass: [String, Function, Array],
    stepMarkerRoundedClass: [String, Function, Array],
    stepDividerClass: [String, Function, Array],
    stepMarkerClass: [String, Function, Array],
    stepContentClass: [String, Function, Array],
    stepContentTransitioningClass: [String, Function, Array],
    stepNavigationClass: [String, Function, Array],
    stepLinkClass: [String, Function, Array],
    stepLinkClickableClass: [String, Function, Array],
    stepLinkLabelClass: [String, Function, Array],
    stepLinkLabelPositionClass: [String, Function, Array],
    mobileClass: [String, Function, Array]
  },
  computed: {
    wrapperClasses() {
      return [
        this.computedClass("rootClass", "o-steps__wrapper"),
        { [this.computedClass("sizeClass", "o-steps--", this.size)]: this.size },
        { [this.computedClass("verticalClass", "o-steps__wrapper-vertical")]: this.vertical },
        { [this.computedClass("positionClass", "o-steps__wrapper-position-", this.position)]: this.position && this.vertical },
        { [this.computedClass("mobileClass", "o-steps--mobile")]: this.isMatchMedia }
      ];
    },
    mainClasses() {
      return [
        this.computedClass("stepsClass", "o-steps"),
        { [this.computedClass("animatedClass", "o-steps--animated")]: this.animated }
      ];
    },
    stepDividerClasses() {
      return [
        this.computedClass("stepDividerClass", "o-steps__divider")
      ];
    },
    stepMarkerClasses() {
      return [
        this.computedClass("stepMarkerClass", "o-steps__marker"),
        { [this.computedClass("stepMarkerRoundedClass", "o-steps__marker--rounded")]: this.rounded }
      ];
    },
    stepContentClasses() {
      return [
        this.computedClass("stepContentClass", "o-steps__content"),
        { [this.computedClass("stepContentTransitioningClass", "o-steps__content-transitioning")]: this.isTransitioning }
      ];
    },
    stepNavigationClasses() {
      return [
        this.computedClass("stepNavigationClass", "o-steps__navigation")
      ];
    },
    stepLinkLabelClasses() {
      return [
        this.computedClass("stepLinkLabelClass", "o-steps__title")
      ];
    },
    activeItem() {
      return this.childItems.filter((i) => i.newValue === this.activeId)[0] || this.items[0];
    },
    hasPrev() {
      return !!this.prevItem;
    },
    nextItem() {
      let nextItem = null;
      let idx = this.activeItem ? this.items.indexOf(this.activeItem) + 1 : 0;
      for (; idx < this.items.length; idx++) {
        if (this.items[idx].visible) {
          nextItem = this.items[idx];
          break;
        }
      }
      return nextItem;
    },
    prevItem() {
      if (!this.activeItem) {
        return null;
      }
      let prevItem = null;
      for (let idx = this.items.indexOf(this.activeItem) - 1; idx >= 0; idx--) {
        if (this.items[idx].visible) {
          prevItem = this.items[idx];
          break;
        }
      }
      return prevItem;
    },
    hasNext() {
      return !!this.nextItem;
    },
    navigationProps() {
      return {
        previous: {
          disabled: !this.hasPrev,
          action: this.prev
        },
        next: {
          disabled: !this.hasNext,
          action: this.next
        }
      };
    }
  },
  methods: {
    stepLinkClasses(childItem) {
      return [
        this.computedClass("stepLinkClass", "o-steps__link"),
        { [this.computedClass("stepLinkLabelPositionClass", "o-steps__link-label-", this.labelPosition)]: this.labelPosition },
        { [this.computedClass("stepLinkClickableClass", "o-steps__link-clickable")]: this.isItemClickable(childItem) }
      ];
    },
    isItemClickable(stepItem) {
      if (stepItem.clickable === void 0) {
        return stepItem.index < this.activeItem.index;
      }
      return stepItem.clickable;
    },
    prev() {
      if (this.hasPrev) {
        this.childClick(this.prevItem);
      }
    },
    next() {
      if (this.hasNext) {
        this.childClick(this.nextItem);
      }
    }
  }
});
var _hoisted_17 = {
  key: 1
};
function render23(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_icon = resolveComponent("o-icon");
  const _component_o_button = resolveComponent("o-button");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.wrapperClasses
    },
    [createVNode(
      "nav",
      {
        class: _ctx.mainClasses
      },
      [(openBlock(true), createBlock(
        Fragment,
        null,
        renderList(_ctx.items, (childItem, index29) => {
          return withDirectives((openBlock(), createBlock(
            "div",
            {
              key: childItem.newValue,
              class: childItem.itemClasses
            },
            [index29 > 0 ? (openBlock(), createBlock(
              "span",
              {
                key: 0,
                class: _ctx.stepDividerClasses
              },
              null,
              2
            )) : createCommentVNode("v-if", true), createVNode(
              "a",
              {
                class: _ctx.stepLinkClasses(childItem),
                onClick: ($event) => _ctx.isItemClickable(childItem) && _ctx.childClick(childItem)
              },
              [createVNode(
                "div",
                {
                  class: _ctx.stepMarkerClasses
                },
                [childItem.icon ? createVNode(
                  _component_o_icon,
                  {
                    key: 0,
                    icon: childItem.icon,
                    pack: childItem.iconPack,
                    size: _ctx.size
                  },
                  null,
                  8,
                  ["icon", "pack", "size"]
                ) : childItem.step ? (openBlock(), createBlock(
                  "span",
                  _hoisted_17,
                  toDisplayString(childItem.step),
                  1
                )) : createCommentVNode("v-if", true)],
                2
              ), createVNode(
                "div",
                {
                  class: _ctx.stepLinkLabelClasses
                },
                toDisplayString(childItem.label),
                3
              )],
              10,
              ["onClick"]
            )],
            2
          )), [[vShow, childItem.visible]]);
        }),
        128
      ))],
      2
    ), createVNode(
      "section",
      {
        class: _ctx.stepContentClasses
      },
      [renderSlot(_ctx.$slots, "default")],
      2
    ), renderSlot(_ctx.$slots, "navigation", {
      previous: _ctx.navigationProps.previous,
      next: _ctx.navigationProps.next
    }, () => [_ctx.hasNavigation ? (openBlock(), createBlock(
      "nav",
      {
        key: 0,
        class: _ctx.stepNavigationClasses
      },
      [createVNode(
        _component_o_button,
        {
          role: "button",
          "icon-left": _ctx.iconPrev,
          "icon-pack": _ctx.iconPack,
          "icon-both": "",
          disabled: _ctx.navigationProps.previous.disabled,
          onClick: withModifiers(_ctx.navigationProps.previous.action, ["prevent"]),
          "aria-label": _ctx.ariaPreviousLabel
        },
        null,
        8,
        ["icon-left", "icon-pack", "disabled", "onClick", "aria-label"]
      ), createVNode(
        _component_o_button,
        {
          role: "button",
          "icon-left": _ctx.iconNext,
          "icon-pack": _ctx.iconPack,
          "icon-both": "",
          disabled: _ctx.navigationProps.next.disabled,
          onClick: withModifiers(_ctx.navigationProps.next.action, ["prevent"]),
          "aria-label": _ctx.ariaNextLabel
        },
        null,
        8,
        ["icon-left", "icon-pack", "disabled", "onClick", "aria-label"]
      )],
      2
    )) : createCommentVNode("v-if", true)])],
    2
  );
}
script24.render = render23;
script24.__file = "src/components/steps/Steps.vue";
var script$18 = defineComponent({
  name: "OStepItem",
  mixins: [BaseComponentMixin, TabbedChildMixin("step")],
  configField: "steps",
  props: {
    step: [String, Number],
    variant: [String, Object],
    clickable: {
      type: Boolean,
      default: void 0
    },
    itemClass: [String, Function, Array],
    itemHeaderClass: [String, Function, Array],
    itemHeaderActiveClass: [String, Function, Array],
    itemHeaderPreviousClass: [String, Function, Array],
    itemHeaderVariantClass: [String, Function, Array]
  },
  computed: {
    elementClasses() {
      return [this.computedClass("itemClass", "o-steps__item")];
    },
    itemClasses() {
      return [this.headerClass, this.computedClass("itemHeaderClass", "o-steps__nav-item"), {
        [this.computedClass("itemHeaderVariantClass", "o-steps__nav-item--", this.variant || this.parent.variant)]: this.variant || this.parent.variant
      }, {
        [this.computedClass("itemHeaderActiveClass", "o-steps__nav-item-active")]: this.isActive
      }, {
        [this.computedClass("itemHeaderPreviousClass", "o-steps__nav-item-previous")]: this.parent.activeItem.index > this.index
      }];
    }
  }
});
script$18.__file = "src/components/steps/StepItem.vue";
var index22 = {
  install(app) {
    registerComponent(app, script24);
    registerComponent(app, script$18);
  }
};
var steps_default = index22;

// node_modules/@oruga-ui/oruga-next/dist/esm/switch.mjs
var script25 = defineComponent({
  name: "OSwitch",
  mixins: [BaseComponentMixin],
  configField: "switch",
  emits: ["update:modelValue"],
  props: {
    modelValue: [String, Number, Boolean],
    nativeValue: [String, Number, Boolean],
    disabled: Boolean,
    variant: String,
    passiveVariant: String,
    name: String,
    required: Boolean,
    size: String,
    trueValue: {
      type: [String, Number, Boolean],
      default: true
    },
    falseValue: {
      type: [String, Number, Boolean],
      default: false
    },
    rounded: {
      type: Boolean,
      default: true
    },
    position: {
      type: String,
      default: "right"
    },
    ariaLabelledby: String,
    rootClass: [String, Function, Array],
    disabledClass: [String, Function, Array],
    checkClass: [String, Function, Array],
    checkCheckedClass: [String, Function, Array],
    checkSwitchClass: [String, Function, Array],
    roundedClass: [String, Function, Array],
    labelClass: [String, Function, Array],
    sizeClass: [String, Function, Array],
    variantClass: [String, Function, Array],
    elementsWrapperClass: [String, Function, Array],
    passiveVariantClass: [String, Function, Array],
    positionClass: [String, Function, Array],
    inputClass: [String, Function, Array]
  },
  data() {
    return {
      newValue: this.modelValue,
      isMouseDown: false
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-switch"),
        { [this.computedClass("sizeClass", "o-switch--", this.size)]: this.size },
        { [this.computedClass("disabledClass", "o-switch--disabled")]: this.disabled },
        { [this.computedClass("variantClass", "o-switch--", this.variant)]: this.variant },
        { [this.computedClass("positionClass", "o-switch--", this.position)]: this.position },
        { [this.computedClass("passiveVariantClass", "o-switch--", this.passiveVariant + "-passive")]: this.passiveVariant }
      ];
    },
    inputClasses() {
      return [
        this.computedClass("inputClass", "o-switch__input")
      ];
    },
    checkClasses() {
      return [
        this.computedClass("checkClass", "o-switch__check"),
        { [this.computedClass("checkCheckedClass", "o-switch__check--checked")]: this.newValue === this.trueValue },
        { [this.computedClass("roundedClass", "o-switch--rounded")]: this.rounded }
      ];
    },
    checkSwitchClasses() {
      return [
        this.computedClass("checkSwitchClass", "o-switch__check-switch"),
        { [this.computedClass("roundedClass", "o-switch--rounded")]: this.rounded }
      ];
    },
    labelClasses() {
      return [
        this.computedClass("labelClass", "o-switch__label")
      ];
    },
    computedValue: {
      get() {
        return this.newValue;
      },
      set(value) {
        this.newValue = value;
        this.$emit("update:modelValue", this.newValue);
      }
    }
  },
  watch: {
    modelValue(value) {
      this.newValue = value;
    }
  },
  methods: {
    focus() {
      this.$refs.input.focus();
    }
  }
});
function render24(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "label",
    {
      class: _ctx.rootClasses,
      ref: "label",
      onClick: _cache[3] || (_cache[3] = (...args) => _ctx.focus(...args)),
      onKeydown: _cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.$refs.label.click(), ["prevent"]), ["enter"])),
      onMousedown: _cache[5] || (_cache[5] = ($event) => _ctx.isMouseDown = true),
      onMouseup: _cache[6] || (_cache[6] = ($event) => _ctx.isMouseDown = false),
      onMouseout: _cache[7] || (_cache[7] = ($event) => _ctx.isMouseDown = false),
      onBlur: _cache[8] || (_cache[8] = ($event) => _ctx.isMouseDown = false)
    },
    [withDirectives(createVNode(
      "input",
      {
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.computedValue = $event),
        type: "checkbox",
        ref: "input",
        class: _ctx.inputClasses,
        onClick: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["stop"])),
        disabled: _ctx.disabled,
        name: _ctx.name,
        required: _ctx.required,
        value: _ctx.nativeValue,
        "true-value": _ctx.trueValue,
        "false-value": _ctx.falseValue,
        "aria-labelledby": _ctx.ariaLabelledby
      },
      null,
      10,
      ["disabled", "name", "required", "value", "true-value", "false-value", "aria-labelledby"]
    ), [[vModelCheckbox, _ctx.computedValue]]), createVNode(
      "span",
      {
        class: _ctx.checkClasses
      },
      [createVNode(
        "span",
        {
          class: _ctx.checkSwitchClasses
        },
        null,
        2
      )],
      2
    ), createVNode(
      "span",
      {
        id: _ctx.ariaLabelledby,
        class: _ctx.labelClasses
      },
      [renderSlot(_ctx.$slots, "default")],
      10,
      ["id"]
    )],
    34
  );
}
script25.render = render24;
script25.__file = "src/components/switch/Switch.vue";
var index23 = {
  install(app) {
    registerComponent(app, script25);
  }
};
var switch_default = index23;

// node_modules/@oruga-ui/oruga-next/dist/esm/table.mjs
var script26 = defineComponent({
  name: "OTableMobileSort",
  components: {
    [script4.name]: script4,
    [script10.name]: script10,
    [script.name]: script,
    [script$13.name]: script$13
  },
  inject: ["$table"],
  emits: ["sort"],
  props: {
    currentSortColumn: Object,
    columns: Array,
    placeholder: String,
    iconPack: String,
    sortIcon: {
      type: String,
      default: "arrow-up"
    },
    sortIconSize: {
      type: String,
      default: "small"
    },
    isAsc: Boolean
  },
  data() {
    return {
      mobileSort: getValueByPath(this.currentSortColumn, "newKey"),
      defaultEvent: {
        shiftKey: true,
        altKey: true,
        ctrlKey: true
      },
      ignoreSort: false
    };
  },
  computed: {
    showPlaceholder() {
      return !this.columns || !this.columns.some((column) => getValueByPath(column, "newKey") === this.mobileSort);
    },
    sortableColumns() {
      if (!this.columns)
        return [];
      return this.columns.filter((c) => c.sortable);
    },
    isCurrentSort() {
      return getValueByPath(this.currentSortColumn, "newKey") === this.mobileSort;
    }
  },
  watch: {
    mobileSort(value) {
      if (this.currentSortColumn.newKey === value)
        return;
      const column = this.sortableColumns.filter((c) => getValueByPath(c, "newKey") === value)[0];
      this.$emit("sort", column, this.defaultEvent);
    },
    currentSortColumn(column) {
      this.mobileSort = getValueByPath(column, "newKey");
    }
  },
  methods: {
    sort() {
      const column = this.sortableColumns.filter((c) => getValueByPath(c, "newKey") === this.mobileSort)[0];
      this.$emit("sort", column, this.defaultEvent);
    }
  }
});
function render25(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_select = resolveComponent("o-select");
  const _component_o_icon = resolveComponent("o-icon");
  const _component_o_button = resolveComponent("o-button");
  const _component_o_field = resolveComponent("o-field");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.$table.mobileSortClasses
    },
    [createVNode(_component_o_field, null, {
      default: withCtx(() => [createVNode(
        _component_o_select,
        {
          modelValue: _ctx.mobileSort,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.mobileSort = $event),
          expanded: ""
        },
        {
          default: withCtx(() => [_ctx.placeholder ? withDirectives((openBlock(), createBlock(
            "option",
            {
              key: 0,
              value: {},
              selected: "",
              disabled: "",
              hidden: ""
            },
            toDisplayString(_ctx.placeholder),
            513
          )), [[vShow, _ctx.showPlaceholder]]) : createCommentVNode("v-if", true), (openBlock(true), createBlock(
            Fragment,
            null,
            renderList(_ctx.sortableColumns, (column, index29) => {
              return openBlock(), createBlock(
                "option",
                {
                  key: index29,
                  value: column.newKey
                },
                toDisplayString(column.label),
                9,
                ["value"]
              );
            }),
            128
          ))]),
          _: 1
        },
        8,
        ["modelValue"]
      ), createVNode(
        _component_o_button,
        {
          onClick: _ctx.sort
        },
        {
          default: withCtx(() => [withDirectives(createVNode(
            _component_o_icon,
            {
              icon: _ctx.sortIcon,
              pack: _ctx.iconPack,
              size: _ctx.sortIconSize,
              both: "",
              rotation: !_ctx.isAsc ? 180 : 0
            },
            null,
            8,
            ["icon", "pack", "size", "rotation"]
          ), [[vShow, _ctx.isCurrentSort]])]),
          _: 1
        },
        8,
        ["onClick"]
      )]),
      _: 1
    })],
    2
  );
}
script26.render = render25;
script26.__file = "src/components/table/TableMobileSort.vue";
var script$19 = defineComponent({
  name: "OTableColumn",
  inject: ["$table"],
  props: {
    label: String,
    customKey: [String, Number],
    field: String,
    meta: [String, Number, Boolean, Function, Object, Array],
    width: [Number, String],
    numeric: Boolean,
    position: {
      type: String,
      validator(value) {
        return [
          "left",
          "centered",
          "right"
        ].indexOf(value) > -1;
      }
    },
    searchable: Boolean,
    sortable: Boolean,
    visible: {
      type: Boolean,
      default: true
    },
    customSort: Function,
    customSearch: Function,
    sticky: Boolean,
    headerSelectable: Boolean,
    thAttrs: {
      type: Function,
      default: () => ({})
    },
    tdAttrs: {
      type: Function,
      default: () => ({})
    },
    subheading: String
  },
  data() {
    return {
      newKey: void 0
    };
  },
  computed: {
    style() {
      return {
        width: toCssDimension(this.width)
      };
    },
    hasDefaultSlot() {
      return this.$slots.default;
    },
    hasSearchableSlot() {
      return this.$slots.searchable;
    },
    hasHeaderSlot() {
      return this.$slots.header;
    },
    isHeaderUnselectable() {
      return !this.headerSelectable && this.sortable;
    }
  },
  created() {
    if (!this.$table) {
      throw new Error("You should wrap oTableColumn on a oTable");
    }
    this.newKey = this.$table._nextSequence();
    this.$table._addColumn(this);
  },
  beforeUnmount() {
    this.$table._removeColumn(this);
  },
  render() {
    return h("span", { "data-id": this.newKey }, this.label);
  }
});
script$19.__file = "src/components/table/TableColumn.vue";
var script$23 = defineComponent({
  name: "OTablePagination",
  components: {
    [script$16.name]: script$16
  },
  emits: ["update:currentPage", "page-change"],
  props: {
    paginated: Boolean,
    total: [Number, String],
    perPage: [Number, String],
    currentPage: [Number, String],
    paginationSimple: Boolean,
    paginationSize: String,
    rounded: Boolean,
    iconPack: String,
    rootClass: [String, Array, Object],
    ariaNextLabel: String,
    ariaPreviousLabel: String,
    ariaPageLabel: String,
    ariaCurrentLabel: String
  },
  data() {
    return {
      newCurrentPage: this.currentPage
    };
  },
  watch: {
    currentPage(newVal) {
      this.newCurrentPage = newVal;
    }
  },
  methods: {
    pageChanged(page) {
      this.newCurrentPage = page > 0 ? page : 1;
      this.$emit("update:currentPage", this.newCurrentPage);
      this.$emit("page-change", this.newCurrentPage);
    }
  }
});
var _hoisted_18 = {
  key: 0
};
function render$17(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_pagination = resolveComponent("o-pagination");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClass
    },
    [createVNode("div", null, [renderSlot(_ctx.$slots, "default")]), createVNode("div", null, [_ctx.paginated ? (openBlock(), createBlock("div", _hoisted_18, [createVNode(
      _component_o_pagination,
      {
        "icon-pack": _ctx.iconPack,
        total: _ctx.total,
        "per-page": _ctx.perPage,
        simple: _ctx.paginationSimple,
        size: _ctx.paginationSize,
        current: _ctx.newCurrentPage,
        rounded: _ctx.rounded,
        onChange: _ctx.pageChanged,
        "aria-next-label": _ctx.ariaNextLabel,
        "aria-previous-label": _ctx.ariaPreviousLabel,
        "aria-page-label": _ctx.ariaPageLabel,
        "aria-current-label": _ctx.ariaCurrentLabel
      },
      null,
      8,
      ["icon-pack", "total", "per-page", "simple", "size", "current", "rounded", "onChange", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label"]
    )])) : createCommentVNode("v-if", true)])],
    2
  );
}
script$23.render = render$17;
script$23.__file = "src/components/table/TablePagination.vue";
var script$32 = defineComponent({
  name: "OTable",
  components: {
    [script4.name]: script4,
    [script6.name]: script6,
    [script.name]: script,
    [script2.name]: script2,
    [script15.name]: script15,
    [SlotComponent.name]: SlotComponent,
    [script26.name]: script26,
    [script$19.name]: script$19,
    [script$23.name]: script$23
  },
  mixins: [BaseComponentMixin, MatchMediaMixin],
  configField: "table",
  inheritAttrs: false,
  provide() {
    return {
      $table: this
    };
  },
  emits: [
    "page-change",
    "click",
    "dblclick",
    "contextmenu",
    "check",
    "check-all",
    "update:checkedRows",
    "select",
    "update:selected",
    "filters-change",
    "details-open",
    "details-close",
    "update:openedDetailed",
    "mouseenter",
    "mouseleave",
    "sort",
    "sorting-priority-removed",
    "dragstart",
    "dragend",
    "drop",
    "dragleave",
    "dragover",
    "cell-click",
    "columndragstart",
    "columndragend",
    "columndrop",
    "columndragleave",
    "columndragover"
  ],
  props: {
    data: {
      type: Array,
      default: () => []
    },
    columns: {
      type: Array,
      default: () => []
    },
    bordered: Boolean,
    striped: Boolean,
    narrowed: Boolean,
    hoverable: Boolean,
    loading: Boolean,
    detailed: Boolean,
    checkable: Boolean,
    headerCheckable: {
      type: Boolean,
      default: true
    },
    checkboxPosition: {
      type: String,
      default: "left",
      validator: (value) => {
        return [
          "left",
          "right"
        ].indexOf(value) >= 0;
      }
    },
    selected: Object,
    isRowSelectable: {
      type: Function,
      default: () => true
    },
    focusable: Boolean,
    customIsChecked: Function,
    isRowCheckable: {
      type: Function,
      default: () => true
    },
    checkedRows: {
      type: Array,
      default: () => []
    },
    mobileCards: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "table.mobileCards", true);
      }
    },
    defaultSort: [String, Array],
    defaultSortDirection: {
      type: String,
      default: "asc"
    },
    sortIcon: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "table.sortIcon", "arrow-up");
      }
    },
    sortIconSize: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "table.sortIconSize", "small");
      }
    },
    paginated: Boolean,
    currentPage: {
      type: Number,
      default: 1
    },
    perPage: {
      type: [Number, String],
      default: () => {
        return getValueByPath(getOptions(), "table.perPage", 20);
      }
    },
    showDetailIcon: {
      type: Boolean,
      default: true
    },
    detailIcon: {
      type: String,
      default: "chevron-right"
    },
    paginationPosition: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "table.paginationPosition", "bottom");
      },
      validator: (value) => {
        return [
          "bottom",
          "top",
          "both"
        ].indexOf(value) >= 0;
      }
    },
    backendSorting: Boolean,
    backendFiltering: Boolean,
    rowClass: {
      type: Function,
      default: () => ""
    },
    openedDetailed: {
      type: Array,
      default: () => []
    },
    hasDetailedVisible: {
      type: Function,
      default: () => true
    },
    detailKey: {
      type: String,
      default: ""
    },
    customDetailRow: {
      type: Boolean,
      default: false
    },
    detailTransition: {
      type: String,
      default: ""
    },
    backendPagination: Boolean,
    total: {
      type: [Number, String],
      default: 0
    },
    iconPack: String,
    mobileSortPlaceholder: String,
    customRowKey: String,
    draggable: {
      type: Boolean,
      default: false
    },
    draggableColumn: {
      type: Boolean,
      default: false
    },
    scrollable: Boolean,
    ariaNextLabel: String,
    ariaPreviousLabel: String,
    ariaPageLabel: String,
    ariaCurrentLabel: String,
    stickyHeader: Boolean,
    height: [Number, String],
    filtersEvent: {
      type: String,
      default: ""
    },
    debounceSearch: Number,
    showHeader: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "table.showHeader", true);
      }
    },
    stickyCheckbox: {
      type: Boolean,
      default: false
    },
    paginationRounded: Boolean,
    rootClass: [String, Function, Array],
    tableClass: [String, Function, Array],
    wrapperClass: [String, Function, Array],
    footerClass: [String, Function, Array],
    emptyClass: [String, Function, Array],
    detailedClass: [String, Function, Array],
    borderedClass: [String, Function, Array],
    stripedClass: [String, Function, Array],
    narrowedClass: [String, Function, Array],
    hoverableClass: [String, Function, Array],
    thClass: [String, Function, Array],
    tdClass: [String, Function, Array],
    thPositionClass: [String, Function, Array],
    thStickyClass: [String, Function, Array],
    thCheckboxClass: [String, Function, Array],
    thCurrentSortClass: [String, Function, Array],
    thSortableClass: [String, Function, Array],
    thUnselectableClass: [String, Function, Array],
    thSortIconClass: [String, Function, Array],
    thDetailedClass: [String, Function, Array],
    tdPositionClass: [String, Function, Array],
    tdStickyClass: [String, Function, Array],
    tdCheckboxClass: [String, Function, Array],
    tdDetailedChevronClass: [String, Function, Array],
    trSelectedClass: [String, Function, Array],
    stickyHeaderClass: [String, Function, Array],
    scrollableClass: [String, Function, Array],
    mobileSortClass: [String, Function, Array],
    paginationWrapperClass: [String, Function, Array],
    mobileClass: [String, Function, Array],
    thSubheadingClass: [String, Function, Array]
  },
  data() {
    return {
      visibleDetailRows: this.openedDetailed,
      newData: this.data,
      newDataTotal: this.backendPagination ? this.total : this.data.length,
      newCheckedRows: [...this.checkedRows],
      lastCheckedRowIndex: null,
      newCurrentPage: this.currentPage,
      currentSortColumn: {},
      isAsc: true,
      filters: {},
      defaultSlots: [],
      firstTimeSort: true,
      sequence: 1,
      isDraggingRow: false,
      isDraggingColumn: false
    };
  },
  mounted() {
    this.$nextTick(() => {
      this.checkSort();
    });
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-table__root"),
        { [this.computedClass("mobileClass", "o-table__wrapper--mobile")]: this.isMobile }
      ];
    },
    tableClasses() {
      return [
        this.computedClass("tableClass", "o-table"),
        { [this.computedClass("borderedClass", "o-table--bordered")]: this.bordered },
        { [this.computedClass("stripedClass", "o-table--striped")]: this.striped },
        { [this.computedClass("narrowedClass", "o-table--narrowed")]: this.narrowed },
        { [this.computedClass("hoverableClass", "o-table--hoverable")]: (this.hoverable || this.focusable) && this.visibleData.length },
        { [this.computedClass("emptyClass", "o-table--table__empty")]: !this.visibleData.length }
      ];
    },
    tableWrapperClasses() {
      return [
        this.computedClass("wrapperClass", "o-table__wrapper"),
        { [this.computedClass("stickyHeaderClass", "o-table__wrapper--sticky-header")]: this.stickyHeader },
        { [this.computedClass("scrollableClass", "o-table__wrapper--scrollable")]: this.isScrollable },
        { [this.computedClass("mobileClass", "o-table__wrapper--mobile")]: this.isMobile }
      ];
    },
    footerClasses() {
      return [
        this.computedClass("footerClass", "o-table__footer")
      ];
    },
    thBaseClasses() {
      return [
        this.computedClass("thClass", "o-table__th")
      ];
    },
    tdBaseClasses() {
      return [
        this.computedClass("tdClass", "o-table__td")
      ];
    },
    thCheckboxClasses() {
      return [
        ...this.thBaseClasses,
        this.computedClass("thCheckboxClass", "o-table__th-checkbox")
      ];
    },
    thDetailedClasses() {
      return [
        ...this.thBaseClasses,
        this.computedClass("thDetailedClass", "o-table__th--detailed")
      ];
    },
    thSubheadingClasses() {
      return [
        ...this.thBaseClasses,
        this.computedClass("thSubheadingClass", "o-table__th")
      ];
    },
    tdCheckboxClasses() {
      return [
        ...this.tdBaseClasses,
        this.computedClass("tdCheckboxClass", "o-table__td-checkbox"),
        ...this.thStickyClasses({ sticky: this.stickyCheckbox })
      ];
    },
    detailedClasses() {
      return [
        this.computedClass("detailedClass", "o-table__detail")
      ];
    },
    tdDetailedChevronClasses() {
      return [
        ...this.tdBaseClasses,
        this.computedClass("tdDetailedChevronClass", "o-table__td-chevron")
      ];
    },
    mobileSortClasses() {
      return [
        this.computedClass("mobileSortClass", "o-table__mobile-sort")
      ];
    },
    paginationWrapperClasses() {
      return [
        this.computedClass("paginationWrapperClass", "o-table__pagination")
      ];
    },
    tableWrapperStyle() {
      return {
        height: toCssDimension(this.height)
      };
    },
    visibleData() {
      if (!this.paginated)
        return this.newData;
      const currentPage = this.newCurrentPage;
      const perPage = this.perPage;
      if (this.newData.length <= perPage) {
        return this.newData;
      } else {
        const start = (currentPage - 1) * perPage;
        const end = start + parseInt(perPage, 10);
        return this.newData.slice(start, end);
      }
    },
    visibleColumns() {
      if (!this.newColumns)
        return this.newColumns;
      return this.newColumns.filter((column) => {
        return column.visible || column.visible === void 0;
      });
    },
    isAllChecked() {
      const validVisibleData = this.visibleData.filter((row) => this.isRowCheckable(row));
      if (validVisibleData.length === 0)
        return false;
      const isAllChecked = validVisibleData.some((currentVisibleRow) => {
        return indexOf(this.newCheckedRows, currentVisibleRow, this.customIsChecked) < 0;
      });
      return !isAllChecked;
    },
    isAllUncheckable() {
      const validVisibleData = this.visibleData.filter((row) => this.isRowCheckable(row));
      return validVisibleData.length === 0;
    },
    hasSortablenewColumns() {
      return this.newColumns.some((column) => {
        return column.sortable;
      });
    },
    hasSearchablenewColumns() {
      return this.newColumns.some((column) => {
        return column.searchable;
      });
    },
    columnCount() {
      let count = this.visibleColumns.length;
      count += this.checkable ? 1 : 0;
      count += this.detailed && this.showDetailIcon ? 1 : 0;
      return count;
    },
    showDetailRowIcon() {
      return this.detailed && this.showDetailIcon;
    },
    isScrollable() {
      if (this.scrollable)
        return true;
      if (!this.newColumns)
        return false;
      return this.newColumns.some((column) => {
        return column.sticky;
      });
    },
    newColumns() {
      if (this.columns && this.columns.length) {
        return this.columns.map((column) => {
          const vnode = createVNode(script$19, column, (props) => {
            const vnode2 = h("span", {}, getValueByPath(props.row, column.field));
            return [vnode2];
          });
          return createApp(vnode).provide("$table", this).mount(document.createElement("div"));
        });
      }
      return this.defaultSlots;
    },
    isMobile() {
      return this.mobileCards && this.isMatchMedia;
    },
    hasCustomSubheadings() {
      if (this.$slots.subheading)
        return true;
      return this.newColumns.some((column) => {
        return column.subheading || column.$slots.subheading;
      });
    },
    canDragRow() {
      return this.draggable && !this.isDraggingColumn;
    },
    canDragColumn() {
      return this.draggableColumn && !this.isDraggingRow;
    }
  },
  watch: {
    data: {
      handler(value) {
        this.newData = value;
        if (!this.backendFiltering) {
          this.newData = value.filter((row) => this.isRowFiltered(row));
        }
        if (!this.backendSorting) {
          this.sort(this.currentSortColumn, true);
        }
        if (!this.backendPagination) {
          this.newDataTotal = this.newData.length;
        }
      },
      deep: true
    },
    total(newTotal) {
      if (!this.backendPagination)
        return;
      this.newDataTotal = newTotal;
    },
    currentPage(newValue) {
      this.newCurrentPage = newValue;
    },
    checkedRows: {
      handler(rows) {
        this.newCheckedRows = [...rows];
      },
      deep: true
    },
    debounceSearch: {
      handler(value) {
        this.debouncedHandleFiltersChange = debounce(this.handleFiltersChange, value);
      },
      immediate: true
    },
    filters: {
      handler(value) {
        if (this.debounceSearch) {
          this.debouncedHandleFiltersChange(value);
        } else {
          this.handleFiltersChange(value);
        }
      },
      deep: true
    },
    openedDetailed(expandedRows) {
      this.visibleDetailRows = expandedRows;
    },
    newCurrentPage(newVal) {
      this.$emit("update:currentPage", newVal);
    }
  },
  methods: {
    thClasses(column) {
      return [
        ...this.thBaseClasses,
        ...this.thStickyClasses(column),
        column.thAttrs && getValueByPath(column.thAttrs(column), "class"),
        { [this.computedClass("thCurrentSortClass", "o-table__th-current-sort")]: this.currentSortColumn === column },
        { [this.computedClass("thSortableClass", "o-table__th--sortable")]: column.sortable },
        { [this.computedClass("thUnselectableClass", "o-table__th--unselectable")]: column.isHeaderUnselectable },
        { [this.computedClass("thPositionClass", "o-table__th--", column.position)]: column.position }
      ];
    },
    thStickyClasses(column) {
      return [
        { [this.computedClass("thStickyClass", "o-table__th--sticky")]: column.sticky }
      ];
    },
    rowClasses(row, index29) {
      return [
        this.rowClass(row, index29),
        { [this.computedClass("trSelectedClass", "o-table__tr--selected")]: this.isRowSelected(row, this.selected) }
      ];
    },
    thSortIconClasses() {
      return [
        this.computedClass("thSortIconClass", "o-table__th__sort-icon")
      ];
    },
    tdClasses(row, column) {
      return [
        ...this.tdBaseClasses,
        column.tdAttrs && getValueByPath(column.tdAttrs(row, column), "class"),
        { [this.computedClass("tdPositionClass", "o-table__td--", column.position)]: column.position },
        { [this.computedClass("tdStickyClass", "o-table__td--sticky")]: column.sticky }
      ];
    },
    onFiltersEvent(event) {
      this.$emit(`filters-event-${this.filtersEvent}`, { event, filters: this.filters });
    },
    handleFiltersChange(value) {
      if (this.backendFiltering) {
        this.$emit("filters-change", value);
      } else {
        this.newData = this.data.filter((row) => this.isRowFiltered(row));
        if (!this.backendPagination) {
          this.newDataTotal = this.newData.length;
        }
        if (!this.backendSorting) {
          if (Object.keys(this.currentSortColumn).length > 0) {
            this.doSortSingleColumn(this.currentSortColumn);
          }
        }
      }
    },
    sortBy(array, key, fn, isAsc) {
      let sorted2 = [];
      if (fn && typeof fn === "function") {
        sorted2 = [...array].sort((a, b) => fn(a, b, isAsc));
      } else {
        sorted2 = [...array].sort((a, b) => {
          let newA = getValueByPath(a, key);
          let newB = getValueByPath(b, key);
          if (typeof newA === "boolean" && typeof newB === "boolean") {
            return isAsc ? newA > newB ? 1 : -1 : newA > newB ? -1 : 1;
          }
          if (!newA && newA !== 0)
            return 1;
          if (!newB && newB !== 0)
            return -1;
          if (newA === newB)
            return 0;
          newA = typeof newA === "string" ? newA.toUpperCase() : newA;
          newB = typeof newB === "string" ? newB.toUpperCase() : newB;
          return isAsc ? newA > newB ? 1 : -1 : newA > newB ? -1 : 1;
        });
      }
      return sorted2;
    },
    sort(column, updatingData = false, event = null) {
      if (!column || !column.sortable)
        return;
      if (!updatingData) {
        this.isAsc = column === this.currentSortColumn ? !this.isAsc : this.defaultSortDirection.toLowerCase() !== "desc";
      }
      if (!this.firstTimeSort) {
        this.$emit("sort", column.field, this.isAsc ? "asc" : "desc", event);
      }
      if (!this.backendSorting) {
        this.doSortSingleColumn(column);
      }
      this.currentSortColumn = column;
    },
    doSortSingleColumn(column) {
      this.newData = this.sortBy(this.newData, column.field, column.customSort, this.isAsc);
    },
    isRowSelected(row, selected) {
      if (!selected) {
        return false;
      }
      if (this.customRowKey) {
        return row[this.customRowKey] === selected[this.customRowKey];
      }
      return row === selected;
    },
    isRowChecked(row) {
      return indexOf(this.newCheckedRows, row, this.customIsChecked) >= 0;
    },
    removeCheckedRow(row) {
      const index29 = indexOf(this.newCheckedRows, row, this.customIsChecked);
      if (index29 >= 0) {
        this.newCheckedRows.splice(index29, 1);
      }
    },
    checkAll() {
      const isAllChecked = this.isAllChecked;
      this.visibleData.forEach((currentRow) => {
        if (this.isRowCheckable(currentRow)) {
          this.removeCheckedRow(currentRow);
        }
        if (!isAllChecked) {
          if (this.isRowCheckable(currentRow)) {
            this.newCheckedRows.push(currentRow);
          }
        }
      });
      this.$emit("check", this.newCheckedRows);
      this.$emit("check-all", this.newCheckedRows);
      this.$emit("update:checkedRows", this.newCheckedRows);
    },
    checkRow(row, index29, event) {
      if (!this.isRowCheckable(row))
        return;
      const lastIndex = this.lastCheckedRowIndex;
      this.lastCheckedRowIndex = index29;
      if (event.shiftKey && lastIndex !== null && index29 !== lastIndex) {
        this.shiftCheckRow(row, index29, lastIndex);
      } else if (!this.isRowChecked(row)) {
        this.newCheckedRows.push(row);
      } else {
        this.removeCheckedRow(row);
      }
      this.$emit("check", this.newCheckedRows, row);
      this.$emit("update:checkedRows", this.newCheckedRows);
    },
    shiftCheckRow(row, index29, lastCheckedRowIndex) {
      const subset = this.visibleData.slice(Math.min(index29, lastCheckedRowIndex), Math.max(index29, lastCheckedRowIndex) + 1);
      const shouldCheck = !this.isRowChecked(row);
      subset.forEach((item) => {
        this.removeCheckedRow(item);
        if (shouldCheck && this.isRowCheckable(item)) {
          this.newCheckedRows.push(item);
        }
      });
    },
    selectRow(row, index29) {
      this.$emit("click", row, index29);
      if (this.selected === row)
        return;
      if (!this.isRowSelectable(row))
        return;
      this.$emit("select", row, this.selected);
      this.$emit("update:selected", row);
    },
    toggleDetails(obj) {
      const found = this.isVisibleDetailRow(obj);
      if (found) {
        this.closeDetailRow(obj);
        this.$emit("details-close", obj);
      } else {
        this.openDetailRow(obj);
        this.$emit("details-open", obj);
      }
      this.$emit("update:openedDetailed", this.visibleDetailRows);
    },
    openDetailRow(obj) {
      const index29 = this.handleDetailKey(obj);
      this.visibleDetailRows.push(index29);
    },
    closeDetailRow(obj) {
      const index29 = this.handleDetailKey(obj);
      const i = this.visibleDetailRows.indexOf(index29);
      if (i >= 0) {
        this.visibleDetailRows.splice(i, 1);
      }
    },
    isVisibleDetailRow(obj) {
      const index29 = this.handleDetailKey(obj);
      return this.visibleDetailRows.indexOf(index29) >= 0;
    },
    isActiveDetailRow(row) {
      return this.detailed && !this.customDetailRow && this.isVisibleDetailRow(row);
    },
    isActiveCustomDetailRow(row) {
      return this.detailed && this.customDetailRow && this.isVisibleDetailRow(row);
    },
    isRowFiltered(row) {
      for (const key in this.filters) {
        if (!this.filters[key])
          continue;
        const input = this.filters[key];
        const column = this.newColumns.filter((c) => c.field === key)[0];
        if (column && column.customSearch && typeof column.customSearch === "function") {
          if (!column.customSearch(row, input))
            return false;
        } else {
          const value = getValueByPath(row, key);
          if (value == null)
            return false;
          if (Number.isInteger(value)) {
            if (value !== Number(input))
              return false;
          } else {
            const re = new RegExp(escapeRegExpChars(input), "i");
            if (Array.isArray(value)) {
              const valid = value.some((val) => re.test(removeDiacriticsFromString(val)) || re.test(val));
              if (!valid)
                return false;
            } else {
              if (!re.test(removeDiacriticsFromString(value)) && !re.test(value)) {
                return false;
              }
            }
          }
        }
      }
      return true;
    },
    handleDetailKey(index29) {
      const key = this.detailKey;
      return !key.length || !index29 ? index29 : index29[key];
    },
    checkSort() {
      if (this.newColumns.length && this.firstTimeSort) {
        this.initSort();
        this.firstTimeSort = false;
      } else if (this.newColumns.length) {
        if (Object.keys(this.currentSortColumn).length > 0) {
          for (let i = 0; i < this.newColumns.length; i++) {
            if (this.newColumns[i].field === this.currentSortColumn.field) {
              this.currentSortColumn = this.newColumns[i];
              break;
            }
          }
        }
      }
    },
    hasCustomFooterSlot() {
      if (this.$slots.footer) {
        const footer = this.$slots.footer();
        if (footer.length > 1)
          return true;
        const tag = footer[0].tag;
        if (tag !== "th" && tag !== "td")
          return false;
      }
      return true;
    },
    pressedArrow(pos) {
      if (!this.visibleData.length)
        return;
      let index29 = this.visibleData.indexOf(this.selected) + pos;
      index29 = index29 < 0 ? 0 : index29 > this.visibleData.length - 1 ? this.visibleData.length - 1 : index29;
      const row = this.visibleData[index29];
      if (!this.isRowSelectable(row)) {
        let newIndex = null;
        if (pos > 0) {
          for (let i = index29; i < this.visibleData.length && newIndex === null; i++) {
            if (this.isRowSelectable(this.visibleData[i]))
              newIndex = i;
          }
        } else {
          for (let i = index29; i >= 0 && newIndex === null; i--) {
            if (this.isRowSelectable(this.visibleData[i]))
              newIndex = i;
          }
        }
        if (newIndex >= 0) {
          this.selectRow(this.visibleData[newIndex]);
        }
      } else {
        this.selectRow(row);
      }
    },
    focus() {
      if (!this.focusable)
        return;
      this.$el.querySelector("table").focus();
    },
    initSort() {
      if (!this.defaultSort)
        return;
      let sortField = "";
      let sortDirection = this.defaultSortDirection;
      if (Array.isArray(this.defaultSort)) {
        sortField = this.defaultSort[0];
        if (this.defaultSort[1]) {
          sortDirection = this.defaultSort[1];
        }
      } else {
        sortField = this.defaultSort;
      }
      const sortColumn = this.newColumns.filter((column) => column.field === sortField)[0];
      if (sortColumn) {
        this.isAsc = sortDirection.toLowerCase() !== "desc";
        this.sort(sortColumn, true);
      }
    },
    handleDragStart(event, row, index29) {
      if (!this.draggable)
        return;
      this.$emit("dragstart", { event, row, index: index29 });
    },
    handleDragEnd(event, row, index29) {
      if (!this.draggable)
        return;
      this.$emit("dragend", { event, row, index: index29 });
    },
    handleDrop(event, row, index29) {
      if (!this.draggable)
        return;
      this.$emit("drop", { event, row, index: index29 });
    },
    handleDragOver(event, row, index29) {
      if (!this.draggable)
        return;
      this.$emit("dragover", { event, row, index: index29 });
    },
    handleDragLeave(event, row, index29) {
      if (!this.draggable)
        return;
      this.$emit("dragleave", { event, row, index: index29 });
    },
    handleColumnDragStart(event, column, index29) {
      if (!this.canDragColumn)
        return;
      this.isDraggingColumn = true;
      this.$emit("columndragstart", { event, column, index: index29 });
    },
    handleColumnDragEnd(event, column, index29) {
      if (!this.canDragColumn)
        return;
      this.isDraggingColumn = false;
      this.$emit("columndragend", { event, column, index: index29 });
    },
    handleColumnDrop(event, column, index29) {
      if (!this.canDragColumn)
        return;
      this.$emit("columndrop", { event, column, index: index29 });
    },
    handleColumnDragOver(event, column, index29) {
      if (!this.canDragColumn)
        return;
      this.$emit("columndragover", { event, column, index: index29 });
    },
    handleColumnDragLeave(event, column, index29) {
      if (!this.canDragColumn)
        return;
      this.$emit("columndragleave", { event, column, index: index29 });
    },
    emitEventForRow(eventName, event, row) {
      return this.$attrs[eventName] ? this.$emit(eventName, row, event) : null;
    },
    _addColumn(column) {
      this.defaultSlots.push(column);
      const slot = this.$refs["slot"];
      if (slot && slot.children) {
        this.$nextTick(() => {
          const ids = this.defaultSlots.map((it) => `[data-id="${it.newKey}"]`).join(",");
          const sortedIds = Array.from(slot.querySelectorAll(ids)).map((el) => el.getAttribute("data-id"));
          this.defaultSlots = this.defaultSlots.sort((a, b) => sortedIds.indexOf(`${a.newKey}`) - sortedIds.indexOf(`${b.newKey}`));
        });
      }
    },
    _removeColumn(column) {
      this.defaultSlots = this.defaultSlots.filter((d) => d.newKey !== column.newKey);
    },
    _nextSequence() {
      return this.sequence++;
    }
  }
});
var _hoisted_1$1 = {
  ref: "slot",
  style: {
    "display": "none"
  }
};
var _hoisted_23 = {
  key: 0
};
var _hoisted_32 = {
  key: 1
};
var _hoisted_42 = {
  key: 1
};
var _hoisted_5 = {
  key: 0
};
var _hoisted_6 = {
  key: 1
};
var _hoisted_7 = {
  key: 2
};
var _hoisted_8 = {
  key: 1
};
var _hoisted_9 = {
  key: 1
};
var _hoisted_10 = {
  key: 2
};
var _hoisted_11 = {
  key: 0
};
var _hoisted_122 = {
  key: 2
};
function render$23(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_table_mobile_sort = resolveComponent("o-table-mobile-sort");
  const _component_o_table_pagination = resolveComponent("o-table-pagination");
  const _component_o_checkbox = resolveComponent("o-checkbox");
  const _component_o_slot_component = resolveComponent("o-slot-component");
  const _component_o_icon = resolveComponent("o-icon");
  const _component_o_input = resolveComponent("o-input");
  const _component_o_loading = resolveComponent("o-loading");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses
    },
    [createVNode(
      "div",
      _hoisted_1$1,
      [renderSlot(_ctx.$slots, "default")],
      512
    ), _ctx.isMobile && _ctx.hasSortablenewColumns ? createVNode(
      _component_o_table_mobile_sort,
      {
        key: 0,
        "current-sort-column": _ctx.currentSortColumn,
        columns: _ctx.newColumns,
        placeholder: _ctx.mobileSortPlaceholder,
        "icon-pack": _ctx.iconPack,
        "sort-icon": _ctx.sortIcon,
        "sort-icon-size": _ctx.sortIconSize,
        "is-asc": _ctx.isAsc,
        onSort: _cache[1] || (_cache[1] = (column, event) => _ctx.sort(column, null, event))
      },
      null,
      8,
      ["current-sort-column", "columns", "placeholder", "icon-pack", "sort-icon", "sort-icon-size", "is-asc"]
    ) : createCommentVNode("v-if", true), _ctx.paginated && (_ctx.paginationPosition === "top" || _ctx.paginationPosition === "both") ? renderSlot(_ctx.$slots, "pagination", {
      key: 1
    }, () => [createVNode(
      _component_o_table_pagination,
      mergeProps(_ctx.$attrs, {
        "per-page": _ctx.perPage,
        paginated: _ctx.paginated,
        total: _ctx.newDataTotal,
        "current-page": _ctx.newCurrentPage,
        "onUpdate:currentPage": _cache[2] || (_cache[2] = ($event) => _ctx.newCurrentPage = $event),
        "root-class": _ctx.paginationWrapperClasses,
        "icon-pack": _ctx.iconPack,
        rounded: _ctx.paginationRounded,
        "onPage-change": _cache[3] || (_cache[3] = (event) => _ctx.$emit("page-change", event)),
        "aria-next-label": _ctx.ariaNextLabel,
        "aria-previous-label": _ctx.ariaPreviousLabel,
        "aria-page-label": _ctx.ariaPageLabel,
        "aria-current-label": _ctx.ariaCurrentLabel
      }),
      {
        default: withCtx(() => [renderSlot(_ctx.$slots, "top-left")]),
        _: 3
      },
      16,
      ["per-page", "paginated", "total", "current-page", "root-class", "icon-pack", "rounded", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label"]
    )]) : createCommentVNode("v-if", true), createVNode(
      "div",
      {
        class: _ctx.tableWrapperClasses,
        style: _ctx.tableWrapperStyle
      },
      [createVNode(
        "table",
        {
          class: _ctx.tableClasses,
          tabindex: !_ctx.focusable ? false : 0,
          onKeydown: [_cache[4] || (_cache[4] = withKeys(withModifiers(($event) => _ctx.pressedArrow(-1), ["self", "prevent"]), ["up"])), _cache[5] || (_cache[5] = withKeys(withModifiers(($event) => _ctx.pressedArrow(1), ["self", "prevent"]), ["down"]))]
        },
        [_ctx.$slots.caption ? (openBlock(), createBlock("caption", _hoisted_23, [renderSlot(_ctx.$slots, "caption")])) : createCommentVNode("v-if", true), _ctx.newColumns.length && _ctx.showHeader ? (openBlock(), createBlock("thead", _hoisted_32, [createVNode("tr", null, [_ctx.showDetailRowIcon ? (openBlock(), createBlock(
          "th",
          {
            key: 0,
            class: _ctx.thDetailedClasses
          },
          null,
          2
        )) : createCommentVNode("v-if", true), _ctx.checkable && _ctx.checkboxPosition === "left" ? (openBlock(), createBlock(
          "th",
          {
            key: 1,
            class: _ctx.thCheckboxClasses
          },
          [_ctx.headerCheckable ? createVNode(
            _component_o_checkbox,
            {
              key: 0,
              autocomplete: "off",
              modelValue: _ctx.isAllChecked,
              disabled: _ctx.isAllUncheckable,
              onChange: _ctx.checkAll
            },
            null,
            8,
            ["modelValue", "disabled", "onChange"]
          ) : createCommentVNode("v-if", true)],
          2
        )) : createCommentVNode("v-if", true), (openBlock(true), createBlock(
          Fragment,
          null,
          renderList(_ctx.visibleColumns, (column, index29) => {
            return openBlock(), createBlock(
              "th",
              mergeProps({
                key: column.newKey + ":" + index29 + "header"
              }, column.thAttrs && column.thAttrs(column), {
                class: _ctx.thClasses(column),
                style: column.style,
                onClick: withModifiers(($event) => _ctx.sort(column, null, $event), ["stop"]),
                draggable: _ctx.canDragColumn,
                onDragstart: ($event) => _ctx.handleColumnDragStart($event, column, index29),
                onDragend: ($event) => _ctx.handleColumnDragEnd($event, column, index29),
                onDrop: ($event) => _ctx.handleColumnDrop($event, column, index29),
                onDragover: ($event) => _ctx.handleColumnDragOver($event, column, index29),
                onDragleave: ($event) => _ctx.handleColumnDragLeave($event, column, index29)
              }),
              [column.hasHeaderSlot ? createVNode(
                _component_o_slot_component,
                {
                  key: 0,
                  component: column,
                  scoped: "",
                  name: "header",
                  tag: "span",
                  props: {
                    column,
                    index: index29
                  }
                },
                null,
                8,
                ["component", "props"]
              ) : (openBlock(), createBlock("span", _hoisted_42, [createTextVNode(
                toDisplayString(column.label) + " ",
                1
              ), withDirectives(createVNode(
                "span",
                {
                  class: _ctx.thSortIconClasses()
                },
                [createVNode(
                  _component_o_icon,
                  {
                    icon: _ctx.sortIcon,
                    pack: _ctx.iconPack,
                    both: "",
                    size: _ctx.sortIconSize,
                    rotation: !_ctx.isAsc ? 180 : 0
                  },
                  null,
                  8,
                  ["icon", "pack", "size", "rotation"]
                )],
                2
              ), [[vShow, column.sortable && _ctx.currentSortColumn === column]])]))],
              16,
              ["onClick", "draggable", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave"]
            );
          }),
          128
        )), _ctx.checkable && _ctx.checkboxPosition === "right" ? (openBlock(), createBlock(
          "th",
          {
            key: 2,
            class: _ctx.thCheckboxClasses
          },
          [_ctx.headerCheckable ? createVNode(
            _component_o_checkbox,
            {
              key: 0,
              autocomplete: "off",
              modelValue: _ctx.isAllChecked,
              disabled: _ctx.isAllUncheckable,
              onChange: _ctx.checkAll
            },
            null,
            8,
            ["modelValue", "disabled", "onChange"]
          ) : createCommentVNode("v-if", true)],
          2
        )) : createCommentVNode("v-if", true)]), _ctx.hasSearchablenewColumns ? (openBlock(), createBlock("tr", _hoisted_5, [_ctx.showDetailRowIcon ? (openBlock(), createBlock(
          "th",
          {
            key: 0,
            class: _ctx.thDetailedClasses
          },
          null,
          2
        )) : createCommentVNode("v-if", true), _ctx.checkable && _ctx.checkboxPosition === "left" ? (openBlock(), createBlock("th", _hoisted_6)) : createCommentVNode("v-if", true), (openBlock(true), createBlock(
          Fragment,
          null,
          renderList(_ctx.visibleColumns, (column, index29) => {
            return openBlock(), createBlock(
              "th",
              mergeProps({
                key: column.newKey + ":" + index29 + "searchable"
              }, column.thAttrs && column.thAttrs(column), {
                class: _ctx.thClasses(column),
                style: column.style
              }),
              [column.searchable ? (openBlock(), createBlock(
                Fragment,
                {
                  key: 0
                },
                [column.hasSearchableSlot ? createVNode(
                  _component_o_slot_component,
                  {
                    key: 0,
                    component: column,
                    scoped: "",
                    name: "searchable",
                    tag: "span",
                    props: {
                      column,
                      filters: _ctx.filters
                    }
                  },
                  null,
                  8,
                  ["component", "props"]
                ) : createVNode(
                  _component_o_input,
                  {
                    key: 1,
                    ["on" + capitalize(_ctx.filtersEvent)]: _ctx.onFiltersEvent,
                    modelValue: _ctx.filters[column.field],
                    "onUpdate:modelValue": ($event) => _ctx.filters[column.field] = $event,
                    type: column.numeric ? "number" : "text"
                  },
                  null,
                  16,
                  ["modelValue", "onUpdate:modelValue", "type"]
                )],
                64
              )) : createCommentVNode("v-if", true)],
              16
            );
          }),
          128
        )), _ctx.checkable && _ctx.checkboxPosition === "right" ? (openBlock(), createBlock("th", _hoisted_7)) : createCommentVNode("v-if", true)])) : createCommentVNode("v-if", true), _ctx.hasCustomSubheadings ? (openBlock(), createBlock("tr", _hoisted_8, [_ctx.showDetailRowIcon ? (openBlock(), createBlock(
          "th",
          {
            key: 0,
            class: _ctx.thDetailedClasses
          },
          null,
          2
        )) : createCommentVNode("v-if", true), _ctx.checkable && _ctx.checkboxPosition === "left" ? (openBlock(), createBlock("th", _hoisted_9)) : createCommentVNode("v-if", true), (openBlock(true), createBlock(
          Fragment,
          null,
          renderList(_ctx.visibleColumns, (column, index29) => {
            return openBlock(), createBlock(
              "th",
              {
                key: column.newKey + ":" + index29 + "subheading",
                style: column.style,
                class: _ctx.thSubheadingClasses
              },
              [column.$slots && column.$slots.subheading ? createVNode(
                _component_o_slot_component,
                {
                  key: 0,
                  component: column,
                  scoped: "",
                  name: "subheading",
                  tag: "span",
                  props: {
                    column,
                    index: index29
                  }
                },
                null,
                8,
                ["component", "props"]
              ) : (openBlock(), createBlock(
                Fragment,
                {
                  key: 1
                },
                [createTextVNode(
                  toDisplayString(column.subheading),
                  1
                )],
                64
              ))],
              6
            );
          }),
          128
        )), _ctx.checkable && _ctx.checkboxPosition === "right" ? (openBlock(), createBlock("th", _hoisted_10)) : createCommentVNode("v-if", true)])) : createCommentVNode("v-if", true)])) : createCommentVNode("v-if", true), createVNode("tbody", null, [(openBlock(true), createBlock(
          Fragment,
          null,
          renderList(_ctx.visibleData, (row, index29) => {
            return openBlock(), createBlock(
              Fragment,
              {
                key: this.customRowKey ? row[this.customRowKey] : index29
              },
              [createVNode(
                "tr",
                {
                  class: _ctx.rowClasses(row, index29),
                  onClick: ($event) => _ctx.selectRow(row, index29),
                  onDblclick: ($event) => _ctx.$emit("dblclick", row),
                  onMouseenter: ($event) => _ctx.emitEventForRow("mouseenter", $event, row),
                  onMouseleave: ($event) => _ctx.emitEventForRow("mouseleave", $event, row),
                  onContextmenu: ($event) => _ctx.$emit("contextmenu", row, $event),
                  draggable: _ctx.canDragRow,
                  onDragstart: ($event) => _ctx.handleDragStart($event, row, index29),
                  onDragend: ($event) => _ctx.handleDragEnd($event, row, index29),
                  onDrop: ($event) => _ctx.handleDrop($event, row, index29),
                  onDragover: ($event) => _ctx.handleDragOver($event, row, index29),
                  onDragleave: ($event) => _ctx.handleDragLeave($event, row, index29)
                },
                [_ctx.showDetailRowIcon ? (openBlock(), createBlock(
                  "td",
                  {
                    key: 0,
                    class: _ctx.tdDetailedChevronClasses
                  },
                  [_ctx.hasDetailedVisible(row) ? createVNode(
                    _component_o_icon,
                    {
                      key: 0,
                      icon: _ctx.detailIcon,
                      pack: _ctx.iconPack,
                      rotation: _ctx.isVisibleDetailRow(row) ? 90 : 0,
                      role: "button",
                      onClick: withModifiers(($event) => _ctx.toggleDetails(row), ["stop"]),
                      clickable: "",
                      both: ""
                    },
                    null,
                    8,
                    ["icon", "pack", "rotation", "onClick"]
                  ) : createCommentVNode("v-if", true)],
                  2
                )) : createCommentVNode("v-if", true), _ctx.checkable && _ctx.checkboxPosition === "left" ? (openBlock(), createBlock(
                  "td",
                  {
                    key: 1,
                    class: _ctx.tdCheckboxClasses
                  },
                  [createVNode(
                    _component_o_checkbox,
                    {
                      autocomplete: "off",
                      disabled: !_ctx.isRowCheckable(row),
                      modelValue: _ctx.isRowChecked(row),
                      "onUpdate:modelValue": ($event) => _ctx.checkRow(row, index29, $event)
                    },
                    null,
                    8,
                    ["disabled", "modelValue", "onUpdate:modelValue"]
                  )],
                  2
                )) : createCommentVNode("v-if", true), (openBlock(true), createBlock(
                  Fragment,
                  null,
                  renderList(_ctx.visibleColumns, (column, colindex) => {
                    return openBlock(), createBlock(
                      _component_o_slot_component,
                      mergeProps({
                        key: column.newKey + index29 + ":" + colindex
                      }, column.tdAttrs && column.tdAttrs(row, column), {
                        component: column,
                        scoped: "",
                        name: "default",
                        tag: "td",
                        class: _ctx.tdClasses(row, column),
                        "data-label": column.label,
                        props: {
                          row,
                          column,
                          index: index29,
                          colindex,
                          toggleDetails: _ctx.toggleDetails
                        },
                        onClick: ($event) => _ctx.$emit("cell-click", row, column, index29, colindex, $event)
                      }),
                      null,
                      16,
                      ["component", "class", "data-label", "props", "onClick"]
                    );
                  }),
                  128
                )), _ctx.checkable && _ctx.checkboxPosition === "right" ? (openBlock(), createBlock(
                  "td",
                  {
                    key: 2,
                    class: _ctx.tdCheckboxClasses
                  },
                  [createVNode(
                    _component_o_checkbox,
                    {
                      autocomplete: "off",
                      disabled: !_ctx.isRowCheckable(row),
                      modelValue: _ctx.isRowChecked(row),
                      "onUpdate:modelvalue": ($event) => _ctx.checkRow(row, index29, $event)
                    },
                    null,
                    8,
                    ["disabled", "modelValue", "onUpdate:modelvalue"]
                  )],
                  2
                )) : createCommentVNode("v-if", true)],
                42,
                ["onClick", "onDblclick", "onMouseenter", "onMouseleave", "onContextmenu", "draggable", "onDragstart", "onDragend", "onDrop", "onDragover", "onDragleave"]
              ), createVNode(
                Transition,
                {
                  name: _ctx.detailTransition
                },
                {
                  default: withCtx(() => [_ctx.isActiveDetailRow(row) ? (openBlock(), createBlock(
                    "tr",
                    {
                      key: (_ctx.customRowKey ? row[_ctx.customRowKey] : index29) + "detail",
                      class: _ctx.detailedClasses
                    },
                    [createVNode(
                      "td",
                      {
                        colspan: _ctx.columnCount
                      },
                      [renderSlot(_ctx.$slots, "detail", {
                        row,
                        index: index29
                      })],
                      8,
                      ["colspan"]
                    )],
                    2
                  )) : createCommentVNode("v-if", true)]),
                  _: 2
                },
                1032,
                ["name"]
              ), _ctx.isActiveCustomDetailRow(row) ? renderSlot(_ctx.$slots, "detail", {
                key: 0,
                row,
                index: index29
              }) : createCommentVNode("v-if", true)],
              64
            );
          }),
          128
        )), !_ctx.visibleData.length ? (openBlock(), createBlock("tr", _hoisted_11, [createVNode(
          "td",
          {
            colspan: _ctx.columnCount
          },
          [renderSlot(_ctx.$slots, "empty")],
          8,
          ["colspan"]
        )])) : createCommentVNode("v-if", true)]), _ctx.$slots.footer ? (openBlock(), createBlock("tfoot", _hoisted_122, [createVNode(
          "tr",
          {
            class: _ctx.footerClasses
          },
          [_ctx.hasCustomFooterSlot() ? renderSlot(_ctx.$slots, "footer", {
            key: 0
          }) : (openBlock(), createBlock(
            "th",
            {
              key: 1,
              colspan: _ctx.columnCount
            },
            [renderSlot(_ctx.$slots, "footer")],
            8,
            ["colspan"]
          ))],
          2
        )])) : createCommentVNode("v-if", true)],
        42,
        ["tabindex"]
      ), renderSlot(_ctx.$slots, "loading", {}, () => [createVNode(
        _component_o_loading,
        {
          "full-page": false,
          active: _ctx.loading
        },
        null,
        8,
        ["active"]
      )])],
      6
    ), _ctx.checkable && _ctx.$slots["bottom-left"] || _ctx.paginated && (_ctx.paginationPosition === "bottom" || _ctx.paginationPosition === "both") ? renderSlot(_ctx.$slots, "pagination", {
      key: 2
    }, () => [createVNode(
      _component_o_table_pagination,
      mergeProps(_ctx.$attrs, {
        "per-page": _ctx.perPage,
        paginated: _ctx.paginated,
        total: _ctx.newDataTotal,
        "current-page": _ctx.newCurrentPage,
        "onUpdate:currentPage": _cache[6] || (_cache[6] = ($event) => _ctx.newCurrentPage = $event),
        "root-class": _ctx.paginationWrapperClasses,
        "icon-pack": _ctx.iconPack,
        rounded: _ctx.paginationRounded,
        "onPage-change": _cache[7] || (_cache[7] = (event) => _ctx.$emit("page-change", event)),
        "aria-next-label": _ctx.ariaNextLabel,
        "aria-previous-label": _ctx.ariaPreviousLabel,
        "aria-page-label": _ctx.ariaPageLabel,
        "aria-current-label": _ctx.ariaCurrentLabel
      }),
      {
        default: withCtx(() => [renderSlot(_ctx.$slots, "bottom-left")]),
        _: 3
      },
      16,
      ["per-page", "paginated", "total", "current-page", "root-class", "icon-pack", "rounded", "aria-next-label", "aria-previous-label", "aria-page-label", "aria-current-label"]
    )]) : createCommentVNode("v-if", true)],
    2
  );
}
script$32.render = render$23;
script$32.__file = "src/components/table/Table.vue";
var index24 = {
  install(app) {
    registerComponent(app, script$32);
    registerComponent(app, script$19);
  }
};
var table_default = index24;

// node_modules/@oruga-ui/oruga-next/dist/esm/tabs.mjs
var script27 = defineComponent({
  name: "OTabs",
  mixins: [BaseComponentMixin, TabbedMixin("tab")],
  configField: "tabs",
  props: {
    type: {
      type: String,
      default: "default"
    },
    expanded: Boolean,
    animated: {
      type: Boolean,
      default: () => {
        return getValueByPath(getOptions(), "tabs.animated", true);
      }
    },
    multiline: Boolean,
    rootClass: [String, Function, Array],
    positionClass: [String, Function, Array],
    expandedClass: [String, Function, Array],
    verticalClass: [String, Function, Array],
    multilineClass: [String, Function, Array],
    navTabsClass: [String, Function, Array],
    navSizeClass: [String, Function, Array],
    navPositionClass: [String, Function, Array],
    navTypeClass: [String, Function, Array],
    contentClass: [String, Function, Array],
    transitioningClass: [String, Function, Array],
    tabItemWrapperClass: [String, Function, Array]
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-tabs"),
        { [this.computedClass("positionClass", "o-tabs--", this.position)]: this.position && this.vertical },
        { [this.computedClass("expandedClass", "o-tabs--fullwidth")]: this.expanded },
        { [this.computedClass("verticalClass", "o-tabs--vertical")]: this.vertical },
        { [this.computedClass("multilineClass", "o-tabs--multiline")]: this.multiline }
      ];
    },
    itemWrapperClasses() {
      return [
        this.computedClass("tabItemWrapperClass", "o-tabs__nav-item-wrapper")
      ];
    },
    navClasses() {
      return [
        this.computedClass("navTabsClass", "o-tabs__nav"),
        { [this.computedClass("navSizeClass", "o-tabs__nav--", this.size)]: this.size },
        { [this.computedClass("navPositionClass", "o-tabs__nav--", this.position)]: this.position && !this.vertical },
        { [this.computedClass("navTypeClass", "o-tabs__nav--", this.type)]: this.type }
      ];
    },
    contentClasses() {
      return [
        this.computedClass("contentClass", "o-tabs__content"),
        { [this.computedClass("transitioningClass", "o-tabs__content--transitioning")]: this.isTransitioning }
      ];
    }
  }
});
function render26(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_o_slot_component = resolveComponent("o-slot-component");
  const _component_o_icon = resolveComponent("o-icon");
  return openBlock(), createBlock(
    "div",
    {
      class: _ctx.rootClasses
    },
    [createVNode(
      "nav",
      {
        class: _ctx.navClasses,
        role: "tablist",
        "aria-orientation": _ctx.vertical ? "vertical" : "horizontal"
      },
      [renderSlot(_ctx.$slots, "start"), (openBlock(true), createBlock(
        Fragment,
        null,
        renderList(_ctx.items, (childItem) => {
          return withDirectives((openBlock(), createBlock(
            "div",
            {
              key: childItem.newValue,
              onKeydown: [_cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.prev(...args), ["prevent"]), ["left"])), _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.next(...args), ["prevent"]), ["right"])), _cache[3] || (_cache[3] = withKeys(withModifiers((...args) => _ctx.prev(...args), ["prevent"]), ["up"])), _cache[4] || (_cache[4] = withKeys(withModifiers((...args) => _ctx.next(...args), ["prevent"]), ["down"])), _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.homePressed(...args), ["prevent"]), ["home"])), _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.endPressed(...args), ["prevent"]), ["end"]))],
              class: _ctx.itemWrapperClasses,
              role: "tab",
              "aria-controls": `${childItem.value}-content`,
              "aria-selected": `${childItem.isActive}`
            },
            [childItem.$slots.header ? createVNode(
              _component_o_slot_component,
              {
                key: 0,
                component: childItem,
                tag: childItem.tag,
                name: "header",
                onClick: ($event) => _ctx.childClick(childItem),
                onKeydown: [withKeys(withModifiers(_ctx.prev, ["prevent"]), ["left"]), withKeys(withModifiers(_ctx.next, ["prevent"]), ["right"]), withKeys(withModifiers(_ctx.prev, ["prevent"]), ["up"]), withKeys(withModifiers(_ctx.next, ["prevent"]), ["down"]), withKeys(withModifiers(_ctx.homePressed, ["prevent"]), ["home"]), withKeys(withModifiers(_ctx.endPressed, ["prevent"]), ["end"])],
                class: childItem.headerClasses
              },
              null,
              8,
              ["component", "tag", "onClick", "onKeydown", "class"]
            ) : (openBlock(), createBlock(
              resolveDynamicComponent(childItem.tag),
              {
                key: 1,
                onClick: ($event) => _ctx.childClick(childItem),
                class: childItem.headerClasses
              },
              {
                default: withCtx(() => [childItem.icon ? createVNode(
                  _component_o_icon,
                  {
                    key: 0,
                    rootClass: childItem.headerIconClasses,
                    icon: childItem.icon,
                    pack: childItem.iconPack,
                    size: _ctx.size
                  },
                  null,
                  8,
                  ["rootClass", "icon", "pack", "size"]
                ) : createCommentVNode("v-if", true), createVNode(
                  "span",
                  {
                    class: childItem.headerTextClasses
                  },
                  toDisplayString(childItem.label),
                  3
                )]),
                _: 2
              },
              1032,
              ["onClick", "class"]
            ))],
            42,
            ["aria-controls", "aria-selected"]
          )), [[vShow, childItem.visible]]);
        }),
        128
      )), renderSlot(_ctx.$slots, "end")],
      10,
      ["aria-orientation"]
    ), createVNode(
      "section",
      {
        class: _ctx.contentClasses
      },
      [renderSlot(_ctx.$slots, "default")],
      2
    )],
    2
  );
}
script27.render = render26;
script27.__file = "src/components/tabs/Tabs.vue";
var script$110 = defineComponent({
  name: "OTabItem",
  mixins: [BaseComponentMixin, TabbedChildMixin("tab")],
  configField: "tabs",
  props: {
    disabled: Boolean,
    tag: {
      type: String,
      default: () => {
        return getValueByPath(getOptions(), "tabs.itemTag", "button");
      }
    },
    itemClass: [String, Function, Array],
    itemHeaderClass: [String, Function, Array],
    itemHeaderActiveClass: [String, Function, Array],
    itemHeaderDisabledClass: [String, Function, Array],
    itemHeaderTypeClass: [String, Function, Array],
    itemHeaderIconClass: [String, Function, Array],
    itemHeaderTextClass: [String, Function, Array]
  },
  computed: {
    elementClasses() {
      return [
        this.computedClass("itemClass", "o-tab-item__content")
      ];
    },
    headerClasses() {
      return [
        this.computedClass("itemHeaderClass", "o-tabs__nav-item"),
        { [this.computedClass("itemHeaderActiveClass", "o-tabs__nav-item-{*}--active", this.parent.type)]: this.isActive },
        { [this.computedClass("itemHeaderDisabledClass", "o-tabs__nav-item-{*}--disabled", this.parent.type)]: this.disabled },
        { [this.computedClass("itemHeaderTypeClass", "o-tabs__nav-item-", this.parent.type)]: this.parent.type }
      ];
    },
    headerIconClasses() {
      return [
        this.computedClass("itemHeaderIconClass", "o-tabs__nav-item-icon")
      ];
    },
    headerTextClasses() {
      return [
        this.computedClass("itemHeaderTextClass", "o-tabs__nav-item-text")
      ];
    }
  }
});
script$110.__file = "src/components/tabs/TabItem.vue";
var index25 = {
  install(app) {
    registerComponent(app, script27);
    registerComponent(app, script$110);
  }
};
var tabs_default = index25;

// node_modules/@oruga-ui/oruga-next/dist/esm/timepicker.mjs
var index26 = {
  install(app) {
    registerComponent(app, script12);
  }
};
var timepicker_default = index26;

// node_modules/@oruga-ui/oruga-next/dist/esm/tooltip.mjs
var index27 = {
  install(app) {
    registerComponent(app, script22);
  }
};
var tooltip_default = index27;

// node_modules/@oruga-ui/oruga-next/dist/esm/upload.mjs
var script28 = defineComponent({
  name: "OUpload",
  mixins: [BaseComponentMixin, FormElementMixin],
  configField: "upload",
  inheritAttrs: false,
  emits: ["update:modelValue"],
  props: {
    modelValue: [Object, File, Array],
    multiple: Boolean,
    disabled: Boolean,
    accept: String,
    dragDrop: Boolean,
    variant: {
      type: String
    },
    native: {
      type: Boolean,
      default: false
    },
    expanded: {
      type: Boolean,
      default: false
    },
    rootClass: [String, Function, Array],
    draggableClass: [String, Function, Array],
    variantClass: [String, Function, Array],
    expandedClass: [String, Function, Array],
    disabledClass: [String, Function, Array],
    hoveredClass: [String, Function, Array]
  },
  data() {
    return {
      newValue: this.modelValue,
      dragDropFocus: false
    };
  },
  computed: {
    rootClasses() {
      return [
        this.computedClass("rootClass", "o-upl"),
        { [this.computedClass("expandedClass", "o-upl--expanded")]: this.expanded },
        { [this.computedClass("disabledClass", "o-upl--disabled")]: this.disabled }
      ];
    },
    draggableClasses() {
      return [
        this.computedClass("draggableClass", "o-upl__draggable"),
        { [this.computedClass("hoveredClass", "o-upl__draggable--hovered")]: !this.variant && this.dragDropFocus },
        { [this.computedClass("variantClass", "o-upl__draggable--hovered-", this.variant)]: this.variant && this.dragDropFocus }
      ];
    },
    $elementRef() {
      return "input";
    }
  },
  watch: {
    modelValue(value) {
      this.newValue = value;
      if (!value || Array.isArray(value) && value.length === 0) {
        this.$refs.input.value = null;
      }
      !this.isValid && !this.dragDrop && this.checkHtml5Validity();
    }
  },
  methods: {
    onFileChange(event) {
      if (this.disabled)
        return;
      if (this.dragDrop)
        this.updateDragDropFocus(false);
      const value = event.target.files || event.dataTransfer.files;
      if (value.length === 0) {
        if (!this.newValue)
          return;
        if (this.native)
          this.newValue = null;
      } else if (!this.multiple) {
        if (this.dragDrop && value.length !== 1)
          return;
        else {
          const file = value[0];
          if (this.checkType(file))
            this.newValue = file;
          else if (this.newValue) {
            this.newValue = null;
            this.clearInput();
          } else {
            this.clearInput();
            this.checkHtml5Validity();
            return;
          }
        }
      } else {
        let newValues = false;
        if (this.native || !this.newValue) {
          this.newValue = [];
          newValues = true;
        }
        for (let i = 0; i < value.length; i++) {
          const file = value[i];
          if (this.checkType(file)) {
            this.newValue.push(file);
            newValues = true;
          }
        }
        if (!newValues)
          return;
      }
      this.$emit("update:modelValue", this.newValue);
      !this.dragDrop && this.checkHtml5Validity();
    },
    clearInput() {
      this.$refs.input.value = null;
    },
    updateDragDropFocus(focus) {
      if (!this.disabled) {
        this.dragDropFocus = focus;
      }
    },
    checkType(file) {
      if (!this.accept)
        return true;
      const types = this.accept.split(",");
      if (types.length === 0)
        return true;
      for (let i = 0; i < types.length; i++) {
        const type = types[i].trim();
        if (type) {
          if (type.substring(0, 1) === ".") {
            const extension = file.name.toLowerCase().slice(-type.length);
            if (extension === type.toLowerCase()) {
              return true;
            }
          } else {
            if (file.type.match(type))
              return true;
          }
        }
      }
      return false;
    }
  }
});
function render27(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(
    "label",
    {
      class: _ctx.rootClasses
    },
    [!_ctx.dragDrop ? renderSlot(_ctx.$slots, "default", {
      key: 0
    }) : (openBlock(), createBlock(
      "div",
      {
        key: 1,
        class: _ctx.draggableClasses,
        onMouseenter: _cache[1] || (_cache[1] = ($event) => _ctx.updateDragDropFocus(true)),
        onMouseleave: _cache[2] || (_cache[2] = ($event) => _ctx.updateDragDropFocus(false)),
        onDragover: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.updateDragDropFocus(true), ["prevent"])),
        onDragleave: _cache[4] || (_cache[4] = withModifiers(($event) => _ctx.updateDragDropFocus(false), ["prevent"])),
        onDragenter: _cache[5] || (_cache[5] = withModifiers(($event) => _ctx.updateDragDropFocus(true), ["prevent"])),
        onDrop: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.onFileChange(...args), ["prevent"]))
      },
      [renderSlot(_ctx.$slots, "default")],
      34
    )), createVNode(
      "input",
      mergeProps({
        ref: "input",
        type: "file"
      }, _ctx.$attrs, {
        multiple: _ctx.multiple,
        accept: _ctx.accept,
        disabled: _ctx.disabled,
        onChange: _cache[7] || (_cache[7] = (...args) => _ctx.onFileChange(...args))
      }),
      null,
      16,
      ["multiple", "accept", "disabled"]
    )],
    2
  );
}
script28.render = render27;
script28.__file = "src/components/upload/Upload.vue";
var index28 = {
  install(app) {
    registerComponent(app, script28);
  }
};
var upload_default = index28;

// node_modules/@oruga-ui/oruga-next/dist/esm/index.mjs
var components = Object.freeze({
  __proto__: null,
  Autocomplete: autocomplete_default,
  Button: button_default,
  Carousel: carousel_default,
  Checkbox: checkbox_default,
  Collapse: collapse_default,
  Datepicker: datepicker_default,
  Datetimepicker: datetimepicker_default,
  Dropdown: dropdown_default,
  Field: field_default,
  Icon: icon_default,
  Input: input_default,
  Inputitems: inputitems_default,
  Loading: loading_default,
  Modal: modal_default,
  Notification: notification_default,
  Pagination: pagination_default,
  Radio: radio_default,
  Select: select_default,
  Skeleton: skeleton_default,
  Sidebar: sidebar_default,
  Slider: slider_default,
  Steps: steps_default,
  Switch: switch_default,
  Table: table_default,
  Tabs: tabs_default,
  Timepicker: timepicker_default,
  Tooltip: tooltip_default,
  Upload: upload_default
});
var Oruga = {
  install(app, options = {}) {
    setVueInstance(app);
    const defaultConfig = getOptions();
    setOptions(merge(defaultConfig, options, true));
    for (const componentKey in components) {
      registerPlugin(app, components[componentKey]);
    }
    registerComponentProgrammatic(app, "config", Programmatic);
  }
};
var esm_default = Oruga;

// dep:@oruga-ui_oruga-next
var oruga_ui_oruga_next_default = esm_default;
export {
  autocomplete_default as Autocomplete,
  button_default as Button,
  carousel_default as Carousel,
  checkbox_default as Checkbox,
  collapse_default as Collapse,
  Plugin as Config,
  Programmatic as ConfigProgrammatic,
  datepicker_default as Datepicker,
  datetimepicker_default as Datetimepicker,
  dropdown_default as Dropdown,
  field_default as Field,
  icon_default as Icon,
  input_default as Input,
  inputitems_default as Inputitems,
  loading_default as Loading,
  LoadingProgrammatic,
  modal_default as Modal,
  ModalProgrammatic,
  notification_default as Notification,
  NotificationProgrammatic,
  pagination_default as Pagination,
  radio_default as Radio,
  select_default as Select,
  sidebar_default as Sidebar,
  skeleton_default as Skeleton,
  slider_default as Slider,
  steps_default as Steps,
  switch_default as Switch,
  table_default as Table,
  tabs_default as Tabs,
  timepicker_default as Timepicker,
  tooltip_default as Tooltip,
  upload_default as Upload,
  oruga_ui_oruga_next_default as default,
  useProgrammatic
};
//# sourceMappingURL=@oruga-ui_oruga-next.js.map
